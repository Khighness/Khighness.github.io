<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ANTLR学习笔记 | Khighness</title><meta name="keywords" content="开源,编译原理,规则引擎"><meta name="author" content="Khighness"><meta name="copyright" content="Khighness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ANTLR 是功能强大的解析器生成器，用于读取，处理，执行或翻译结构化文本或二进制文件。 它被广泛用于构建语言，工具和框架。">
<meta property="og:type" content="article">
<meta property="og:title" content="ANTLR学习笔记">
<meta property="og:url" content="https://www.parak.top/posts/49052/index.html">
<meta property="og:site_name" content="Khighness">
<meta property="og:description" content="ANTLR 是功能强大的解析器生成器，用于读取，处理，执行或翻译结构化文本或二进制文件。 它被广泛用于构建语言，工具和框架。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/top/bg-92.jpg">
<meta property="article:published_time" content="2024-03-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-08T18:22:18.145Z">
<meta property="article:author" content="Khighness">
<meta property="article:tag" content="开源">
<meta property="article:tag" content="编译原理">
<meta property="article:tag" content="规则引擎">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/top/bg-92.jpg"><link rel="shortcut icon" href="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/avatar/K.jpg"><link rel="canonical" href="https://www.parak.top/posts/49052/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16576652";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1279324689&amp;web_id=1279324689"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Khighness","link":"链接: ","source":"来源: Khighness","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-09 02:22:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/iconfont/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Khighness" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/avatar/Khighness.jpg" onerror="onerror=null;src='https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/404.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://khighness-blog.oss-cn-shanghai.aliyuncs.com/top/bg-92.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Khighness</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ANTLR学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-09T16:00:00.000Z" title="发表于 2024-03-10 00:00:00">2024-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-08T18:22:18.145Z" title="更新于 2024-04-09 02:22:18">2024-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E8%AF%91/">编译</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">70.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>259分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ANTLR学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ANTLR-解析器生成器"><a href="#ANTLR-解析器生成器" class="headerlink" title="ANTLR 解析器生成器"></a>ANTLR 解析器生成器</h1><p>ANTLR（ANother Tool for Language Recognition 另一种语言识别工具）是功能强大的解析器生成器，用于读取，处理，执行或翻译结构化文本或二进制文件。 它被广泛用于构建语言，工具和框架。 ANTLR通过语法生成可以构建和遍历语法树的语法分析器。</p>
<p>一门语言的正式描述称为**语法(grammer)**，ANTLR能够为该语言生成一个语法分析器，并自动建立语法分析树—-一种描述语法与输入文本匹配关系的数据结构。ANTLR也能够自动生成树的遍历器，这样就可以访问树中的节点，执行自定义的业务逻辑代码。</p>
<h2 id="ANTLR4的新特点"><a href="#ANTLR4的新特点" class="headerlink" title="ANTLR4的新特点"></a>ANTLR4的新特点</h2><p>ANTLR4极大地简化了匹配某些句法结构(如编程语言的算术表达式)所需的语法规则。长久以来，处理表达式都是ANTLR语法以及手工编写的递归下降语法分析器的难题。识别表达式最自然的语法对于传统的自顶向下的语法分析器生成器(如ANTLR3)是无效的，但是ANTLR4可以使用如下的左递归表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : expr &#x27;*&#x27; expr  // 匹配乘法</span><br><span class="line">     | expr &#x27;+&#x27; expr  // 匹配加法</span><br><span class="line">     | INT            // 匹配简单的整数因子</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p>类似<code>expr</code>的自引用规则是递归的，更准确地说，是**左递归(left recursive)**的，因为它的至少一个备选分支直接引用了它自己。</p>
<p>ANTLR4自动将类似expr的左递归规则重写成了等价的非左递归形式。唯一的约束是左递归必须是直接的，也就是说直接引用自身。一条规则不能匹配另外一条规则。</p>
<p>ANTLR生成的语法分析器能够自动建立语法分析树的视图，其他程序可以遍历此树，并在所需处理的结构处触发回调函数。在先前的ANTLR3中，用户需要补充语法来创建树。ANTLR4还提供了自动生成语法树遍历器的实现：监听器(listener)或者访问器(visitor)。监听器与在XML文档的解析过程中响应SAX事件的处理器相似。</p>
<p>ANTLR的<code>LL(*)</code>语法分析策略不如ANTLR4的<code>ALL(*)</code>强大，所以ANTLR3为了能够正确识别输入的文本，有时候不得不进行回溯。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><ul>
<li>OS X</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/lib</span><br><span class="line">$ sudo curl -O https://www.antlr.org/download/antlr-4.8-complete.jar</span><br><span class="line">$ export CLASSPATH=&quot;.:/usr/local/lib/antlr-4.8-complete.jar:$CLASSPATH&quot;</span><br><span class="line">$ alias antlr4=&#x27;java -jar /usr/local/lib/antlr-4.8-complete.jar&#x27;</span><br><span class="line">$ alias grun=&#x27;java org.antlr.v4.gui.TestRig&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>LINUX</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local/lib</span><br><span class="line">$ wget https://www.antlr.org/download/antlr-4.8-complete.jar</span><br><span class="line">$ <span class="built_in">export</span> CLASSPATH=<span class="string">&quot;.:/usr/local/lib/antlr-4.8-complete.jar:<span class="variable">$CLASSPATH</span>&quot;</span></span><br><span class="line">$ <span class="built_in">alias</span> antlr4=<span class="string">&#x27;java -jar /usr/local/lib/antlr-4.8-complete.jar&#x27;</span></span><br><span class="line">$ <span class="built_in">alias</span> grun=<span class="string">&#x27;java org.antlr.v4.gui.TestRig&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="VS-Code-ANTLR4-插件"><a href="#VS-Code-ANTLR4-插件" class="headerlink" title="VS Code ANTLR4 插件"></a>VS Code ANTLR4 插件</h2><h2 id="ANTLR-语法"><a href="#ANTLR-语法" class="headerlink" title="ANTLR 语法"></a>ANTLR 语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** Optional javadoc style comment */</span><br><span class="line">grammar Name; </span><br><span class="line">options &#123;...&#125;</span><br><span class="line">import ... ;</span><br><span class="line"></span><br><span class="line">tokens &#123;...&#125;</span><br><span class="line">channels &#123;...&#125; // lexer only</span><br><span class="line">@actionName &#123;...&#125;</span><br><span class="line"></span><br><span class="line">rule1 // parser and lexer rules, possibly intermingled</span><br><span class="line">...</span><br><span class="line">ruleN</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>grammer</strong>-声明语法头，类似于Java的定义</li>
<li><strong>options</strong>-选项，如语言选项，输出选项，回溯选项，记忆选项等等</li>
<li><strong>@actionName</strong>-动作（Actions）实际上是用目标语言写成的、嵌入到规则中的代码（以花括号包裹）。它们通常直接操作输入的标号，但是他们也可以用来调用相应的外部代码。常用属性或动作说明：</li>
</ul>
<ol>
<li><code>@header &#123; package com.zetyun.aiops.antlr.test; &#125;</code>这个动作很有用，即在运行脚本后，生成的类中自动带上这个包路径，避免了手动加入的麻烦。</li>
<li><code>@members &#123; int i; public TParser(TokenStream input, int foo) &#123; this(input); i = foo; &#125;&#125;</code></li>
<li><code>@after &#123;System.out.println(&quot;after matching rule; before finally&quot;);&#125;</code></li>
</ol>
<ul>
<li><strong>rule</strong>-文法的核心，表示规则，以 <code>:</code> 开始， <code>;</code> 结束， 多规则以 <code>|</code> 分隔。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ID : [a-zA-Z0-9|&#x27;_&#x27;]+ ;    //数字 </span><br><span class="line">STR:&#x27;\&#x27;&#x27; (&#x27;\&#x27;\&#x27;&#x27; | ~(&#x27;\&#x27;&#x27;))* &#x27;\&#x27;&#x27;; </span><br><span class="line">WS: [ \t\n\r]+ -&gt; skip ; // 系统级规则 ，即忽略换行与空格</span><br><span class="line"></span><br><span class="line">sqlStatement</span><br><span class="line">    : ddlStatement </span><br><span class="line">    | dmlStatement     | transactionStatement</span><br><span class="line">    | replicationStatement     | preparedStatement</span><br><span class="line">    | administrationStatement     | utilityStatement</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR-注释"><a href="#ANTLR-注释" class="headerlink" title="ANTLR 注释"></a>ANTLR 注释</h2><ul>
<li>单行、多行、javadoc风格</li>
<li>javadoc风格只能在开头使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * This grammar is an example illustrating the three kinds</span><br><span class="line"> * of comments.</span><br><span class="line"> */</span><br><span class="line">grammar T;</span><br><span class="line"></span><br><span class="line">/* a multi-line</span><br><span class="line">  comment</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/** This rule matches a declarator for my language */</span><br><span class="line"></span><br><span class="line">decl : ID ; // match a variable name</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR-标识符"><a href="#ANTLR-标识符" class="headerlink" title="ANTLR 标识符"></a>ANTLR 标识符</h2><ul>
<li>符号(Token)名大写开头</li>
<li>解析规则(Parser rule)名小写开头,后面可以跟字母、数字、下划线</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID, LPAREN, RIGHT_CURLY // token names</span><br><span class="line">expr, simpleDeclarator, d2, header_file // rule names</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR-遍历模式"><a href="#ANTLR-遍历模式" class="headerlink" title="ANTLR 遍历模式"></a>ANTLR 遍历模式</h2><h3 id="Listener-观察者模式，通过结点监听，触发处理方法"><a href="#Listener-观察者模式，通过结点监听，触发处理方法" class="headerlink" title="Listener (观察者模式，通过结点监听，触发处理方法)"></a>Listener (观察者模式，通过结点监听，触发处理方法)</h3><ul>
<li>程序员不需要显示定义遍历语法树的顺序，实现简单</li>
<li>缺点，不能显示控制遍历语法树的顺序</li>
<li>动作代码与文法产生式解耦，利于文法产生式的重用</li>
<li>没有返回值，需要使用map、栈等结构在节点间传值</li>
</ul>
<h3 id="Visitor-访问者模式，主动遍历"><a href="#Visitor-访问者模式，主动遍历" class="headerlink" title="Visitor (访问者模式，主动遍历)"></a>Visitor (访问者模式，主动遍历)</h3><ul>
<li>程序员可以显示定义遍历语法树的顺序</li>
<li>不需要与antlr遍历类ParseTreeWalker一起使用，直接对tree操作</li>
<li>动作代码与文法产生式解耦，利于文法产生式的重用</li>
<li>visitor方法可以直接返回值，返回值的类型必须一致，不需要使用map这种节点间传值方式，效率高</li>
</ul>
<h2 id="Hello-ANTLR4"><a href="#Hello-ANTLR4" class="headerlink" title="Hello ANTLR4"></a>Hello ANTLR4</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Define a grammar called Hello 定义一个语法名字：Hello</span><br><span class="line">grammar Hello;</span><br><span class="line">r  : &#x27;hello&#x27; ID ;         // match keyword hello followed by an identifier 匹配关键字hello，后跟标识符</span><br><span class="line">ID : [a-z]+ ;             // match lower-case identifiers 匹配全是小写字母的标识符</span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip ; // skip spaces, tabs, newlines  跳过空格，制表符，换行符</span><br></pre></td></tr></table></figure>

<p>然后使用<code>antlr</code>和<code>grun</code>别名来运行测试它,<code>grun</code>相当于一个主程序</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">antlr4 Hello.g4</span><br><span class="line">javac *.java</span><br><span class="line">grun Hello r -tokens</span><br></pre></td></tr></table></figure>

<p>或者打印出LISP风格文本格式的语法分析树</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grun Hello r -tree </span><br><span class="line">hello parrt</span><br></pre></td></tr></table></figure>

<p><code>grun</code>的命令行参数选项:</p>
<ul>
<li><strong>-tokens</strong>-打印出词法符号流</li>
<li><strong>-tree</strong>-以LISP格式打印出语法分析树</li>
<li><strong>-gui</strong>-在对话框中以可视化方式显示语法分析树</li>
<li><strong>-ps file.ps</strong>-以PostScript格式生成可视化语法分析树，然后将其存储于file.ps。</li>
<li><strong>-encoding encodinggame</strong>-若当前的区域设定无法正确读取输入，使用这个选项制定测试组件</li>
<li><strong>-trace</strong>-打印规则的名字以及进入和离开该规则时的词法符号。</li>
<li><strong>diagnostics</strong>-开启解析过程中的调试信息输出。通常仅在一些罕见情况下才使用它产生信息，例如输入的文本有歧义。</li>
<li><strong>-SLL</strong>-使用另外一种更快但是功能稍弱的解析策略。</li>
</ul>
<h3 id="ANTLR-元语言"><a href="#ANTLR-元语言" class="headerlink" title="ANTLR 元语言"></a>ANTLR 元语言</h3><p>为了实现一门编程语言，需要构建一个程序，读取输入的语句，对其中的词组和输入符号进行正确的处理。<strong>语言(language)**由一系列有意义的语句组成，</strong>语句(sentence)<strong>由词组组成，</strong>词组(phrase)<strong>是由更小的</strong>子词组(subphrase)<strong>和</strong>词汇符号(vocabulary sumbol)<strong>组成。一般来说，如果一个程序能够分析计算或者“执行”语句，就称之为</strong>解释器(interpreter)<strong>。这样的例子包括计算器、读取配置文件的程序和Python解释器。如果一个程序能够将一门语言的语句转换为另外一门语言的语句，称之为</strong>翻译器(translator)**。这样的例子包括Java和C#的转换器和普通的编译器。</p>
<p>为了达到目的，解释器或者翻译器需要识别出一门特定语言的所有的有意义的语句、词组和子词组。识别一个词组意味着可以将它从众多的组成部分中辨认和区分出来。例如，能够将输入的<code>&quot;sp=100;&quot;</code>识别为一个赋值语句，这意味着需要知道sp是被赋值的目标，100是要被赋予的值。与之类似，如果要识别英文语句，就需要辨认出一段对话的不同部分，例如主语、谓语和宾语。</p>
<p>识别语言的程序称为<strong>语法分析器(parser)**或者</strong>句法分析器(syntax analyzer)<strong>。</strong>句法(syntax)<strong>是指约束语言中的各个组成部分之间关系的规则，</strong>语法(grammer)<strong>是一系列规则的集合，每条规则表述出一种词汇结构。ANTLR工具能够将其转换为如同经验丰富的开发者手工构建一般的语法分析器(ANTLR是一个能够生成其他程序的程序)。ANTLR语法本身又遵循了一种专门用来描述其他语言的语法，称之为</strong>ANTLR元语言(ANTLR’s meta-language)**。</p>
<p>如果将语法分析的过程分解为两个相似但独立的任务或者说阶段时，实现起来就容易多了。就像读英文一样，不是一个字符一个字符地读句子，而是将句子看作一列单词。在识别整个句子的语法结构之前，先获取单词(词法)，再获取句子(语法)。</p>
<p>将字符聚集为<strong>单词或者符号(词法符号,token)**的过程称为</strong>词法分析(lexical analysis)<strong>或者</strong>词法符号化(tokenizing)<strong>。可以把输入文本转换为词法符号的程序称为</strong>词法分析器(lexer)<strong>。词法分析器可以将相关的词法符号归类，例如</strong>INT(整数)<strong>、</strong>ID(标识符)<strong>、</strong>FLOAT(浮点数)**等。当语法分析器不关心单个符号，而仅关心符号的类型时，词法分析器就需要将词汇符号归类。词法符号包含至少两部分信息：词法符号的类型(从而能够通过类型来识别词法结构)和该词法符号对应的文本。</p>
<p>第二个阶段是实际的语法分析过程，在这个过程中，输入的词法符号被”消费”以识别语句结构，在上例中即为赋值语句。默认情况下，ANTLR生成的语法分析器会建造一种名为<strong>语法分析树parse tree</strong>或者<strong>句法树syntax tree</strong>的数据结构，该数据结构记录了语法分析器识别出输入语句结构的过程，以及该结构的各组成部分。</p>
<p>语法分析树的内部结点是词组名，这些名字用于识别它们的子结点，并将子结点归类。根结点是最抽象的一个名字，一般使用<strong>stat</strong>(statment的简称)命名。语法分析树的叶子结点永远是输入的词法符号。句子，也即符号的线性组合，本质上是语法分析树在人脑中的串行化。为了能与其他人沟通，需要使用一串单词，使得他们能在脑海中构建出一棵相同的语法分析树。</p>
<p>通过操纵语法分析树，识别同一种语言的不同程序就能复用同一个语法分析器。另外一种解决方案，也是传统的生成语法分析器的方案，是直接在语法文件中嵌入与这种程序相关的代码。ANTLR4仍然允许这种传统的方案，不过使用语法分析树可以使程序更简洁、解耦性更强。</p>
<p>在语言的翻译过程中，一个阶段依赖于前一个阶段的计算结果和信息，因此需要多次进行**树的遍历(tree walk)**，这种情况下语法分析树也是非常有用的。在其他情况下，将一个复杂的程序分解为多个阶段会大大简化编码和测试工作，与其每个阶段都重新解析一下输入的字符流，不如首先生成语法分析树，然后多次访问其中的节点，这样更有效率。</p>
<p>由于使用一系列的规则制定语句的词汇结构，语法分析树的子树的根节点就对应语法规则的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assign : ID &#x27;=&#x27; expr; // 匹配一个类似&quot;sp=100;&quot;的赋值语句</span><br></pre></td></tr></table></figure>

<p>使用和调试ANTLR语法的一个基本要求是，理解ANTLR是如何将这样的规则转为人类可阅读的语法分析程序。</p>
<h3 id="实现一个语法分析器"><a href="#实现一个语法分析器" class="headerlink" title="实现一个语法分析器"></a>实现一个语法分析器</h3><p>ANTLR工具依据类似于之前的<code>assign</code>语法规则，产生一个<strong>递归下降语法分析器(recursive-descent parser)**。递归下降的语法分析器实际上是若干递归方法的集合，每个方法对应一条规则。下降的过程就是从语法分析树的根节点开始，朝着叶节点(词法符号)进行解析的过程。首先调用的规则，即语义符号的起始点，就会称为语法分析树的根节点。这种解析的别名是</strong>自上而下的解析**，递归下降的语法分析器仅仅是自上而下的语法分析器的一种实现。</p>
<p>下面是一个ANTLR根据assign规则生成的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assign : ID &#x27;=&#x27; expr &#x27;;&#x27;;</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">    match(ID);     <span class="comment">// 根据assign规则生成的方法</span></span><br><span class="line">    match(<span class="string">&#x27;=&#x27;</span>);    <span class="comment">// 将当前的输入符号和ID相比较，然后将其消费掉</span></span><br><span class="line">    expr();        </span><br><span class="line">    match(<span class="string">&#x27;;&#x27;</span>);    <span class="comment">// 通过调用方法expr()来匹配一个表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归下降语法分析器通过方法调用描绘出的路线图映射到了语法分析树的节点上。调用<code>match()</code>对应了语法分析树的叶子结点。</p>
<p>对<code>stat</code>语法规则的解析像是一个switch语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (token<span class="comment">/*当前的词法符号*/</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> ID:</span><br><span class="line">            assign();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IF:</span><br><span class="line">            ifstat();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WHILE:</span><br><span class="line">            whilestat();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般使用**前瞻词法符号(lookahead token)**这个术语，它其实就是下一个输入的词法符号。一个前瞻词法符号是任何一个在被匹配和消费之前就由语法分析器主动找出的词法符号。有些时候，语法分析器需要很多个前瞻词法符号来判断语义规则的哪个方案是正确的，甚至可能要从当前的词法符号的位置开始，一直分析到文件末尾才能做出判断！</p>
<h3 id="语法的歧义"><a href="#语法的歧义" class="headerlink" title="语法的歧义"></a>语法的歧义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: ID &#x27;=&#x27; expr &#x27;;&#x27; // 匹配一个赋值语句</span><br><span class="line">    | ID &#x27;=&#x27; expr &#x27;;&#x27; // 重复了前一个备选分支</span><br><span class="line">    ;</span><br><span class="line">expr: INT;</span><br></pre></td></tr></table></figure>

<p>或者下面这个嵌套了一层的歧义语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stat: expr &#x27;;&#x27;  // 表达式语句</span><br><span class="line">    | ID &#x27;(&#x27; &#x27;)&#x27; &#x27;;&#x27;  // 函数调用语句</span><br><span class="line">    ;</span><br><span class="line">expr: ID &#x27;(&#x27; &#x27;)&#x27;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一个歧义性语法通常被认为是程序设计上的bug。需要重新组织语法，使得对于每个输入的词组，语法分析器都能够选择唯一匹配的备选分支。如果语法分析器检测到该词组存在歧义，就必须在多个备选分支中做出选择。ANTLR解决歧义问题的方法是：选择所有匹配的备选分支中的第一条。</p>
<p>歧义问题在词法分析器和语法分析器中都会发生，ANTLR的解决方案使得对规则的解析能够正常进行。在词法分析器中，ANTLR解决歧义问题的方法是：匹配在语法定义中最靠前的那条词法规则。</p>
<p>比如下面的关键字和标识符冲突:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BEGIN: &#x27;begin&#x27;;  // 匹配begin关键字</span><br><span class="line">ID   : [a-z]+    // 匹配一个或者多个小写字母</span><br></pre></td></tr></table></figure>

<p>词法分析器会匹配可能的最长字符串来生成一个词法符号，这意味着，输入文本<code>beginner</code>只会匹配上例中的ID这条词法规则。ANTLR词法分析器不会把它匹配为关键字BEGIN后跟着标识符ner。</p>
<p>有时候，一门语言的语法本身就存在歧义，无论如何修改语法也不能改变这一点。例如，最常见的数学表达式<code>1+2*3</code>可以用两种方式解释，一种是像绝大多数编程语言一样，按照优先级来处理。当然可以隐式地制定表达式中的运算符优先级。</p>
<h3 id="使用语法分析树构建语言类应用程序"><a href="#使用语法分析树构建语言类应用程序" class="headerlink" title="使用语法分析树构建语言类应用程序"></a>使用语法分析树构建语言类应用程序</h3><p>为了编写一个语言类应用程序，必须对每个输入的词组或者子词组执行一些适当的操作。进行这项工作最简单的方式是操作语法分析器自动生成的语法分析树。这种方式的优点在于，可以使用Java。</p>
<p>词法分析器处理字符序列并将生成的词法符号提供给语法分析器，语法分析器随机根据这些信息来检查语法的正确性并建造出一棵语法分析树。这个过程对应的ANTLR类是<code>CharStream</code>、<code>Lexer</code>、<code>Token</code>、<code>Parser</code>以及ParseTree。连接词法分析器和语法分析器的“管道”。</p>
<p>ANTLR尽可能很多地使用共享数据结构来节约内存。语法分析树中的叶子结点(词法符号)仅仅是盛放词法符号流中的词法符号的容器。每个词法符号都记录了自己在字符序列中的开始位置和结束位置，而非保存子字符串的拷贝。其中，不存在空白字符对应的词法符号的原因是，假定词法分析器会丢弃空白字符。</p>
<p>因为语法分析树根节点包含了使用规则识别词组过程中的全部信息，它们被称为上下文(context)对象。每个上下文对象都知道自己识别出的词组中，开始和结束位置处的词法符号，同时提供访问该词组全部元素的途径。例如，AssignContext类提供了方法<code>ID()</code>和方法<code>expr()</code>来访问标识符节点和代表表达式的子树。</p>
<p>给定这些类型的具体实现，可以手工写出对语法分析树进行深度优先遍历的代码。这样，在访问其中的节点时，可以进行一切所需的操作。这个过程中的典型操作是诸如计算结果、更新数据结构或者产生输出一类的事情。实际上，可以利用ANTLR自动生成并遍历树的机制，而不需要每次都重复编写遍历树的代码。</p>
<h3 id="语法分析树监听器和访问器"><a href="#语法分析树监听器和访问器" class="headerlink" title="语法分析树监听器和访问器"></a>语法分析树监听器和访问器</h3><p>ANTLR的运行库提供了两种遍历树的机制。默认情况下，ANTLR使用内建的遍历器访问生成的语法分析树，并为每个遍历时可能触发的事件生成一个语法分析树监听器接口。监听器非常类似于XML解析器生成的SAX文档对象。SAX监听器接收类似<code>startDocument()</code>和<code>endDocument()</code>的事件通知。一个监听器的方法实际上就是回调函数，正如在图形界面程序中响应复选框点击事件一样。除了监听器的方式，还将介绍另外一种遍历语法分析树的方式：**访问者模式(visitor pattern)**。</p>
<h4 id="语法分析树监听器"><a href="#语法分析树监听器" class="headerlink" title="语法分析树监听器"></a>语法分析树监听器</h4><p>为了将遍历树时触发的事件转化为监听器的调用，ANTLR运行库提供了ParseTree-Walker类。可以自行实现ParseTreeListener接口，在其中填充自己的逻辑代码(通常是调用程序的其他部分)，从而构建出自己的语言类应用程序。</p>
<p>ANTLR为每个语法文件生成ParseTreeListener的子类，在该类中，语法中的每条规则都对应的enter方法和exit方法。例如，当遍历器访问到assign规则对应的节点时，它就会调用<code>enterAssign()</code>方法，然后将对应的语法分析树节点—-AssignContext的实例。</p>
<h4 id="语法分析树访问器"><a href="#语法分析树访问器" class="headerlink" title="语法分析树访问器"></a>语法分析树访问器</h4><p>有时候，希望控制遍历语法分析树的过程，通过显式的方法调用来访问子节点。在命令行中加入<code>-visitor</code>选项可以指示ANTLR为一个语法生成访问器接口(visitor interface)，语法中的每条规则对应接口中的一个visit方法。</p>
<p>ANTLR会提供访问器接口和一个默认实现类，只关注感兴趣的方法即可。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>语言</strong>-一门语言是一个有效语句的结合。语句由词组组成，词组由子词组组成，子词组又由更小的子词组组成，一次类推。</li>
<li><strong>语法</strong>-语法定义了语言的语义规则。语法中的每条规则定义了一种词组结构</li>
<li><strong>语义树或语法分析树</strong>-代表了语句的结构，其中的每个子树的根节点都使用了一个抽象的名字给其包含的元素命名。</li>
<li><strong>词法符号</strong>-词法符号就是一门语言的基本词汇符号，它们可以代表像是”标识符”这样的一类符号，也可以代表一个单一的运算符，或者代表一个关键字。</li>
<li><strong>词法分析器或者词法符号生成器</strong>-将输入的字符序列分解称一系列词法符号。一个词法分析器负责分析词法。</li>
<li><strong>语法分析器</strong>-语法分析器通过检查语句的结构是否符合语法规则的定义来验证该语句在特定语言中是否合法。语法分析的过程类似于走迷宫。ANTLR能够生成被称为<code>ALL(*)</code>的自顶向下的语法分析器，<code>ALL(*)</code>是指它可以利用剩余的所有输入文本来进行决策。自顶乡下的语法分析器以结果为导向，首先匹配粗粒度的规则，这样的规则通常命名为<code>program</code>或者<code>inputFile</code></li>
<li><strong>递归下降的语法分析器</strong>-这是自顶向下的语法分析器的一种实现，每条规则都对应语法分析器中的一个函数</li>
<li><strong>前向预测</strong>-语法分析器使用前向预测来进行决策，具体方法是：将输入的符号与每个备选分支的起始符号进行比较。</li>
</ul>
<h2 id="入门的ANTLR项目"><a href="#入门的ANTLR项目" class="headerlink" title="入门的ANTLR项目"></a>入门的ANTLR项目</h2><p>比如识别一些像是<code>&#123;1, 2, 3&#125;</code>和<code>&#123;1, &#123;2, 3&#125;, 4&#125;</code>这样的花括号括起来语句。</p>
<h3 id="ANTLR工具、运行库以及自动生成的代码"><a href="#ANTLR工具、运行库以及自动生成的代码" class="headerlink" title="ANTLR工具、运行库以及自动生成的代码"></a>ANTLR工具、运行库以及自动生成的代码</h3><p>在ANTLR的jar包中存在两个关键部分：ANTLR工具和ANTLR运行库(运行时语法分析)API。通常，对一个语法运行ANTLR时，指的是运行ANTLR工具，即<code>org.antlr.v4.Tool</code>类来生成一些代码(语法分析器和词法分析器)，它们能够识别使用这份语法代表的语言所写成的语句。词法分析器将输入的字符流分解为词法符号序列，然后将它们传递给能够进行语法检查的语法分析器。运行库是一个由若干类和方法组成的库，这些类和方法是自动生成的代码（如Parser,Lexer和Token）运行所必须的。因此，完成工作的一般步骤是：首先对一个语法运行ANTLR，然后将生成的代码与jar包中的运行库一起编译，最后将编译好的代码和运行库放在一起运行。</p>
<p>构建一个语言类应用程序的第一步是创建一个能够描述这种语言的语法(即合法语句结构的集合)的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line">/* 一条名为init的规则，它匹配一对花括号中的、逗号分隔的value */</span><br><span class="line">init : &#x27;&#123;&#x27; value (&#x27;,&#x27; value)*  &#x27;&#125;&#x27;;</span><br><span class="line">/* 一个value可以是嵌套的花括号结构，也可以是一个简单的整数，即INT词法符号 */</span><br><span class="line">value : init</span><br><span class="line">      | INT</span><br><span class="line">      ;</span><br><span class="line">INT:  [0-9]+;              // 定义词法符号INT，它由一个或多个数字组成</span><br><span class="line">WS:   [\t\r\n]+ -&gt; skip;   // 定义词法规则“空白符号”，丢弃之</span><br></pre></td></tr></table></figure>

<p>ANTLR语法比正则表达式功能更强大，实际上，由于嵌套的花括号结构的存在，正则表达式无法识别这样的初始化语句。正则表达式没有存储的概念，它们无法记住之前匹配过的额输入，因此，它们不能将左右花括号正确配对。</p>
<h3 id="测试生成的语法生成器"><a href="#测试生成的语法生成器" class="headerlink" title="测试生成的语法生成器"></a>测试生成的语法生成器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grun ArrayInit init -tokens </span><br><span class="line">$ &#123;99, 3, 451&#125;</span><br><span class="line">$ EOF</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grun ArrayInit init -tree</span><br><span class="line">$ &#123;99, 3, 451&#125;</span><br><span class="line">$ EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grun ArrayInit init -gui</span><br><span class="line">$ &#123;99, 3, 451&#125;</span><br><span class="line">$ EOF</span><br></pre></td></tr></table></figure>

<p>用自然语言表述，语法分析树就是，“输入的是一个由一对花括号包裹的三个值组成的初始化语句”</p>
<p><em>注意：文件结束符(end of file EOF)在类UNIX系统上的输入方法是<code>Ctrl+D</code>，在Windows上的方法是<code>Ctrl+Z</code></em></p>
<h3 id="将生成的语法分析器与Java程序集成"><a href="#将生成的语法分析器与Java程序集成" class="headerlink" title="将生成的语法分析器与Java程序集成"></a>将生成的语法分析器与Java程序集成</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ANTLRInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ANTLRInputStream</span>(System.in);</span><br><span class="line">        <span class="type">ArrayInitLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayInitLexer</span>(input);</span><br><span class="line">        <span class="type">CommonTokenStrem</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        <span class="type">ArrayInitParser</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayInitParser</span>(tokens);</span><br><span class="line">        <span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.init();</span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建一个语言类应用"><a href="#构建一个语言类应用" class="headerlink" title="构建一个语言类应用"></a>构建一个语言类应用</h3><p>可以使用ANTLR监听器在语法树的遍历中调用回调函数，比如把<code>&#123;99,3,451&#125;</code>的short数组翻译成<code>\u0063\u0003\u01c3</code>。</p>
<p>最简单的方式是使用ANTLR内置的语法分析树遍历器进行深度优先遍历，然后在它触发的一系列回调函数中进行适当的操作。这样的监听器非常类似于图形界面程序控件上的回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortToUnicodeString</span> <span class="keyword">extends</span> <span class="title class_">ArrayInitBaseListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterInit</span><span class="params">(ArrayInitPaser.InitContext ctx)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;\&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitInit</span><span class="params">(ArrayInitPaser.InitContext ctx)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;\&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterValue</span><span class="params">(ArrayInitPaser.ValueContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Integer.valueOf(ctx.INT().getText());</span><br><span class="line">        System.out.printf(<span class="string">&#x27;\\u%04x&#x27;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主程序中调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ParseTreeWalker</span> <span class="variable">walker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line">walker.walk(<span class="keyword">new</span> <span class="title class_">ShortToUnicodeString</span>(), tree);</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR-快速指南"><a href="#ANTLR-快速指南" class="headerlink" title="ANTLR 快速指南"></a>ANTLR 快速指南</h2><h3 id="匹配算术表达式的语言"><a href="#匹配算术表达式的语言" class="headerlink" title="匹配算术表达式的语言"></a>匹配算术表达式的语言</h3><p>第一个语法用于构建一个简单的计算器，其对算术表达式的处理具有十分重要的意义，因为它们很常见。为简单起见，只允许基本的算术操作符(加减乘除)、圆括号、整数以及变量出现。例子中的算术表达式限制浮点数的使用，只允许整数出现。</p>
<p>下面的示例包含了本语言的全部特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">193</span><br><span class="line">a = 5</span><br><span class="line">b = 6</span><br><span class="line">a+b*2</span><br><span class="line">(1+2)*3</span><br></pre></td></tr></table></figure>

<p>用自然语言来说，表达式语言组成的程序就是一系列语句，每个语句都由换行符终止。一个语句可以是一个表达式、一个赋值语句或者是一个空行。下面是对应的ANTLR语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">/* 起始规则，语法分析的起点 */</span><br><span class="line">prog: stat+;</span><br><span class="line">stat: expr NEWLINE</span><br><span class="line">    | ID &#x27;=&#x27; expr NEWLINE</span><br><span class="line">    | NEWLINE</span><br><span class="line">    ;</span><br><span class="line">expr: expr (&#x27;*&#x27;|&#x27;/&#x27;) expr</span><br><span class="line">    | expr (&#x27;+&#x27;|&#x27;-&#x27;) expr</span><br><span class="line">    | INT</span><br><span class="line">    | ID</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line">ID:  [a-zA-Z]+;     // 匹配标识符</span><br><span class="line">INT: [0-9]+;        // 匹配整数</span><br><span class="line">NEWLINE: &#x27;r&#x27;? &#x27;\n&#x27;; // 告诉语法分析器一个新行的开始(即语句终止标志)</span><br><span class="line">WS:  [\t]+ -&gt; skip; // 丢弃空白字符</span><br></pre></td></tr></table></figure>

<ul>
<li>语法包含一系列描述语言结构的规则。这些规则既包括类似<code>stat</code>和<code>expr</code>的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号(词法符号)的规则。</li>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
<li>使用<code>|</code>来分隔同一个语言规则的若干备选分支，使用<strong>圆括号</strong>把一些符号组合成子规则。例如，子规则<code>(&#39;*&#39;|&#39;/&#39;)</code>匹配一个乘法符号或者一个除法符号。</li>
</ul>
<p><strong>ANTLR4的最重要的新功能之一就是，它能够处理(大部分情况下)左递归规则</strong>。左递归规则是指这样的语言规则：在某个备选分支的起始位置调用了自身。例如，在上述语法中，expr规则的备选分支出现了自身expr规则。使用这种方式指定算术表达式远比传统的自顶向下语法分析器策略简单。在传统的语法分析策略中，需要为运算符的每种优先级编写一条规则。</p>
<p>词法符号定义的标记和正则表达式的元字符非常相似。</p>
<ul>
<li><code>&#39;+&#39;</code>-加号代表前面的字符必须至少出现一次（1次或多次）。</li>
<li><code>&#39;*&#39;</code>-星号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li>
<li><code>&#39;?&#39;</code>-问号代表前面的字符最多只可以出现一次（0次、或1次）</li>
</ul>
<p><em>注意：在WS词法规则后面的<code>-&gt; skip</code>操作是一条指令，告诉词法分析器匹配并丢弃空白字符。</em>通过使用正式的ANTLR标记，而非嵌入一段代码来告诉词法分析器忽略这些字符，就能避免语法和某种特定的目标语言绑定。</p>
<h3 id="利用访问器构建一个计算器"><a href="#利用访问器构建一个计算器" class="headerlink" title="利用访问器构建一个计算器"></a>利用访问器构建一个计算器</h3><p>可以使用ANTLR4的语法分析树访问器和其他的遍历器来实现语言类应用程序，从而保持语法本身的整洁。</p>
<p>首先给备选分支加上标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">grammar LabeledExpr;</span><br><span class="line">/* 起始规则，语法分析的起点 */</span><br><span class="line">prog: stat+;</span><br><span class="line">stat: expr NEWLINE        # printExpr</span><br><span class="line">    | ID &#x27;=&#x27; expr NEWLINE # assign</span><br><span class="line">    | NEWLINE             # blank</span><br><span class="line">    ;</span><br><span class="line">expr: expr op=(&#x27;*&#x27;|&#x27;/&#x27;) expr # MulDiv</span><br><span class="line">    | expr op=(&#x27;+&#x27;|&#x27;-&#x27;) expr # AddSub</span><br><span class="line">    | INT                    # int</span><br><span class="line">    | ID                     # id</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;           # parens</span><br><span class="line">    ;</span><br><span class="line">ID:  [a-zA-Z]+;     // 匹配标识符</span><br><span class="line">INT: [0-9]+;        // 匹配整数</span><br><span class="line">NEWLINE: &#x27;r&#x27;? &#x27;\n&#x27;; // 告诉语法分析器一个新行的开始(即语句终止标志)</span><br><span class="line">WS:  [ \t]+ -&gt; skip; //丢弃制表符和空白符</span><br><span class="line">MUL:  &#x27;*&#x27;;</span><br><span class="line">DIV:  &#x27;/&#x27;;</span><br><span class="line">ADD:  &#x27;+&#x27;;</span><br><span class="line">SUB:  &#x27;-&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvalVisitor</span> <span class="keyword">extends</span> <span class="title class_">LabledExprBaseVisitor</span>&lt;Integer&gt; &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; memory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ID &#x27;=&#x27; expr NEWLINE */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitAssign</span><span class="params">(LabeledExprParser.AssignContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> visit(ctx.expr());</span><br><span class="line">        memory.put(id, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expr NEWLINE */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitPrintExpr</span><span class="params">(LabeledExprParser.AssignContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> visit(ctx.expr());</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ID */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitId</span><span class="params">(LabeledExprParser.AssignContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">        <span class="keyword">if</span> (memory.containsKey(id))</span><br><span class="line">            <span class="keyword">return</span> memory.get(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* expr op=(&#x27;*&#x27;|&#x27;/&#x27;) expr */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitMulDiv</span><span class="params">(LabeledExprParser.AssignContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (ctx.op.getType() == LabledExprParser.MUL) </span><br><span class="line">            <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* expr op=(&#x27;+&#x27;|&#x27;-&#x27;) expr */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitMulDiv</span><span class="params">(LabeledExprParser.AssignContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (ctx.op.getType() == LabledExprParser.ADD) </span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用监听器构建一个翻译程序"><a href="#利用监听器构建一个翻译程序" class="headerlink" title="利用监听器构建一个翻译程序"></a>利用监听器构建一个翻译程序</h3><p>将一个Java类中的全部方法抽取出来，生成一个接口文件，保留方法签名中的空白字符和注释。</p>
<p>部分<code>Java.g4</code>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">classDeclaration :</span><br><span class="line">    &#x27;class&#x27; Identifier typeParameters? (&#x27;extends&#x27; type)?</span><br><span class="line">    (&#x27;implements&#x27; typeList)?</span><br><span class="line">    classBody;</span><br><span class="line">methodDeclaration :</span><br><span class="line">    type Identifier formalParameters (&#x27;[&#x27; &#x27;]&#x27;)* methodDelarationRest</span><br><span class="line">    | &#x27;void&#x27; Identifier formalParameters methodDelarationRest</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>基本思想是，在类定义的起始位置打印出接口定义，然后在类定义的结束位置打印出<code>&#125;</code>。在遇到每个方法定义时，将会抽取出它的签名。</p>
<p>访问器和监听器机制表现出色，它们使语法分析过程和程序本身高度分离。尽管如此，有些时候，还是需要额外的灵活性和可操控性。</p>
<h3 id="定制语法分析过程"><a href="#定制语法分析过程" class="headerlink" title="定制语法分析过程"></a>定制语法分析过程</h3><p>监听器和访问器机制是一个创举，这使得自定义的程序代码和语法本身分离开来，让语法更具可读性，避免了将语法和特定的程序混杂子一起。不过，为了灵活性和可操控性，可以直接将代码片段(动作)嵌入语法中。这些动作将被拷贝到ANTLR自动生成的递归下降语法分析器的代码中。</p>
<p>将会看到如何实现特殊的动作，叫做<strong>语义判定(samantic predicate)</strong>,它能够动态地开启或者关闭部分语法。</p>
<h4 id="在语法中嵌入任意动作"><a href="#在语法中嵌入任意动作" class="headerlink" title="在语法中嵌入任意动作"></a>在语法中嵌入任意动作</h4><p>如果不想承担建立语法分析树的开销，可以在语法分析的过程中计算并打印结果。另一个方案是，在“表达式语法”中嵌入一些代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line">@parser::members &#123;</span><br><span class="line">    int col;</span><br><span class="line">    public RowsParser(TokenStream input, int col) &#123;</span><br><span class="line">        // 自定义构造器</span><br><span class="line">        this(input);</span><br><span class="line">        this.col = col</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [int i = 0]</span><br><span class="line">    : (STUFF</span><br><span class="line">    &#123;</span><br><span class="line">        $i++;</span><br><span class="line">        if ($i == col) System.out.println($STUFF.text);</span><br><span class="line">    &#125;</span><br><span class="line">    )+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TAB : &#x27;\t&#x27; -&gt; skip; // 匹配但是不将其传递给语法分析器</span><br><span class="line">NL :  &#x27;\r&#x27;? &#x27;\n&#x27;;   // 匹配并将其传递给语法分析器</span><br><span class="line">STUFF ~[\t\r\n]+    // 匹配除tab符和换行符之外的任何字符</span><br></pre></td></tr></table></figure>

<p>语义判定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+</span><br><span class="line">group: INT sequence[$INT.int];</span><br><span class="line">sequence[int n]</span><br><span class="line">locals [int i = l;]</span><br><span class="line">: ( &#123;$i&lt;=$n&#125;? INT &#123;$i++&#125; )* // 匹配n个函数</span><br><span class="line">;</span><br><span class="line">INT : [0-9]+;</span><br><span class="line">WS : [ \t\n\r] // 丢弃所有空白字符</span><br></pre></td></tr></table></figure>

<h3 id="词法分析特性"><a href="#词法分析特性" class="headerlink" title="词法分析特性"></a>词法分析特性</h3><h4 id="孤岛语法：处理相同文件中的不同格式"><a href="#孤岛语法：处理相同文件中的不同格式" class="headerlink" title="孤岛语法：处理相同文件中的不同格式"></a>孤岛语法：处理相同文件中的不同格式</h4><p>事实上，有很多常见的文件格式包含多重语言。例如，Java文档注释中的<code>@author</code>标签等内容使用的是一种特殊的微型语言；在注释之外的一切内容都是Java代码。需要将模版语言表达式之外的文本按照不同的方式进行处理，这种情况通常称为孤岛语法。</p>
<p>ANTLR提供了一个众所周知的词法分析器特性，称为**词法分析模式(lexical mode)**，使能够方便地处理混杂着不同格式数据的文件。它的基本思想是，当词法分析器看到一些特殊的“哨兵”字符序列时，执行不同模式的切换。</p>
<p>XML是个很好的例子。一个XML解析器除了标签和实体转义时(例如<code>&amp;pound;</code>)之外的东西全部当作普通文本。当看到<code>&lt;</code>时，词法分析器会切换到“标签内部”模式；当看到<code>&gt;</code>或者<code>/&gt;</code>时，它就切换回默认模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">// 默认的“模式”，所有在标签之外的东西</span><br><span class="line">OPEN  : &#x27;&lt;&#x27;   -&gt; pushMode(INSIDE);</span><br><span class="line">COMMENT :  &#x27;&lt;!--&#x27; .*? &#x27;--&gt;&#x27;  -&gt; skip;</span><br><span class="line">EntityRef: &#x27;&amp;&#x27; [a-z]+ &#x27;;&#x27; ;</span><br><span class="line">TEXT   :  ~(&#x27;&lt;&#x27;|&#x27;&amp;&#x27;)+ ;  // 匹配任意除&lt;和&amp;之外的16位字符</span><br><span class="line"></span><br><span class="line">// ------- 所有在标签之内的东西 ------</span><br><span class="line">mode INSIDE;</span><br><span class="line">CLOSE  :  &#x27;&gt;&#x27; -&gt; popMode;</span><br><span class="line">SLASH_CLOSE :  &#x27;/&gt;&#x27; -&gt; popMode;</span><br><span class="line">EQUALS  :  &#x27;=&#x27; ;</span><br><span class="line">STRING :    &#x27;&quot;&#x27;  .*? &#x27;&quot;&#x27; ;</span><br><span class="line">SlashName  :  &#x27;/&#x27; Name;</span><br><span class="line">Name  :  ALPHA (ALPHA|DIGIT)*;</span><br><span class="line">S : [ \t\r\n] -&gt; skip;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA : [a-zA-Z];</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT  : [0-9];</span><br></pre></td></tr></table></figure>

<p>如果需要令测试组件只运行词法分析器而不运行语法分析器，可以指定参数为语法名加上一个特殊的规则名tokens。</p>
<h4 id="重写输入流"><a href="#重写输入流" class="headerlink" title="重写输入流"></a>重写输入流</h4><p>构建一个小工具，能够修改Java源代码并插入<code>java.io.Serializable</code>使用的序列化版本标识符(serialVersionUID,类似Eclipse的自动生成功能)。简单的做法是：在原先的词法符号流中插入一个适当代表常量字段的词法符号，然后打印出修改后的输入流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印除修改后的词法符号流</span></span><br><span class="line">System.out.println(extractor.rewriter.getText());</span><br></pre></td></tr></table></figure>

<p>在监听器的实现中，在类定义的起始位置触发一个插入操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStrem;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStremRewriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSerialIDListener</span> <span class="keyword">extends</span> <span class="title class_">JavaBaseListener</span> &#123;</span><br><span class="line">    TokenStreamRewriter rewiter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsertSerialIDListener</span><span class="params">(TokenStream tokens)</span> &#123;</span><br><span class="line">        rewiter = <span class="keyword">new</span> <span class="title class_">TokenStreamRewriter</span>(tokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterClassBody</span><span class="params">(JavaParser.ClassBodyContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;\n\tpublic static final long serialVersionUID = 1L;&quot;</span></span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的关键之处在于，<code>TokenStreamRewriter</code>对象实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列，在未来词法符号流被重新渲染为文本时，这些修改才会被执行。每次调用<code>getText()</code>方法时，<code>rewriter</code>对象都会执行上述队列中的指令。</p>
<h4 id="将词法符号流送入不同通道"><a href="#将词法符号流送入不同通道" class="headerlink" title="将词法符号流送入不同通道"></a>将词法符号流送入不同通道</h4><p>使用传统方法很难达到保留方法签名中的空白字符和注释，对于大多数语法，词法分析器是可以忽略空白字符和注释的。如果不想让空白字符和注释在语法中到处都是，可以让词法分析器丢弃它们。忽略却保留注释和空白的方法是将词法符号送入一个“隐藏通道”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COMMENT</span><br><span class="line">    : &#x27;/*&#x27; .*? &#x27;*/&#x27; -&gt; channel(HIDDEN)   //匹配 &#x27;/*&#x27; 和 &#x27;*/&#x27; 之间的任何东西 </span><br><span class="line">    ;</span><br><span class="line">WS  : [ \r\t\u000C\n]+ -&gt; channel(HIDDEN)</span><br></pre></td></tr></table></figure>

<p>同之前讨论的<code>-&gt; skip</code>一样，<code>-&gt; channel(HIDDEN)</code>也是一个词法分析器指令。此处，设置了这些词法符号的通道号，这样，这些词法符号就会被语法分析器忽略。词法符号流仍然保存着这些原始的词法符号序列，只不过在向语法分析器提供数据时忽略了那些处于已关闭通道的词法符号。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>实现的访问器和监听器让不需要在语法中嵌入动作就能完成计算和翻译工作。内嵌动作是进行特殊的内部控制必不可少的手段，以及切换不同的模式和隐藏通道等都可以解决一些不大但是现实的问题。</p>
<h2 id="ANTLR-设计语法"><a href="#ANTLR-设计语法" class="headerlink" title="ANTLR 设计语法"></a>ANTLR 设计语法</h2><p>ANTLR一些实用的细节，例如建立内部数据结构，提取信息，以及翻译输入内容等。研究编程语言的通用模式，将其在语句中辨识出来。一种语言模式就是一种递归的结构，例如英语的一个句子包含<code>主语-谓语动词-宾语</code>。需要从一系列有代表性的输入文件中归纳出一门语言的结构。在完成这样的归纳工作后，就可以正式实用ANTLR语法来表达这门语言了。</p>
<p>在词法层面上，不同编程语言也倾向于实用相同的结构，例如标识符、整数、字符串等等。对单词顺序和单词间依赖关系的限制来源于自然语言，逐渐发展为以下四种抽象的计算机语言模式：</p>
<ul>
<li><strong>序列</strong>-既一列元素，例如一个数组初始化语句中的值</li>
<li><strong>选择</strong>-在多种可选方案中做出选择，例如编程语言中的不同种类的语句</li>
<li><strong>词法符号依赖</strong>-一个词法符号需要和某种的另外一个词法符号匹配，例如左右括号匹配</li>
<li><strong>嵌套结构</strong>-一种自相似的语言结构，例如编程语言中的嵌套算术表达式或者嵌套语句块。</li>
</ul>
<p>为实现以上模式，语法规则只要可选方案、词法符号引用和规则引用即可<strong>Backus-Naur-Format,BNF</strong>。为方便起见，还是将这些元素划分为子规则，与<strong>正则表达式</strong>类似，子规则是用<code>括号()</code>包围的内联规则。可以用以下符号标记子规则，用于指明其中的语法片段出现的次数：<code>可选(?)</code>；<code>出现0次或多次(*)</code>；<code>至少一次(+)</code>；(扩展巴克斯-诺尔范式，Extended Backus-Naur Format)。</p>
<h3 id="从编程语言的范例代码中提取语法"><a href="#从编程语言的范例代码中提取语法" class="headerlink" title="从编程语言的范例代码中提取语法"></a>从编程语言的范例代码中提取语法</h3><p>编写语法和编写软件很相似，差异在于处理的是语言规则，而非函数或者过程(procedure)。(记住，ANTLR将会为语法中每条规则生成一个函数)。</p>
<p>任何编程语言项目的基础步骤：讨论语法的整体结构以及如何建立初始的语法框架。</p>
<p>ANTLR语法由一个为该语法命名的头部定义和一系列可以相互引用的语言规则组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grammar MyG;</span><br><span class="line">rule1 : &lt;stuff&gt;;</span><br><span class="line">rule2 : &lt;more stuff&gt;;</span><br></pre></td></tr></table></figure>

<p>和编写软件一样，必须指明需要的语言规则，既其中<code>&lt;stuff&gt;</code>的具体内容，以及哪条规则是起始规则。</p>
<p>为了给某种编程语言编写语法，必须要么精通它，要么有很多代表性的、由该语言所编写的样例程序。设计良好的语法反映了编程世界中的功能分解或者自顶向下的设计。设计起始规则的内容实际上就是实用“英语伪代码”来买描述输入文本的整体结构，和编写软件的过程有点类似。</p>
<p>从顶层开始，降低一个层次，描述起始规则右侧所指定的那些元素。它右侧的名词通常是词法符号或者尚未定义的规则。其中，词法符号是那些能够轻易识别出的单词、标点符号或者运算符。词法符号是文法的基本元素。起始规则引用了其他的、需要进一步细化的语言结构。</p>
<p>再降低一层，一个行就是一系列由逗号分隔的字段。一个字段就是一个数字或者字符串。伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file: &lt;sequence of rows that are terminated by newlines&gt;</span><br><span class="line">row: &lt;sequence of fields separated by commas&gt;;</span><br><span class="line">field: &lt;number of strings&gt;</span><br></pre></td></tr></table></figure>

<p>当完成对规则的定义后，语法草稿就成形了。</p>
<h3 id="以现有的语法规范为指南"><a href="#以现有的语法规范为指南" class="headerlink" title="以现有的语法规范为指南"></a>以现有的语法规范为指南</h3><p>一份非ANTLR格式的语法规范能够很好地知道编程者理清该语言的结构。但是请把参考手册当作一份指南，而非一份代码。</p>
<p>出于使语法更清晰的目的，参考手册的范围通常都非常宽泛，这意味着其中的语法能够匹配很多实际上不合法的语句。或者，语法可能存在歧义，能够以多种方式匹配相同的输入文本。例如。</p>
<p>刚开始的时候，辨识一条语法规则并使用伪代码编写右侧的内容是一项充满挑战的工作，不过，会随着为不同语言编写语法的过程变得越来越容易。一旦拥有了伪代码，就需要将它翻译为ANTLR标记，从而得到一个能够正常工作的语法。</p>
<h3 id="使用ANTLR语法识别常见的语言模式"><a href="#使用ANTLR语法识别常见的语言模式" class="headerlink" title="使用ANTLR语法识别常见的语言模式"></a>使用ANTLR语法识别常见的语言模式</h3><p>现在需要关注的是常见的语言模式：序列(sequence),选择(choice)，词法符号依赖(token dependency),以及嵌套结构(nested phrase)。会用正式的语法规则将特定的模式表达出来，通过这种方式，就能够掌握基本的ANTLR标记的用法。</p>
<h4 id="序列模式"><a href="#序列模式" class="headerlink" title="序列模式"></a>序列模式</h4><p>在计算机编程语言中，这种结构最常见的形式是一列元素，就像上文中的类定义中包括一系列方法一样。即使是像HTTP、POP和SMTP这样的简单的“协议语言”中，也能够看到序列模式的身影。协议的输入通常是一列指令。例如，下面是登陆一台POP服务器并获取第一条消息的指令序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">USER parrt</span><br><span class="line">PASS secret</span><br><span class="line">RETR 1</span><br></pre></td></tr></table></figure>

<p>每个指令自身也是一个序列。大多数指令由一个类似USER和RETR的关键字(保留字)，一个操作数和一个换行符构成。在上述例子中，可以说一个检索指令就是一个关键字，后面跟着一个整数，再后面是一个换行符。使用语法来表述这样的序列，只需要按照顺序将它们列出即可。在ANTLR标记中，检索指令可表达为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retr : &#x27;RETR&#x27; INT &#x27;\n&#x27; ;  // 匹配 “关键字-整数-换行符” 序列</span><br></pre></td></tr></table></figure>

<p>注意，可以直接使用类似<code>RETR</code>的常量字符来表示任意简单字符序列，诸如关键字或者标点符号等。使用语法规则来为编程语言的特定结构命名，就像在编程时将若干语句组合成一个函数。</p>
<p>使用语法规则来为编程语言的特定结构命名，就好像在编程时将若干个语句组合成一个函数。在上例中，将RETR命名为retr规则。这样，在语法的其他地方，可以直接把规则名作为简称来引用RETR。</p>
<p>序列模式的变体包括：带终止符的序列模式和带分隔符的序列模式。CSV文件同时使用了这两种模式。</p>
<p>下面是在先前的章节中使用ANTLR标记写出的伪代码语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file : (row &#x27;\n&#x27;)*;       // 以一个&#x27;\n&#x27;作为终止符的序列</span><br><span class="line">row : field (&#x27;,&#x27; field)*; // 以一个&#x27;,&#x27;作为分隔符的序列</span><br><span class="line">field : INT;              // 假设字段都是整数</span><br></pre></td></tr></table></figure>

<p>下面的语法匹配类似Java的、每个语句都由分号结束的编程语言：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stats : (stat &#x27;;&#x27;)*;  // 匹配零个或多个以&#x27;;&#x27;终止的语句</span><br></pre></td></tr></table></figure>

<p>与之相似，下面的语法匹配以逗号分隔的多个表达式，可以在一次函数调用的参数列表中找到这样的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expList : expr (&#x27;,&#x27; expr)*;</span><br></pre></td></tr></table></figure>

<p>就连ANTLR元语言也使用了序列模式。下面的语法片段显示了ANTLR是如何使用它自身的句法表达“规则定义”这条句法的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 匹配这样的结构：&#x27;规则名:&#x27;后面跟着至少一个备选分支,</span><br><span class="line">// 然后是若干条以&#x27;|&#x27;符号分隔的备选分支，最后是一个&#x27;;&#x27;</span><br><span class="line">rule ID &#x27;;&#x27; alternative (&#x27;|&#x27; alternative)* &#x27;;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="选择模式（多个备选分支）"><a href="#选择模式（多个备选分支）" class="headerlink" title="选择模式（多个备选分支）"></a>选择模式（多个备选分支）</h4><p>使用’|’符号作为“或者”来表达编程语言中的选择模式，在ANTLR的规则中，用于分隔多个可选的语法结构—-称作备选分支(alternatives)或者可生成的结果(productions)。选择模式在语法中随处可见。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field : INT | STRING;</span><br><span class="line">type : &#x27;float&#x27; | &#x27;int&#x27; | &#x27;void&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stmt: node_stmt</span><br><span class="line">    | edge_stmt</span><br><span class="line">    | attr_stmt</span><br><span class="line">    | id &#x27;=&#x27; id</span><br><span class="line">    | subgraph</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>语法中的序列模式和选择模式使能够编写语言的框架，但是这还不够，接下来，还有两种关键的模式：词法符号依赖和嵌套结构。在语法中，它们通常是一起出现的，不过，为简单起见，先来单独分析词法符号依赖模式。</p>
<h4 id="词法符号依赖模式"><a href="#词法符号依赖模式" class="headerlink" title="词法符号依赖模式"></a>词法符号依赖模式</h4><p>需要一种方法来表达对这样的词法符号的依赖。此时，如果在某个语句中看到了某个符号，就必须在同一个语句中找到和它配对的那个符号。为表达出这种语义，在语法中，使用一个序列来指明所有配对的符号，通常这些符号会把其他元素分组或者包裹起来。比如指定一个完整的向量:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector : &#x27;[&#x27; INT+ &#x27;]&#x27;;</span><br></pre></td></tr></table></figure>

<p>几乎所有的用于分组的符号都是成对出现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : expr &#x27;(&#x27; exprList? &#x27;)&#x27;</span><br><span class="line">    | expr &#x27;[&#x27; expr &#x27;]&#x27;</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>也可以在方法声明中看到左右圆括号之间的词法符号依赖模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">functionDecl</span><br><span class="line">    : type ID &#x27;(&#x27; formalParameters &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line">formalParameters</span><br><span class="line">    : formalParameter (&#x27;,&#x27; formalParameter)*</span><br><span class="line">    ;</span><br><span class="line">formalParameter</span><br><span class="line">    : type ID</span><br></pre></td></tr></table></figure>

<p><em>注意：一个有依赖符号并非必须匹配到它所依赖的符号。在C语言基础上发展起来的编程语言通常拥有a?b:c三元运算符。只有在这种情况下，?才依赖其后的:</em></p>
<p>此外，词法符号间的依赖并不意味着一定存在嵌套结构。一个向量中可能不允许出现嵌套的向量。</p>
<h4 id="嵌套模式"><a href="#嵌套模式" class="headerlink" title="嵌套模式"></a>嵌套模式</h4><p>嵌套的词组是一种自相似的语言结构，既它的子词组也遵循相同的结构。表达式是一种典型的自相似结构，它包含多个嵌套的、以运算符分隔的子表达式。与之相似，一个while循环代码块是一个嵌套在更外层代码块中的代码块。在语法中，使用递归规则来表达这种自相似的语言结构。所以，如果一条规则定义中伪代码引用了它自身，我们就需要一条递归规则 (自引用规则)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat : &#x27;while&#x27; &#x27;(&#x27; expr &#x27;)&#x27; stat  // 匹配WHILE语句</span><br><span class="line">    | &#x27;&#123;&#x27; stat* &#x27;&#125;&#x27;               // 匹配花括号中若干条语句组成的代码块</span><br><span class="line">    ...                 </span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>其中，while中的stat是一个循环结构，它可以是一个语句或者由花括号包裹的一组语句。因为stat规则在前两个备选分支中引用了自身，称它为<strong>直接递归(directly recursive)**的。如果将它的第二个备选分支抽取出来，stat规则和block规则就会互为</strong>间接递归(indirectly recursive)**的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stat: &#x27;while&#x27; &#x27;(&#x27; expr &#x27;)&#x27; stat   // 匹配WHILE语句</span><br><span class="line">    | block                       // 匹配一个语句组成的代码块</span><br><span class="line">    ...                           // 其他种类的语句</span><br><span class="line">    ;</span><br><span class="line">block: &#x27;&#123;&#x27; stat* &#x27;&#125;&#x27;;             // 匹配花括号中若干条语句组成的代码块</span><br></pre></td></tr></table></figure>

<p>大部分编程语言都包含多种形式的自相似结构，这带来的结果是语法中包含很多递归规则。下面是一个简单的例子：只有三种表达式类型：数组索引表达式、括号表达式和整数—-的编程语言。下面是用ANTLR标记书写的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : ID &#x27;[&#x27; expr &#x27;]&#x27;</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>其中的递归发生的非常自然。因为一个数组的索引值本身也是一个表达式，所以就在对应的备选分支中直接引用了expr。实际上，索引值本身也可以是一个数组索引表达式。从这个例子中可以看到，语言结构上的递归自然而然地使得语言规则发生了递归。</p>
<p>语法分析树的非叶子节点代表了规则，而叶子节点代表了词法符号。一条从根节点到任意节点的路径代表了对应的规则调用栈(同时也是ANTLR自动生成的递归下降语法分析器的调用栈)。因此，代表递归调用的路径上就会存在对多个相同规则的引用。</p>
<p>并非所有的语言都有表达式，例如数据格式定义。不过所接触的大多数语言都包含非常复杂的表达式。</p>
<p>ANTLR的核心语法标记</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>匹配词法符号、规则引用或者子规则<code>x</code></td>
</tr>
<tr>
<td><code>x</code> <code>y</code> … <code>z</code></td>
<td>匹配一列规则元素</td>
</tr>
<tr>
<td>`(…</td>
<td>…</td>
</tr>
<tr>
<td><code>x?</code></td>
<td>匹配<code>x</code>或者忽略它</td>
</tr>
<tr>
<td><code>x*</code></td>
<td>匹配<code>x</code>零次或多次</td>
</tr>
<tr>
<td><code>x+</code></td>
<td>匹配<code>x</code>一次或多次</td>
</tr>
<tr>
<td><code>r:...;</code></td>
<td>定义规则<code>r</code></td>
</tr>
<tr>
<td>`r:…</td>
<td>…</td>
</tr>
</tbody></table>
<p>几种常见的计算机语言模式：</p>
<ul>
<li><strong>序列模式</strong>-它是一个有限长度或者任意长度的序列，序列中的元素可以是词法符号或者子规则。序列模式的用例包括了变量声明（类型后面紧跟着标识符）和整数序列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x y ... z</span><br><span class="line">&#x27;[&#x27; INT+ &#x27;]&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带终止符的序列模式</strong>-它是一个任意场的、可能为空的序列，该序列由一个词法符号分隔开，通常是分号或者换行符，其中的元素可以是词法符号或者子规则。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(statement &#x27;;&#x27;)*</span><br><span class="line">(row &#x27;\n&#x27;)*  // 多行数据</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带分隔符的序列模式</strong>-它是一个任意长的，可能为空的序列，该序列由一个词法符号分隔开，通常是逗号，分号或者句号，其中的元素可以是词法符号或者子规则。这样的例子包括函数定义中的参数表、函数调用时传递的参数表、某些词句之间有分隔符却无终止符的编程语言。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr (&#x27;,&#x27; expr)*   // 函数调用时传递的参数</span><br><span class="line">(expr (&#x27;,&#x27; expr)* )? // 函数调用时传递的参数是可选的</span><br><span class="line">&#x27;/&#x27; ? name (&#x27;/&#x27; name)* // 简化的目录名</span><br><span class="line">stat (&#x27;.&#x27; stat)*  // 若干个SmallTalk语句</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>选择模式</strong>-它是一组备选分支的集合。这样的例子不包括种类的类型、语句、表达式或者XML标签。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type : &#x27;int&#x27; | &#x27;float&#x27;;</span><br><span class="line">stat : ifstat | whilestat | &#x27;return&#x27; expr &#x27;;&#x27;;</span><br><span class="line">expr : &#x27;(&#x27; expr &#x27;)&#x27; | INT | ID;</span><br><span class="line">tag : &#x27;&lt;&#x27; Name attribute* &#x27;&gt;&#x27; | &#x27;&lt;&#x27; &#x27;/&#x27; Name &#x27;&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>词法符号依赖</strong>-一个词法符号需要和一个或者多个后续词法符号匹配。这样的例子包括配对的圆括号、花括号、方括号和尖括号。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;(&#x27; expr &#x27;)&#x27;   // 嵌套表达式</span><br><span class="line">ID &#x27;[&#x27; expr &#x27;]&#x27; // 数组索引表达式</span><br><span class="line">&#x27;&#123;&#x27; stat* &#x27;&#125;&#x27;   // 花括号包裹的若干个语句</span><br><span class="line">&#x27;&lt;&#x27; ID (&#x27;,&#x27; ID)* &#x27;&gt;&#x27; //范型声明</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>嵌套模式</strong>-它是一种自相似的语言结构。这样的例子包括表达式、Java内部类，嵌套的代码块以及嵌套的Python函数定义。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr : &#x27;(&#x27; expr &#x27;)&#x27; | ID;</span><br><span class="line">classDef : &#x27;class&#x27; ID &#x27;&#123;&#x27; (classDef | method | field) &#x27;&#125;&#x27;; </span><br></pre></td></tr></table></figure>

<h3 id="处理优先级、左递归和结合性"><a href="#处理优先级、左递归和结合性" class="headerlink" title="处理优先级、左递归和结合性"></a>处理优先级、左递归和结合性</h3><p>在自顶向下的语法和手工编写的递归下降语法分析器中，处理表达式都是一件相当棘手的事情，这首先是因为大多数语法都存在歧义，其次是因为大多数语言的规范使用了一种特殊的递归方式，称为*<em>左递归(left recursion)**。</em>注意：自顶向下的语法和语法分析器的经典形式无法处理左递归*。假设有一种简单的算术表达式语言，它包含乘法和加法运算符，以及整数因子。表达式是自相似的，所以，很自然地，一个乘法表达式是由<code>*</code>连接的两个子表达式，一个加法表达式是由<code>+</code>连接的两个子表达式。另外单个整数也可以作为简单的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : expr &#x27;*&#x27; expr  </span><br><span class="line">     | expr &#x27;+&#x27; expr</span><br><span class="line">     | INT</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p>问题在于，对于某些输入文本而言，上面的规则存在歧义。换句话说，这条规则可以用不止一种方式匹配某种输入的字符流。这个语法在简单的整数表达式和单运算符表达式上工作的很好—-例如<code>1+2</code>和<code>1*2</code>—-是因为只存在一种方式去匹配它们。</p>
<p>但是对于<code>1+2*3</code>这样的输入而言，上述规则能够用两种方式解释它。这就是运算符优先级带来的问题，传统的语法无法指定优先级。大多数语法工具，使用额外的标记来指定运算符优先级</p>
<p>与之不同的是，ANTLR通过优先选择位置靠前的备选分支来解决歧义问题，这隐式地允许指定运算符优先级。默认情况下，ANTLR按照通常对<code>*</code>和<code>+</code>理解，将运算符从左向右地进行结合。尽管如此，一些运算符—-例如指数运算符—-是从右向左结合的，所以需要在这样的运算符上使用assoc选项手工指定结合性。这样输入的<code>2^3^4</code>就能够被正确解释为<code>2^(3^4)</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr : expr &#x27;^&#x27; &lt;assoc=right&gt; expr  // ^ 运算符是右结合的</span><br><span class="line">     ｜ INT</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p><em>注意：在ANTLR4.2之后，<code>&lt;assoc=right&gt;</code>需要被放到备选分支的最左侧，否则会收到警告。正确地写法为:</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr : &lt;assoc=right&gt; expr &#x27;^&#x27; expr</span><br><span class="line">     | expr &#x27;*&#x27; expr</span><br><span class="line">     | expr &#x27;+&#x27; expr</span><br><span class="line">     | INT</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p>ANTLR4相比于ANTLR3的一项重大改进就是它可以处理左递归了。左递归规则是这样的一种规则：在某个备选分支的最左侧以直接或者间接方式调用了自身。</p>
<h5 id="使用优先级上升-Precedence-Climbing-算法解析表达式"><a href="#使用优先级上升-Precedence-Climbing-算法解析表达式" class="headerlink" title="使用优先级上升(Precedence Climbing)算法解析表达式"></a>使用优先级上升(Precedence Climbing)算法解析表达式</h5><p>ANTLR将直接左递归替换为一个判定循环(predicated loop)，该循环会比较前一个和下一个运算符的优先级。在ANTLR4之前，必须使用多个规则来表达优先级，类似下面的这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : addExpr;</span><br><span class="line">addExpr : multExpr (&#x27;+&#x27; multiExpr)*;</span><br><span class="line">multExpr : atom (&#x27;*&#x27; atom)*;</span><br><span class="line">atom     : INT;</span><br></pre></td></tr></table></figure>

<p>ANTLR4简化了处理直接左递归表达式规则的相关工作。新的机制不仅更有效率，而且使表达式规则更简洁、更易理解。在实践中，可以用直接左递归来处理所有关注的语言结构。例如，下面的规则匹配C语言中的声明语句，如<code>*(*a)[][]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decl : decl &#x27;[&#x27; &#x27;]&#x27;</span><br><span class="line">     | &#x27;*&#x27; decl</span><br><span class="line">     | &#x27;(&#x27; decl &#x27;)&#x27;</span><br><span class="line">     | ID</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<h3 id="识别常见的词法结构"><a href="#识别常见的词法结构" class="headerlink" title="识别常见的词法结构"></a>识别常见的词法结构</h3><p>在词法角度上，不同的计算语言的外观都十分相似。在词法角度，不论是函数式、过程式、声明式，还是面向对象的编程语言，基本大同小异。</p>
<p>和语法分析器一样，词法分析器也使用规则来描述种类繁多的语言结构。在ANTLR中，使用的是几乎完全相同的标记。唯一的差别在于，语法分析器通过输入的词法符号流来识别特定的语言结构，而词法分析器通过输入的字符流来识别特定的语言结构。</p>
<p>由于词法规则和文法规则的结构相似，ANTLR允许二者在同一个语法文件中同时存在。不过，由于词法分析和语法分析是语言识别过程中的两个不同阶段，必须告诉ANTLR每条规则对应的阶段。它是通过这种方式完成的：词法规则以大写字母开头，而文法规则以小写字母开头。例如，<code>ID</code>是一个词法规则名，而<code>expr</code>是一个文法规则名。</p>
<p>对于关键字、运算符和标点符号，无须声明词法规则，只需要在文法规则中直接使用单引号将它们括起来即可，例如<code>&#39;while&#39;</code>,<code>&#39;*&#39;</code>，以及<code>&#39;++&#39;</code>。有些开发者更愿意使用类似的词法规则来引用<code>&#39;*&#39;</code>，以避免对其的直接使用。</p>
<h4 id="匹配标识符"><a href="#匹配标识符" class="headerlink" title="匹配标识符"></a>匹配标识符</h4><p>在语法的伪代码中，一个基本的标识符就是一个由大小写字母组成的字符序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID : (&#x27;a&#x27; .. &#x27;z&#x27; | &#x27;A&#x27; .. &#x27;Z&#x27;)+;</span><br></pre></td></tr></table></figure>

<p><em>注意：<code>&#39;a&#39; .. &#39;z&#39;</code>是范围运算符，意思是从a到z的所有字符，这实际上是从97到122的ASCII码。如果使用Unicode字符(Unicode code point)，就必须写作<code>\uXXXX</code>,其中<code>XXXX</code>是相应的Unicode字符以十六进制表示的码点值</em>。此外，ANTLR还支持正则表达式中用于表示字符集的缩写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID : [a-zA-Z]+;</span><br></pre></td></tr></table></figure>

<p>类似ID的规则有时候会和其他词法规则或者字符串常量值产生冲突，例如<code>enum</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar KeywordTest;</span><br><span class="line">enumDef : &#x27;enum&#x27; &#x27;&#123;&#x27; ... &#x27;&#125;&#x27;;</span><br><span class="line">FOR : &#x27;for&#x27;;</span><br><span class="line">ID : [a-zA-Z]+ // 不会匹配enum和for</span><br></pre></td></tr></table></figure>

<p>ANTLR首先从文法规则中筛选出所有的字符串常量，并将它们和词法规则放在一起，<code>enum</code>这样的字符串常量被隐式定义为词法规则，然后放置文法规则之后、显式定义的词法规则之前。</p>
<h4 id="匹配数字"><a href="#匹配数字" class="headerlink" title="匹配数字"></a>匹配数字</h4><p>浮点数比较复杂，以下是简单版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INT : [0-9]+;</span><br><span class="line">FLOAT : DIGIT+ &#x27;.&#x27; DIGIT*</span><br><span class="line">    | &#x27;.&#x27; DIGIT+</span><br><span class="line">    ;</span><br><span class="line">fragment</span><br><span class="line">DIGIT : [0-9];</span><br></pre></td></tr></table></figure>

<h4 id="匹配字符串常量"><a href="#匹配字符串常量" class="headerlink" title="匹配字符串常量"></a>匹配字符串常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRING : &#x27;&quot;&#x27; .*? &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>点号通配符匹配任意的单个字符，<code>.*?</code>: 非贪婪匹配，获取一些字符，直到发现匹配后续子规则的字符为止。比如<code>.*</code>会匹配任意字符，不会停下来，因此加<code>?</code>表示遇到引号<code>&quot;</code>就停止匹配。</p>
<p>但是这个字符串不能匹配转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STRING : &#x27;&quot;&#x27; (ESC|.)*? &#x27;&quot;&#x27;;</span><br><span class="line">fragment</span><br><span class="line">ESC : &#x27;\\&quot;&#x27; | &#x27;\\\\&#x27;;</span><br></pre></td></tr></table></figure>

<p>其中，ANTLR语法本身需要对转义字符\进行转义，因此需要用<code>\\</code>来表示单个反斜杠字符。</p>
<p><code>fragment</code>表示片段规则。</p>
<h4 id="匹配注释和空白字符"><a href="#匹配注释和空白字符" class="headerlink" title="匹配注释和空白字符"></a>匹配注释和空白字符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINE_COMMENT : &#x27;//&#x27; .*? &#x27;\r&#x27;? &#x27;\n&#x27; -&gt; skip;</span><br><span class="line">COMMENT      : &#x27;/*&#x27; .*? &#x27;*/&#x27;       -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>在某种语法上下文中，应该丢弃换行符，在另外一些上下文中，需要将它输送给语法分析器，从而让语法分析器得知命令被终止了，比如Python等。既可以忽略，又可以不忽略。</p>
<h4 id="划定词法分析器和语法分析器的界线"><a href="#划定词法分析器和语法分析器的界线" class="headerlink" title="划定词法分析器和语法分析器的界线"></a>划定词法分析器和语法分析器的界线</h4><p>由于ANTLR的词法规则可以包含递归，从技术角度上看，词法分析器变得和语法分析器一样强大。这意味着可以甚至可以在词法分析器中匹配语法结构。另外一种极端是，可以把字符看作词法符号，然后用语法分析器来分析字符流的语法结构，这种情况称为无扫描器的语法分析器。划定词法分析器和语法分析器的界线位置不仅是语言的指责，更是语言编写的应用程序的职责。</p>
<ul>
<li>在词法分析器中匹配并丢弃任何语法分析器无须知晓的东西。对于编程语言来说，要识别并丢弃的就是类似注释和空白字符的东西。否则，语法分析器就需要频繁检查它们是否存在于词法符号之间。</li>
<li>由词法分析器来匹配类似标识符、关键字、字符串和数字的常见词法符号。语法分析器的层次更高，所以不应当让它处理将数字组合成整数这样的事情，这会加重它的负担。</li>
<li>将语法分析器无须区分的词法结构归为同一个词法符号类型。如果对待整数和浮点数的方式是一致的，那就把它们都归为NUMBER类型的词法符号。没必要传给语法分析器不同的类型。</li>
<li>将任何语法分析器可以以相同方式处理的实体归为一类。</li>
<li>如果语法分析器需要把一种类型的文本拆开处理，那么词法分析器就应该将它的各组成部分作为独立的词法符号输送给语法分析器。</li>
</ul>
<p>例如，Java编译器需要在忽略Javadoc注释的同时处理它；在XML文件中，标签内外的词法结构不一致。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>学习了如何根据一份语言的样例代码或者文档，来构造语法的伪代码，然后使用ANTLR标记构造出一个正式的语法。通用的语言模式：序列、选择、词法符号依赖和嵌套结构。在词法分析领域，了解最常见的词法符号的实现方法：标识符、数字、字符串、注释，以及空白字符。</p>
<h2 id="ANTLR语法实践"><a href="#ANTLR语法实践" class="headerlink" title="ANTLR语法实践"></a>ANTLR语法实践</h2><h3 id="解析CSV文件"><a href="#解析CSV文件" class="headerlink" title="解析CSV文件"></a>解析CSV文件</h3><p>能够识别标题行，允许空列存在，下面是以恶搞典型的csv文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Details,Month,Amount</span><br><span class="line">Mid Bonus,June,&quot;$2,000&quot;</span><br><span class="line">,January,&quot;&quot;&quot;zippo&quot;&quot;&quot;</span><br><span class="line">Total Bonuses,&quot;&quot;,&quot;%5,000&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grammar CSV;</span><br><span class="line"></span><br><span class="line">file : hdr row+;</span><br><span class="line">hdr : row;</span><br><span class="line">row : field (&#x27;,&#x27; field)* &#x27;\r&#x27;? &#x27;\n&#x27;;</span><br><span class="line">field : TEXT </span><br><span class="line">      | STRING</span><br><span class="line">      |</span><br><span class="line">      ;</span><br><span class="line">TEXT : ~[,\n\r&quot;]+;</span><br><span class="line">STRING &#x27;&quot;&#x27;  (&#x27;&quot;&quot;&#x27;|~&#x27;&quot;&#x27;)* &#x27;&quot;&#x27;; // 两个双信号是对双引号的转义</span><br></pre></td></tr></table></figure>

<p>为了允许被双引号包围的字符串中出现双引号，CSV格式通常使用两个双引号转义一个双引号。CSV是一种很好的数据存储格式。不过，如果需要在一个字段中存储多个值，它就无能为力了。JSON数据格式就允许嵌套</p>
<h3 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h3><p>JSON是一种存储键值对的数据格式，由于值本身也可以作为键值对的容器，JSON中可以包含嵌套结构。设计一个用于JSON的语法分析器可以处理更加复杂的词法规则。下面是一个简答的JSON数据文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;antlr.org&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;owners&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;live&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;speed&quot;</span> <span class="punctuation">:</span> <span class="number">1e100</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;menus&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;files&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Help\nMenu&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON的语法规则"><a href="#JSON的语法规则" class="headerlink" title="JSON的语法规则"></a>JSON的语法规则</h4><p>JSON语法指明，一个JSON文件可以是一个对象，或者是一个由若干值组成的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grammar JSON;</span><br><span class="line"></span><br><span class="line">json : object</span><br><span class="line">     | array</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p>下一步是将json规则引用的各个子规则进行分解。对于对象，JSON语法是这样规定的：</p>
<p>一个对象是一组无序的键值对集合。一个对象以一个左花括号<code>&#123;</code>开始，且以一个右花括号<code>&#125;</code>结束。每个键后跟一个冒号<code>:</code>,键值对之间由逗号分隔<code>,</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object : &#x27;&#123;&#x27; STRING &#x27;:&#x27; value (&#x27;,&#x27; STRING &#x27;:&#x27; value )* &#x27;&#125;&#x27; </span><br><span class="line">       | &#x27;&#123;&#x27;  &#x27;&#125;&#x27;</span><br><span class="line">       ;</span><br></pre></td></tr></table></figure>

<p>还可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">    : &#x27;&#123;&#x27; pair (&#x27;,&#x27; pair)* &#x27;&#125;&#x27;</span><br><span class="line">    | &#x27;&#123;&#x27;  &#x27;&#125;&#x27;   // 空对象</span><br><span class="line">    ;</span><br><span class="line">pair: STRING &#x27;:&#x27;  value </span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>JSON的语法参考中是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    &#123; members &#125;</span><br><span class="line"></span><br><span class="line">members</span><br><span class="line">    pair</span><br><span class="line">    pair, members</span><br><span class="line"></span><br><span class="line">pair</span><br><span class="line">    string : value</span><br></pre></td></tr></table></figure>

<p>其中<code>members</code>规则使用了<strong>尾递归</strong>的方式，而不使用<code>(...)*</code>循环。原因在于ANTLR支持EBNF，而JSON参考手册中直接使用了BNF。BNF不支持类似<code>(...)*</code>的循环，因此，它们使用了尾递归（某个规则在最后一个备选分支的最后一个元素调用了自身）来对循环进行模拟。</p>
<p>对于JSON中的数组，数组是一组值的有序集合。一个数组由一个左方括号开始<code>[</code>,由一个右方括号<code>]</code>结束。其中的值由逗号<code>,</code>分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array</span><br><span class="line">    : &#x27;[&#x27; value (&#x27;,&#x27; value)* &#x27;]&#x27;</span><br><span class="line">    | &#x27;[&#x27;  &#x27;]&#x27;   // 空数组</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>在上述规则的基础上进一步细化，需要编写规则<code>value</code>,它是一个选择模式。</p>
<p>一个值可以是一个双引号包围的字符串、一个数字、true/false、null、一个对象，或者一个数组。这些结构中可能发生嵌套。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value</span><br><span class="line">    : STRING</span><br><span class="line">    | NUMBER</span><br><span class="line">    | object  // 递归调用</span><br><span class="line">    | array   // 递归调用</span><br><span class="line">    | &#x27;true&#x27;  // 关键字</span><br><span class="line">    | &#x27;false&#x27; // 关键字</span><br><span class="line">    | &#x27;null&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h4 id="JSON-词法规则"><a href="#JSON-词法规则" class="headerlink" title="JSON 词法规则"></a>JSON 词法规则</h4><p>JSON中的字符串是一个由零个或者多个Unicode字符组成的序列，它由双引号包围，其中的字符使用反斜杠转义。单个字符由长度为1的字符串来表示，与C/Java中的字符串非常相似。JSON语法规范中的转义字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char</span><br><span class="line">    任意除&quot;字符、\字符以及控制字符之外的Unicode字符</span><br><span class="line">    \&quot;</span><br><span class="line">    \\</span><br><span class="line">    \/</span><br><span class="line">    \b</span><br><span class="line">    \f</span><br><span class="line">    \n</span><br><span class="line">    \r</span><br><span class="line">    \t</span><br><span class="line">    \u 由4位十六进制表示的数字</span><br></pre></td></tr></table></figure>

<p>其中指明了需要被转义的字符，并且指明了应当匹配任意除双引号和反斜杠之外的字符。可以通过反向选择序列<code>~[&quot;\\]</code>来满足这个要求，<code>~</code>操作符的意思是“非”。STRING定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">STRING &#x27;&quot;&#x27; ( ESC | ~[&quot;\\] )*  &#x27;&quot;&#x27;</span><br><span class="line">    ;</span><br><span class="line">fragment ESC : &#x27;\\&#x27; ( [&quot;\\/bfnrt] |UNICODE ) </span><br><span class="line">    ;</span><br><span class="line">fragment UNICODE : &#x27;u&#x27; HEX HEX HEX HEX</span><br><span class="line">    ;</span><br><span class="line">fragment HEX : [0-9a-fA-F];</span><br></pre></td></tr></table></figure>

<p><em>注意：以fragment开头的规则只能被其他的词法分析器规则使用，它们并不是词法符号</em></p>
<p>在JSON语法参考中，词法符号<code>NUMBER</code>的定义为:与C/Java中的数字非常相似，除了一点之外：<em>不允许使用八进制和十六进制格式</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NUMBER</span><br><span class="line">    : &#x27;-&#x27; ? INT &#x27;.&#x27; INT EXP?    // 1.35, 1.35e-9, 0.3, -4.5</span><br><span class="line">    | &#x27;-&#x27; ? INT EXP             // 1e10 -3e4</span><br><span class="line">    | &#x27;-&#x27; ? INT                 // -3 45</span><br><span class="line">    ;</span><br><span class="line">fragment INT :  &#x27;0&#x27; | [1-9] [0-9]*; // 除0外的数字不允许以0开始</span><br><span class="line">fragment EXP :  [Ee] [+\-]? INT;    // \-是对-的转义，因为[...]中的-用于表达“范围”语义</span><br></pre></td></tr></table></figure>

<p>同样，片段规则INT和EXP减少了重复代码，使语法可读性更强。根据JSON语法参考：INT不应当匹配除0之外的以0开头的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int </span><br><span class="line">    digit</span><br><span class="line">    digit1-9 digits</span><br><span class="line">    - digit</span><br><span class="line">    - digit1-9 digits</span><br></pre></td></tr></table></figure>

<p>在NUMBER规则中处理负号，这样，就能将精力集中于前两个备选分支：digit和digit1-9 digits。前者匹配任意的单个数字，所以0是可行的。后者匹配1到9，即除0之外开头的数字。</p>
<p>与CSV语法不同的是，JSON语法需要额外处理空白字符。在任意两个词法负号之间，可以存在任意多的空白字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WS : [ \t\n\r]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<h3 id="解析DOT语言"><a href="#解析DOT语言" class="headerlink" title="解析DOT语言"></a>解析DOT语言</h3><p>DOT是一门声明式编程语言，主要用于描述网络图、树或者状态机之类的图形。它是一种应用广泛的图形工具，例如，ANTLR的-atn选项就用DOT来产生可视化的状态机。</p>
<p>一个dot的源代码：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    main [shape=box];</span><br><span class="line">    main -&gt; f -&gt; g;         // main 调用f，f调用g</span><br><span class="line">    f -&gt; f [style=dotted];  // f是递归的</span><br><span class="line">    f -&gt; h;                 // f调用了h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    main [shape=box];</span><br><span class="line">    main -&gt; f -&gt; g;         // main 调用f，f调用g</span><br><span class="line">    f -&gt; f [style=dotted];  // f是递归的</span><br><span class="line">    f -&gt; h;                 // f调用了h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123; n -&gt; sw; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123; n -&gt; sw; &#125;</span><br></pre></td></tr></table></figure>

<p>DOT语法指南中包含了几乎可以直接使用的句法规则。</p>
<h4 id="DOT语言的语法规则"><a href="#DOT语言的语法规则" class="headerlink" title="DOT语言的语法规则"></a>DOT语言的语法规则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">grammar DOT:</span><br><span class="line">graph : STRICT (GRAPH | DIGRAPH) id? &#x27;&#123;&#x27; stmt list &#x27;&#125;&#x27; ;</span><br><span class="line">stmt_list : (stmt &#x27;;&#x27;? )*;</span><br><span class="line">stmt : node_stmt </span><br><span class="line">     | edge_stmt</span><br><span class="line">     | attr stmt</span><br><span class="line">     | id &#x27;=&#x27; id</span><br><span class="line">     | subgraph</span><br><span class="line">     ;</span><br><span class="line">attr_stmt : (GRAPH | NODE | EDGE) attr list;</span><br><span class="line">attr_list : (&#x27;[&#x27; a_list &#x27;]&#x27;)+;</span><br><span class="line">a_list    : (id (&#x27;=&#x27; id)? &#x27;,&#x27;?)+ ;</span><br><span class="line">edge_stmt : (node_id | subgraph) edgeRHS attr_list?;</span><br><span class="line">edgeRHS   : (edgeop (node_id | subgraph))+ ;</span><br><span class="line">edgeop    : &#x27;-&gt;&#x27; | &#x27;--&#x27;;</span><br><span class="line">node_stmt : node_id attr_list? ;</span><br><span class="line">node_id   : id port?</span><br><span class="line">port      : &#x27;;&#x27; id (&#x27;:&#x27; id)? ;</span><br><span class="line"></span><br><span class="line">subgraph : (SUBGRAPH id?)? &#x27;&#123;&#x27; stmt_list &#x27;&#125;&#x27; ;</span><br><span class="line">id       : ID</span><br><span class="line">         | STRING</span><br><span class="line">         | HTML_STRING</span><br><span class="line">         | NUMBER</span><br><span class="line">         ;</span><br></pre></td></tr></table></figure>

<h4 id="DOT语言的词法规则"><a href="#DOT语言的词法规则" class="headerlink" title="DOT语言的词法规则"></a>DOT语言的词法规则</h4><p>由于DOT语言参考指南没有给出正式的词法规则，就需要根据其中的描述来生成它们。参考文档指出：关键字<code>node</code>,<code>edge</code>,<code>graph</code>,<code>digraph</code>,<code>subgraph</code>,<code>strict</code>是不区分大小写的。如果它们区分大小写，就可以在语法中简单地使用类似<code>node</code>的字符串常量。为了能够识别<code>nOdE</code>这样的变体，需要在关键字的词法规则中为每个字符分别指定大小写的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STRICT   : [Ss][Tt][Rr][Ii][Cc][Tt];</span><br><span class="line">GRAPH    : [Gg][Rr][Aa][Pp][Hh];</span><br><span class="line">DIGRAPH  : [Dd][Ii][Gg][Rr][Aa][Pp][Hh];</span><br><span class="line">NODE     : [Nn][Oo][Dd][Ee];</span><br><span class="line">EDGE     : [Ee][Dd][Gg][Ee];</span><br><span class="line">SUBGRAPH : [Ss][Uu][Bb][Gg][Rr][Aa][Pp][Hh];</span><br></pre></td></tr></table></figure>

<p>DOT语言中的标识符和其他编程语言相似。</p>
<p>任意由字母标中字符(<code>[a-zA-Z\200-\377]</code>)、下划线(‘_’)或数字(<code>[0-9]</code>)组成的，不以数字开头的字符串。</p>
<p>八进制的数字范围<code>\200-377</code>用十六进制来表示是80懂到ff，因此ID规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID : LETTER | (LETTER|DIGIT)*;</span><br><span class="line">fragment</span><br><span class="line">LETTER   :  [a-zA-Z\u0080-u00FF_];</span><br></pre></td></tr></table></figure>

<p>定义一个辅助规则DIGIT来匹配数字。数字遵循下列正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUMBER : &#x27;-&#x27;? (&#x27;.&#x27; DIGIT+ | DIGIT+ (&#x27;.&#x27; DIGIT*)?);</span><br><span class="line">fragment</span><br><span class="line">DIGIT  : [0-9];</span><br></pre></td></tr></table></figure>

<p>DOT语言中的字符串定义较为基础。任意的由双引号包围的字符序列(“…”)，可能包括转义后的双引号<code>\&quot;</code>。</p>
<p>使用点通配符来匹配字符串中的任意字符，直到遇见最后的双引号为止。额外地，将转义后的双引号作为子规则循环中的一个备选分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRING : &#x27;&quot;&#x27; (&#x27;\\&quot;&#x27;|.)*? &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>DOT语言中还包含一种名为HTML字符串的元素，它和字符串非常相似，唯一的差别在于它使用尖括号而不是双引号。参考文档中使用<code>&lt;...&gt;</code>来表示这种元素，描述如下：</p>
<p>在HTML字符串中，尖括号必须成对出现，其中可以包含未转义的换行符。除此之外，HTML字符串的内容必须是合法的XML，这就要求某些特殊字符<code>(&quot;, &amp;, &lt;以及&gt;)</code>需要被转义，以便嵌入XML标签的属性或者文本中。</p>
<p>可以使用ANTLR结构<code>&#39;&lt;&#39; .*? &#39;&gt;&#39;</code>来匹配两个尖括号之间的任意文本。不过，这个规则不允许其中出现嵌套的尖括号，因为它会把第一个<code>&gt;</code>和第一个<code>&lt;</code>配对，而不是期望最近的<code>&lt;</code>。下列规则能够达到预期效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 在HTML字符串中，尖括号必须成对出现，其中可以包含未转义的换行符</span><br><span class="line"> */</span><br><span class="line">HTML_STRING : &#x27;&lt;&#x27; (TAG|~[&lt;&gt;])* &#x27;&gt;&#x27;;</span><br><span class="line">fragment</span><br><span class="line">TAG  :  &#x27;&lt;&#x27; .*? &#x27;&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>其中的HTML_STRING规则允许TAG元素出现在配对的尖括号之间，这样就实现了一层的嵌套。<code>~[&lt;&gt;]</code>负责匹配类似<code>&amp;lt</code>;的XML字符实体。它匹配除左右尖括号外的任何字符。在这里，不能使用通配符和非贪婪匹配循环。</p>
<p>DOT语言匹配并丢弃以<code>#</code>开头的行，它认为那是C语言的预处理器的输出。可以用与之前类似的单行注释的方法来处理它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PREPROC  :  &#x27;#&#x27; .*? &#x27;\n&#x27; -&gt; skip;</span><br></pre></td></tr></table></figure>

<h3 id="解析Cymbol语言"><a href="#解析Cymbol语言" class="headerlink" title="解析Cymbol语言"></a>解析Cymbol语言</h3><p>Cymbol是一门简单的、非面向对象的编程语言，外观类似于不带结构体的C语言。下面一段带有全局变量和递归函数声明的程序就是Cymbol代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int g = 9;   // 全局变量</span><br><span class="line">int fact(int x) &#123;  // 求阶乘的函数</span><br><span class="line">    if x == 0 then return 1;</span><br><span class="line">    return x * fact(x - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从最粗粒度观察Cymbol程序，可以发现它由一系列全局变量和函数声明组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file: (functionDecl | varDecl)+;</span><br></pre></td></tr></table></figure>

<p>同所有的类C语言一样，变量声明由一个类型开始，随后是一个标识符，最后是一个可选的初始化语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">varDecl</span><br><span class="line">    : type ID (&#x27;=&#x27; expr)?</span><br><span class="line">    ;</span><br><span class="line">type: &#x27;float&#x27; | &#x27;int&#x27; | &#x27;void&#x27;;  // 用户定义的类型</span><br></pre></td></tr></table></figure>

<p>函数声明也基本上相同：类型后面跟着函数名，随后是被括号包围的参数列表，最后是函数体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functionDecl</span><br><span class="line">    : type ID &#x27;(&#x27; formalParameters? &#x27;)&#x27; block // &quot;void f(int x) &#123;...&#125;&quot;</span><br><span class="line">    ;</span><br><span class="line">formalParameters</span><br><span class="line">    : formalParameter (&#x27;,&#x27; formalParameter)*</span><br><span class="line">    ;</span><br><span class="line">formalParameter</span><br><span class="line">    : type ID</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>一个函数体是由花括号包围的一组语句。先构造出六种语句：嵌套的代码块、变量声明、if语句、return语句、赋值语句，以及函数调用。可以用下面的ANTLR语法来表达它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">block: &#x27;&#123;&#x27; stat* &#x27;&#125;&#x27;;  // 语句组成的代码块，可以为空</span><br><span class="line">stat: block</span><br><span class="line">    | varDecl</span><br><span class="line">    | &#x27;if&#x27; expr &#x27;then&#x27; stat (&#x27;else&#x27; stat)?</span><br><span class="line">    | &#x27;return&#x27; expr? &#x27;;&#x27;</span><br><span class="line">    | expr &#x27;=&#x27; expr &#x27;;&#x27;  // 赋值</span><br><span class="line">    | expr &#x27;;&#x27;           // 函数调用</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>Cymbol语言的最后一个主要部分是表达式语法。因为Cymbol实际上仅仅是其他语言的原型或者基础，因此没有必要包含非常多的运算符。假设表达式包括一元取反、布尔非、乘法、加法、减法、函数调用、数组索引、等同性判断、变量、整数以及括号表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">expr: ID &#x27;(&#x27; exprList? &#x27;)&#x27;  // 类似f(),f(x),f(1,2)的函数调用表达式</span><br><span class="line">    | expr &#x27;[&#x27; expr &#x27;]&#x27;     // 类似a[i],a[i][j]的数组索引表达式</span><br><span class="line">    | &#x27;-&#x27; expr</span><br><span class="line">    | &#x27;!&#x27; expr</span><br><span class="line">    | expr &#x27;*&#x27; expr</span><br><span class="line">    | expr (&#x27;+&#x27;|&#x27;-&#x27;) expr</span><br><span class="line">    | expr &#x27;==&#x27; expr          // 等同性判断表达式(它是优先级最低的运算符)</span><br><span class="line">    | ID                      // 变量引用</span><br><span class="line">    | INT</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line">exprList: expr (&#x27;,&#x27; expr)*;   // 参数列表</span><br></pre></td></tr></table></figure>

<p>其中的重点是通常将备选分支按照从高到低的优先级进行排序。一元取反运算符比加法的优先级更高，这是由于取反表达式的备选分支在加法表达式之前。另一方面，由于取反表达式的备选分支在数组索引表达式之后，取反运算符的优先级比数组索引运算符低。</p>
<h3 id="解析R语言"><a href="#解析R语言" class="headerlink" title="解析R语言"></a>解析R语言</h3><p>R是一门极富表现力的领域特定(domain-specific)编程语言，专门用于描述和解决统计学问题。在R语言中，新建向量、对向量调用函数、筛选向量都十分容易。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="number">.5</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">5</span></span><br><span class="line">z <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">9</span><span class="punctuation">,</span><span class="number">6</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">4</span><span class="punctuation">)</span></span><br><span class="line">y <span class="operator">+</span> z</span><br><span class="line">z<span class="punctuation">[</span>z <span class="operator">&lt;</span> <span class="number">5</span><span class="punctuation">]</span> <span class="comment"># 所有满足z &lt; 5的元素</span></span><br><span class="line">mean<span class="punctuation">(</span>z<span class="punctuation">)</span>  <span class="comment"># 计算z的均值</span></span><br><span class="line">zero <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span><span class="built_in">return</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br><span class="line">zero<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>R语言是一门中等大小却十分复杂的语言，R语言的程序由一系列表达式或者赋值语句构成。每个函数定义都是赋值语句，它等价于将一个函数赋值给一个变量。</p>
<p>R语言中存在三种赋值运算符：<code>&lt;-</code>,<code>=</code>,<code>&lt;&lt;-</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prog : ( expr_or_assign (&#x27;;&#x27;|NL)</span><br><span class="line">    | NL</span><br><span class="line">    )*</span><br><span class="line">    EOF</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr_or_assign</span><br><span class="line">    : expr (&#x27;&lt;-&#x27; | &#x27;=&#x27; | &#x27;&lt;&lt;-&#x27;) expr_or_assign</span><br><span class="line">    | expr</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">NL : &#x27;\r&#x27;? &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>

<p>使用词法符号NL而不是常量’\n’的原因是希望同时允许Windows风格的换行符<code>\r\n</code>和UNIX风格的换行符<code>\n</code>,而这很容易在词法规则中定义。</p>
<p>R语言语法中的大部分内容是和表达式相关的，因此在本节的剩余部分将集中精力处理它们，在R语言中，有三种主要的表达式：语句表达式(statement expression),运算符表达式(operator expression)和函数相关表达式(function-related expression)。由于R语言的语句和其他命令式编程语言的对应部分非常相似，首先完成这部分工作。下面是expr规则中包含的备选分支(它们位于运算符表达式的备选分支之后):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| &#x27;&#123;&#x27; exprlist &#x27;&#125;&#x27;  // 复合语句</span><br><span class="line">| &#x27;if&#x27; &#x27;(&#x27; expr &#x27;)&#x27; expr</span><br><span class="line">| &#x27;if&#x27; &#x27;(&#x27; expr &#x27;)&#x27; &#x27;else&#x27; expr</span><br><span class="line">| &#x27;for&#x27; &#x27;(&#x27; ID &#x27;in&#x27; expr &#x27;)&#x27; expr</span><br><span class="line">| &#x27;while&#x27; &#x27;(&#x27; expr &#x27;)&#x27; expr</span><br><span class="line">| &#x27;repeat&#x27; expr</span><br><span class="line">| &#x27;?&#x27; expr   // 获取expr的帮助信息，通常是字符串或者标识符</span><br><span class="line">| &#x27;next&#x27;</span><br><span class="line">| &#x27;break&#x27;</span><br></pre></td></tr></table></figure>

<p>其中，第一个备选分支匹配R-intro中提到的“表达式组”—-多条命令可以通过花括号<code>&#123;</code>和<code>&#125;</code>组成一个复合表达式。下面是<code>exprList</code>规则的定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exprList</span><br><span class="line">    : expr_or_assign ( (&#x27;;&#x27;|NL) expr_or_assign )*</span><br></pre></td></tr></table></figure>

<p>R语言中的大多数表达式包含丰富的运算符。为了得到这些表达式的正确形式，最好的方法是参照yacc的语法。可执行的代码通常是(但并非总是)表达语言作者意图的最好向导。为了获知各运算符的优先级，需要查看优先级表，它显式地指明了相关运算符的优先级。例如，下列yacc语言给出了算术运算符定义:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$left  &#x27;+&#x27; &#x27;-&#x27;</span><br><span class="line">%left  &#x27;*&#x27; &#x27;/&#x27; </span><br></pre></td></tr></table></figure>

<p>R语言二元、前缀和后缀运算符的表达式规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">expr: expr &#x27;[[&#x27; sublist &#x27;]&#x27; &#x27;]&#x27; // &#x27;[[&#x27; 源于R语言的yacc语法</span><br><span class="line">    | expr &#x27;[&#x27; sublist &#x27;]&#x27;</span><br><span class="line">    | expr (&#x27;::&#x27; | &#x27;:::&#x27;) expr</span><br><span class="line">    | expr (&#x27;$&#x27;|&#x27;@&#x27;) expr</span><br><span class="line">    | expr &#x27;^&#x27;&lt;assoc=right&gt; expr</span><br><span class="line">    | (&#x27;-&#x27;|&#x27;+&#x27;) expr</span><br><span class="line">    | expr &#x27;;&#x27; expr</span><br><span class="line">    | expr USER_OP expr   // 任意被%包围的文本：&#x27;%&#x27;,.*,&#x27;%&#x27;</span><br><span class="line">    | expr (&#x27;*&#x27;|&#x27;/&#x27;) expr</span><br><span class="line">    | expr (&#x27;+&#x27;|&#x27;-&#x27;) expr</span><br><span class="line">    | expr (&#x27;&gt;&#x27;|&#x27;&gt;=&#x27;|&#x27;&lt;&#x27;|&#x27;&lt;=&#x27;|&#x27;==&#x27;|&#x27;!=&#x27;) expr</span><br><span class="line">    | &#x27;!&#x27; expr</span><br><span class="line">    | expr (&#x27;&amp;&#x27; | &#x27;&amp;&amp;&#x27;) expr</span><br><span class="line">    | expr (&#x27;|&#x27; | &#x27;||&#x27;) expr</span><br><span class="line">    | &#x27;~&#x27; expr</span><br><span class="line">    | expr &#x27;~&#x27; expr</span><br><span class="line">    | expr (&#x27;-&gt;&#x27;|&#x27;-&gt;&gt;&#x27;|&#x27;:=&#x27;) expr</span><br></pre></td></tr></table></figure>

<p><code>[[...]]</code>得到是包含单一元素的列表，而<code>[...]</code>生成一个子列表。<code>^</code>运算符后面带有后缀<code>&lt;assoc=right&gt;</code>，指数运算符以及向左运算符是子右向左分组合的。即2^2^3的结果是2^8,而不是4^3.</p>
<p><code>expr</code>规则的最后一部分，定义和调用函数。可以写出如下所示的备选分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| &#x27;function&#x27; &#x27;(&#x27; formlist? &#x27;)&#x27; expr // 定义函数</span><br><span class="line">| expr &#x27;(&#x27; sublist &#x27;)&#x27;              // 调用函数</span><br></pre></td></tr></table></figure>

<p><code>formlist</code>和<code>sublist</code>规则分别定义了形式参数列表和实际参数列表。这两个规则的名字取自yacc语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">formlist : form (&#x27;,&#x27; form)+;</span><br><span class="line">form: ID</span><br><span class="line">    | ID &#x27;=&#x27; expr</span><br><span class="line">    | &#x27;...&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>每个参数都可以带上标记<code>tag=expr</code>,或者只是一个简单的表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sublist : sub (&#x27;,&#x27; sub)*;</span><br><span class="line">sub : expr</span><br><span class="line">    | ID &#x27;=&#x27;</span><br><span class="line">    | ID &#x27;=&#x27; expr</span><br><span class="line">    | STRING &#x27;=&#x27;</span><br><span class="line">    | STRING &#x27;=&#x27; expr</span><br><span class="line">    | &#x27;NULL&#x27; &#x27;=&#x27;</span><br><span class="line">    | &#x27;NULL&#x27; &#x27;=&#x27; expr</span><br><span class="line">    | &#x27;...&#x27;</span><br><span class="line">    |</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>标识符包含字母、数字、句点(‘.’)，以及下划线。合法的标识符不能数字、下划线和句点后的数字开头。<em>注意：以句点开头的标识符，例如<code>...</code>,<code>..1</code>等</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID : &#x27;.&#x27; (LETTER|&#x27;_&#x27;|&#x27;.&#x27;) (LETTER|DIGIT|&#x27;_&#x27;|&#x27;.&#x27;)*</span><br><span class="line">    | LETTER (LETTER|DIGIT|&#x27;_&#x27;|&#x27;.&#x27;)*</span><br><span class="line">    ;</span><br><span class="line">fragment LETTER : [a-zA-Z];</span><br></pre></td></tr></table></figure>

<h2 id="将语法和程序的逻辑代码解耦"><a href="#将语法和程序的逻辑代码解耦" class="headerlink" title="将语法和程序的逻辑代码解耦"></a>将语法和程序的逻辑代码解耦</h2><p>通常单独的语法并没有用处，而与其相关的语法分析器才能告诉输入语句是否遵循该语言规范。为了构建一个语言类应用程序，语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组-&gt;行为的集合构成了语言类应用程序，或者，至少担任了语法和外围程序间接口的角色。</p>
<p>可以使用语法分析树监听器和访问器来构建语言类应用程序。监听器能够对特定规则的进入和退出事件(即识别到某些词组的事件)作出响应，这些事件分别由语法分析树遍历器在开始和完成对节点的访问时触发。另外，ANTLR自动生成语法分析树也支持访问者模式，从而允许程序控制语法分析树的遍历过程。</p>
<p>监听器和访问器机制的最大区别在于，监听器方法不负责显式调用子节点的访问方法，而访问器必须显式触发对子节点的访问以便树的遍历过程能够正常惊醒。因为访问器机制需要显式调用方法来访问子节点，所以它能够控制遍历过程的访问顺序，以及节点被访问的次数。</p>
<h3 id="从内嵌动作到监听器"><a href="#从内嵌动作到监听器" class="headerlink" title="从内嵌动作到监听器"></a>从内嵌动作到监听器</h3><p>构建语言类应用程序时，可以不在语法中内嵌动作(代码)。监听器和访问器机制能够将语法和程序逻辑代码解耦。这样的解耦将程序封装起来，避免了杂乱无章地分散在语法中。如果语法中没有内嵌动作，就可以在多个程序中复用同一个语法，而无须为每个目标语法分析器重新编译一次。</p>
<p>受益于内嵌动作的机制，ANTLR能基于同一个语法文件，使用不同的编程语言生成语法分析器，由于无须担心合并后内嵌动作的冲突，对语法的更新和bug修复也十分容易。</p>
<p>本节主要研究从包含内嵌动作的语法到完全与动作解耦的语法的演进过程。下列语法用于读取属性文件，这些文件的每行都是一个赋值语句，其中<code>&lt;&lt;...&gt;&gt;</code>是内嵌动作的概要。类似<code>&lt;&lt;start file&gt;&gt;</code>的标记代表一段恰当饿的Java代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grammar PropertyFile;</span><br><span class="line">file : &#123;&lt;&lt;start file&gt;&gt;&#125; prop+ &#123;&lt;&lt;finish file&gt;&gt;&#125;;</span><br><span class="line">prop : ID &#x27;=&#x27; STRING &#x27;\n&#x27; &#123;&lt;&lt;process property&gt;&gt;&#125;;</span><br><span class="line">ID : [a-z]+;</span><br><span class="line">STRING : &#x27;&quot;&#x27; .*? &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>这样的紧耦合使得语法被绑定到了特定的程序上。更好的方案是，从ANTLR自动生成的语法分析器<code>PropertyFileParser</code>派生出一个子类，然后将内嵌动作转换为方法。这样的重构可以使得语法中仅仅包含方法调用，就可以通过语法分析器的子类实现任意数量的不同功能的程序，而无须修改原先的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar PropertyFile;</span><br><span class="line">@members &#123;</span><br><span class="line">    void startFile() &#123; &#125;</span><br><span class="line">    void finishFile() &#123; &#125;</span><br><span class="line">    void defineProperty(Token name, Token value) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">file : &#123;startFile();&#125; prop+ &#123;finishFile();&#125;;</span><br><span class="line">prop : ID &#x27;=&#x27; STRING &#x27;\n&#x27; &#123;defineProperty($ID, $STRING);&#125;;</span><br><span class="line">ID : [a-z]+;</span><br><span class="line">STRING : &#x27;&quot;&#x27; .*? &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>上述解耦方案允许该语法被不同程序复用，但是由于方法调用存在，它仍然和Java绑定在一起。</p>
<p>为了展示重构后的语法拥有良好的复用性，构建两个不同的“语言类应用程序”，先从其中一个开始：在遇到属性的时候将它们打印出来。编写这个程序的过程非常简单，只需继承ANTLR自动生成的语法分析器类，然后覆盖语法中触发的一个或多个方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyFilePrinter</span> <span class="keyword">extends</span> <span class="title class_">PropertyFileParser</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defineProperty</span><span class="params">(Token name, Token value)</span> &#123;</span><br><span class="line">        System.out.println(name.getText() + <span class="string">&quot;=&quot;</span> value.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：无须覆盖startFile()和endFile()方法，因为ANTLR自动生成的PropertyFileParser已经提供了它们的默认实现。</em></p>
<p>至于第二个程序，要完成的功能是将属性放入一个Map，而非打印出来.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PropertyFileLoader</span> <span class="keyword">extends</span> <span class="title class_">PropertyFileParser</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; props = <span class="keyword">new</span> <span class="title class_">OrderedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defineProperty</span><span class="params">(Token name, Token value)</span> &#123;</span><br><span class="line">        props.put(name.getText(), value.getText())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份语法仍然存在缺陷，受内嵌动作的限制，它只能生成Java编写的语法分析器，为了使语法可被重用并具有语言中立性，需要完全避免内嵌动作的存在。</p>
<h3 id="使用语法分析树监听器编写程序"><a href="#使用语法分析树监听器编写程序" class="headerlink" title="使用语法分析树监听器编写程序"></a>使用语法分析树监听器编写程序</h3><p>构建应用逻辑和语法松耦合的语言类应用程序的关键在于，令语法分析器建立一棵语法分析树，然后在遍历该树的过程中触发应用逻辑代码。可以使用自己熟悉的方式遍历这样的语法分析树，也可以利用ANTLR自动生成的树遍历器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file : prop+</span><br><span class="line">prop : ID &#x27;=&#x27; STRING &#x27;\n&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PropertyFileListener</span> <span class="keyword">extends</span> <span class="title class_">ParseTreeListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enterFile</span><span class="params">(PropertyFileParser.FileContext ctx)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exitFile</span><span class="params">(PropertyFileParser.FileContext ctx)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enterProp</span><span class="params">(PropertyFileParser.PropContext ctx)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exitProp</span><span class="params">(PropertyFileParser.PropContext ctx)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileContext</code>和<code>PropContext</code>类是每条语法规则对应的语法分析树节点的实现。它们包含一些很有用的方法。</p>
<p>为方便起见，ANTLR自动生成了一个名为<code>PropertyFileBaseListener</code>的默认实现，它包含了所有方法的空实现，即上一节涉及语法的<code>@member</code>区域中手工编写的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyFileBaseVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractParseTreeVisitor</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">PropertyFileVisitor</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitFile</span><span class="params">(PropertyFileParser.FileContext ctx)</span> &#123; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitProp</span><span class="params">(PropertyFileParser.PropContext ctx)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的默认实现允许只覆盖那些所关心的方法。例如，下面的属性的文件加载器和之前一样包含单个方法，但是使用了监听器机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PropertyFileLoader</span> <span class="keyword">extends</span> <span class="title class_">PropertyFileBaseListener</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; props = <span class="keyword">new</span> <span class="title class_">OrderedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitProp</span><span class="params">(PropertyFileParser.PropContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ctx.STRING().getText();</span><br><span class="line">        props.put(id, value);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该版本和之前版本的最大差别在于，它继承了监听器基类(base listener)而非继承语法分析器，另外，监听器方法是在语法分析器完成解析之后才被触发的。</p>
<p>遍历语法分析树，并在这个过程中使用新的PropertyFileLoader类监听响应的事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个标准的ANTLR语法分析树遍历器</span></span><br><span class="line"><span class="type">ParseTreeWalker</span> <span class="variable">walker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line"><span class="comment">// 新建一个监听器，将其传递给遍历器</span></span><br><span class="line"><span class="type">PropertyFileLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyFileLoader</span>();</span><br><span class="line">walker.walk(loader, tree);  <span class="comment">// 遍历语法分析树</span></span><br><span class="line">System.out.println(loader.props);   <span class="comment">// 打印结果</span></span><br></pre></td></tr></table></figure>

<p>这种基于监听器的方法之分巧妙，因为所有的遍历过程和方法触发的都是自动进行的。有些时候，自动进行的遍历反而成为一个缺陷，因为无法控制遍历的过程。例如，可能希望遍历一个C语言程序的语法分析树，跳过对代表函数体的子树的访问，从而达到忽略函数内容的目的。此外，监听器的事件方法也无法利用方法的返回值来传递数据。当需要控制遍历过程，或者希望事件方法返回值时，可以使用访问者模式。接下来，作为对比，将会构建一个基于访问器机制的属性文件加载器。</p>
<h3 id="使用访问器编写程序"><a href="#使用访问器编写程序" class="headerlink" title="使用访问器编写程序"></a>使用访问器编写程序</h3><p>使用访问器机制代替监听器机制的详细步骤是：令ANTLR生成一个访问器接口，实现该接口，然后编写一个测试程序对语法分析树调用visit()方法。因此，完全不需要跟语法交互。</p>
<p>在命令行使用<code>-visitor</code>选项时，ANTLR自动生成了接口PropertyFileVisitor和以下默认实现类PropertyFileBaseVisitor:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertyFileBaseVisitor</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractParseTreeVisitor</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">PropertyFileVisitor</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitFile</span><span class="params">(PropertyFileParser.FileContext ctx)</span> &#123; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> T <span class="title function_">visitProp</span><span class="params">(PropertyFileParser.PropContext ctx)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以从上一节的监听器中拷贝<code>exitProp()</code>中的代码，将它们粘贴到prop规则对应的访问器方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PropertyFileVisitor</span> <span class="keyword">extends</span> <span class="title class_">PropertyFileBaseVisitor</span>&lt;Void&gt; &#123;</span><br><span class="line">    Map&lt;String, String&gt; props = <span class="keyword">new</span> <span class="title class_">OrderedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">public</span> Void <span class="title function_">visitProp</span><span class="params">(PropertyFileParser.PropContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ctx.ID().getText(); <span class="comment">// prop : ID &#x27;=&#x27; STRING &#x27;\n&#x27;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> ctx.STRING().getText();</span><br><span class="line">        props.put(id, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问器通过显式调用ParseTreeVisitor接口的visit()方法来遍历语法分析树。该方法的实现在AbstractParseTreeVisitor中。在本例中，prop调用生成饿节点没有子节点，因此visitProp()无需再调用其他的visit().</p>
<p>访问器机制和监听器机制下的测试程序之间的最大区别在于，访问器机制里的测试程序不需要ParseTreeWalker。它通过访问器来访问语法分析器生成的树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PropertyFileVisitor</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyFileVisitor</span>();</span><br><span class="line">loader.visit(tree);</span><br><span class="line">System.out.println(loader.props); <span class="comment">// 打印结果</span></span><br></pre></td></tr></table></figure>

<p>使用访问器和监听器机制，可以完成一切与语法相关的事情。语法及其对应的语法分析树，以及访问器或者监听器事件方法之间的关系。除此之外，剩下的仅仅是普通的代码。在对输入文本进行识别时，可以产生输出、收集信息、用某种方式验证输入文本，或者执行计算。</p>
<p>默认情况下，ANTLR为每条规则生成单一类型的事件，无论语法分析器匹配到的是其中的哪一个备选分支，该事件都会被触发。这是一件非常不便的事情，因为监听器和访问器方法必须搞清楚语法分析器匹配到是哪一个备选分支。在下一节中，将会看到如何在更合适的粒度上处理事件。</p>
<h3 id="标记备选分支以获取精确的事件方法"><a href="#标记备选分支以获取精确的事件方法" class="headerlink" title="标记备选分支以获取精确的事件方法"></a>标记备选分支以获取精确的事件方法</h3><p>使用<code>#</code>来标记ANTLR语法文件，为获取更加精确的监听器事件，ANTLR允许用<code>#</code>运算符为任意规则的最外层备选分支提供标签。利用这种方法，在Expr语法的基础上，增加标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e : e MULT e # Mult</span><br><span class="line">  | e ADD e  # Add</span><br><span class="line">  | INT      # Int</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>ANTLR为e的每个备选分支都生成了一个单独的监听器方法。</p>
<h3 id="在事件方法中共享信息"><a href="#在事件方法中共享信息" class="headerlink" title="在事件方法中共享信息"></a>在事件方法中共享信息</h3><p>不论是出于收集信息还是计算的目的，良好的编程实践应该使用传参和返回值，而非类成员或者其他的“全局变量”。但是，ANTLR自动生成的监听器方法是不带自定义返回值和参数的。同样，ANTLR生成的访问器方法也不带自定义参数。</p>
<ul>
<li>使用访问器方法来返回值</li>
<li>使用类成员在事件方法之间共享数据</li>
<li>通过对语法分析树的节点进行标注来存储相关数据</li>
</ul>
<h4 id="使用访问器方法来返回值"><a href="#使用访问器方法来返回值" class="headerlink" title="使用访问器方法来返回值"></a>使用访问器方法来返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EvalVisitor</span> <span class="keyword">extends</span> <span class="title class_">LExprBaseVisitor</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitMult</span><span class="params">(LExprParser.MultContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.e(<span class="number">0</span>)) * visit(ctx.e(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitAdd</span><span class="params">(LExprParser.AddContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.e(<span class="number">0</span>)) + visit(ctx.e(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">visitInt</span><span class="params">(LExprParser.IntContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要让自定义的程序返回值，访问器是个不错的选择，因为它使用的是Java原生的返回值机制。如果不希望每次都显式调用访问器方法来访问子节点，可以换成监听器机制。但是这意味着放弃了使用Java方法返回值带来的整洁。</p>
<h4 id="使用栈来模拟返回值"><a href="#使用栈来模拟返回值" class="headerlink" title="使用栈来模拟返回值"></a>使用栈来模拟返回值</h4><p>ANTLR生成的监听器方法是没有返回值的（void类型）。在语法分析树中，为了向监听器方法的更高层的调用者返回值，可以将监听器的局部结果保存在一个成员变量中。比如使用栈结构，就像Java虚拟机使用栈来临时存储返回值那样。即每个表达式的计算结果堆入一个栈中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Evaluator</span> <span class="keyword">extends</span> <span class="title class_">LExprBaseListener</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitMult</span><span class="params">(LExprParser.MultContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        stack.push(left * right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitAdd</span><span class="params">(LExprParser.AddContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        stack.push(left + right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitInt</span><span class="params">(LExprParser.IntContext ctx)</span> &#123;</span><br><span class="line">        stack.push(Integer.valueOf(ctx.INT().getText()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用栈的方式不够优雅，但是非常有效。通过栈，可以保证事件方法在所有的监听器事件之间的执行顺序是正确的。带返回值的访问器足够优雅，但是需要手工触发对树节点的访问。</p>
<h4 id="标注语法分析树"><a href="#标注语法分析树" class="headerlink" title="标注语法分析树"></a>标注语法分析树</h4><p>可以讲数据直接存储在语法分析树里。监听器和访问器机制都支持树的标注，接下来会用监听器进行演示。其中，每个子表达式对应一个子树的根节点。可以通过规则参数和返回值为节点添加字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e returns [int value] </span><br><span class="line">    : e &#x27;*&#x27; e # Mult</span><br><span class="line">    : e &#x27;+&#x27; e # Add</span><br><span class="line">    | INT     # Int</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ANTLR会将所有的参数和返回值放入相关的上下文对象中，这样，value就成为EContext的一个字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EContext</span> <span class="keyword">extends</span> <span class="title class_">ParserRuleContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为相应备选分支中的上下文类都继承自EContext，所有的监听器方法都能访问这个值。例如，监听器方法可以直接只用<code>ctx.value = 0</code>.</p>
<p>这里展示的这种方法指定某条规则产生一个结果值，该值将被存储于此规则的上下文对象内。此过程使用了目标语言的片段，从而导致这个语法被绑定到了特定的目标语言上。不过，这种方法并不意味着这份语法被绑定到了特定的应用程序上，因为其他程序也可能需要此规则产生同样的结果值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">exitAdd</span><span class="params">(LExprParser.AddContext ctx)</span> &#123;</span><br><span class="line">    <span class="comment">// e(0).value是备选分支中的第一个e子表达式的值</span></span><br><span class="line">    ctx.value = ctx.e(<span class="number">0</span>).value + ctx.e(<span class="number">1</span>).value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，在Java中，无法为<code>ExprContext</code>类动态添加一个value字段(像Ruby和Python那样)。为了使语法分析树的标注生效，需要一种标注多个节点的方法，这种方法不能是手工修改ANTLR生成的相关节点类，因为ANTLR下次生成代码时会覆盖掉修改。</p>
<p>最简单的标注语法分析树节点的方法是使用Map来将任意值和节点一一对应起来。出于这个目的，ANTLR提供了一个简单的名为<code>ParseTreeProperty</code>的辅助类。</p>
<h4 id="不同的数据共享方法对比"><a href="#不同的数据共享方法对比" class="headerlink" title="不同的数据共享方法对比"></a>不同的数据共享方法对比</h4><p>为获取可复用的语法，需要使其与用户自定义的动作分离。这意味着将所有程序自身的逻辑代码放到语法之外的某种监听器或者访问器中。监听器和访问器通过操纵语法分析树来完成工作，ANTLR会自动生成合适的接口和默认实现类，以便语法分析树进行遍历。</p>
<ul>
<li>原生的Java调用栈：访问器返回一个用户指定类型的值。不过，如果访问器需要传递参数，那就必须使用下面两种方案：</li>
<li>基于栈的：在上下文类中维护一个栈字段，以与Java调用栈相同的方式，模拟参数和返回值的入栈和出栈。</li>
<li>标注：在上下文类中维护一个Map字段，用对应的值来标注节点。</li>
</ul>
<p>这三种方案都能将程序的具体逻辑封装在特定的对象内，从而使其与语法本身完全解耦。除此之外，它们各有利弊。需要综合考虑实际问题以及个人喜好，来决定使用哪种方案。</p>
<p>使用访问器方法的代码具有良好的可读性，这是因为它们直接调用其他的访问器方法来获得局部计算结果，同时能像其他方法一样返回值。访问器方法必须显式访问它们的子节点，而监听器无须如此。因为访问器的接口是通用的，因此在其中无法使用自定义的参数。访问器必须使用其他两种方案之一来解决调用子节点的访问器方法时的传参问题。访问器方法的空间效率较高，因为它在某一时刻只需保存少量的局部结果。在完成对树的遍历之后，局部结果就不存在了。虽然访问器方法能够返回值，但是所有的值都必须具有相同的类型，其他方案不会受到这样的限制。</p>
<p>基于栈的解决方案能够使用栈来模拟参数和返回值，但是，在手工操作栈的过程中，存在失误的可能性。这种情况可能在监听器方法没有直接调用其他监听器方法时发生。必须确保在未来的事件方法中，推出栈的内容是正确的。栈可以传递多个参数值和多个返回值。基于栈的解决方案同样具有较高的空间效率，因为不会在树中存储任何东西。所有局部结果的存储在树遍历完成之后都会被释放。</p>
<p>树标注是首选解决方案，它允许向事件方法提供任意信息来操纵语法分析树中的各个节点。通过该方案，可以传递多个任意类型的参数值。在很多情况下， 标注比存储转瞬即逝的值的栈更好，并且来回传递数据时更不同意失误。这种方案的唯一缺点是，在整个遍历的过程中，局部结果都会被保留，因此具有更大的内存消耗。</p>
<h2 id="构建真实的语言类应用程序"><a href="#构建真实的语言类应用程序" class="headerlink" title="构建真实的语言类应用程序"></a>构建真实的语言类应用程序</h2><h3 id="加载CSV数据"><a href="#加载CSV数据" class="headerlink" title="加载CSV数据"></a>加载CSV数据</h3><p>目标是编写一个自定义的监听器，将逗号分隔符文件(CSV)中的数据加载到一种精心设计的数据结构，由Map组成的List中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Details,Month,Amount</span><br><span class="line">Mid Bonus,June,&quot;$2,000&quot;</span><br><span class="line">,January,&quot;&quot;&quot;zippo&quot;&quot;&quot;</span><br><span class="line">Total Bonuses,&quot;&quot;,&quot;%5,000&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#123;Details=Mid Bonus,Month=June,Amount=&quot;$2,000&quot;&#125;,</span><br><span class="line"> &#123;Details=,Month=January,Amount=&quot;&quot;&quot;zippo&quot;&quot;&quot;&#125;,</span><br><span class="line"> &#123;Details=Total Bonuses,Month=&quot;&quot;,Amount=&quot;$5,000&quot;&#125;]</span><br></pre></td></tr></table></figure>

<p>为了获得更精确的监听器方法，对之前的CSV语法的备选分支进行标记</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grammar CSV;</span><br><span class="line"></span><br><span class="line">file : hdr row+</span><br><span class="line">hdr : row;</span><br><span class="line"></span><br><span class="line">row : field (&#x27;,&#x27; field)* &#x27;\r&#x27;? &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">field </span><br><span class="line">    : TEXT    # text</span><br><span class="line">    | STRING  # string</span><br><span class="line">    |         # empty</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TEXT : ~[,\n\r&quot;]+;</span><br><span class="line">STRING : &#x27;&quot;&#x27; (&#x27;&quot;&quot;&#x27;|~&#x27;&quot;&#x27;)* &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure>

<p>监听器的部分:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Loader</span> <span class="keyword">extends</span> <span class="title class_">CSVBaseListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EMPTY</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Map&lt;String, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; header;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; currentRowFieldValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitString</span><span class="params">(CSVParser.StringContex ctx)</span> &#123;</span><br><span class="line">        currentRowFieldValues.add(ctx.STRING().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitText</span><span class="params">(CSVParser.TextContext ctx)</span> &#123;</span><br><span class="line">        currentRowFieldValues.add(ctx.TEXT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitEmpty</span><span class="params">(CSVParser.EmptyContext ctx)</span> &#123;</span><br><span class="line">        currentRowFieldValues.add(EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitHdr</span><span class="params">(CSVParser.HdrContext ctx)</span> &#123;</span><br><span class="line">        header = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        header.addAll(currentRowFieldValues);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterRow</span><span class="params">(CSVParesr.RowContext ctx)</span> &#123;</span><br><span class="line">        currentRowFieldValues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitRow</span><span class="params">(CSVParser.RowContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前是标题行，什么都不做</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.getParent().getRuleIndex() == CSVParser.RULE_hdr) <span class="keyword">return</span>;</span><br><span class="line">        Map&lt;String, String&gt; m = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String v : currentRowFieldValues) &#123;</span><br><span class="line">            m.put(header.get(i), v);</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows.add(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是将CSV数据读入精心设计的数据结构所需的全部工作。</p>
<h4 id="将JSON翻译成XML"><a href="#将JSON翻译成XML" class="headerlink" title="将JSON翻译成XML"></a>将JSON翻译成XML</h4><p>和CSV语法一样，首先对JSON语法中的备选分支做一定的标记，以便ANTLR生成更精确的监听器方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">    : &#x27;&#123;&#x27; pair (&#x27;,&#x27; pair)* &#x27;&#125;&#x27; # AnObject</span><br><span class="line">    | &#x27;&#123;&#x27; &#x27;&#125;&#x27;                  # EmptyObject</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">array</span><br><span class="line">    : &#x27;[&#x27; value (&#x27;,&#x27; value)* &#x27;]&#x27; # ArrayOfValues</span><br><span class="line">    | &#x27;[&#x27; &#x27;]&#x27;                    # EmptyArray</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">value</span><br><span class="line">    : STRING    # String</span><br><span class="line">    : NUMBER    # Number</span><br><span class="line">    | object    # ObjectValue</span><br><span class="line">    | array     # ArrayValue</span><br><span class="line">    | &#x27;true&#x27;    # Atom</span><br><span class="line">    | &#x27;false&#x27;   # Atom</span><br><span class="line">    | &#x27;null&#x27;    # Atom</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>翻译器的实现需要令每条规则返回与它与匹配到的输入文本等价的XML。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">XMLEmitter</span> <span class="keyword">extends</span> <span class="title class_">JSONBaseListener</span> &#123;</span><br><span class="line">    ParseTreeProperty&lt;String&gt; xml = <span class="keyword">new</span> <span class="title class_">ParseTreeProperty</span>&lt;String&gt;();</span><br><span class="line">    String <span class="title function_">getXML</span><span class="params">(ParseTree ctx)</span> &#123;<span class="keyword">return</span> xml.get(ctx);&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setXML</span><span class="params">(ParseTree ctx, String s)</span> &#123;xml.put(ctx, s);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将每棵子树翻译完的字符串存储在该子树的根结点中。这样，工作在语法分析树更高层节点上的方法就能够获得它们，从而构造出更大的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitAtom</span><span class="params">(JSONParser.AtomContext ctx)</span> &#123;</span><br><span class="line">    setXML(ctx, ctx.getText());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitString</span><span class="params">(JSONParser.StringContext ctx)</span> &#123;</span><br><span class="line">    setXML(ctx, stripQuotes(ctx.getText()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitObjectValue</span><span class="params">(JSONParser.ObjectValueContext ctx)</span> &#123;</span><br><span class="line">    setXML(ctx, getXML(ctx.object()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitPair</span><span class="params">(JSONParer.PairContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> stripQuotes(ctx.STRING().getText());</span><br><span class="line">    JSONParser.<span class="type">ValueContext</span> <span class="variable">vctx</span> <span class="operator">=</span> ctx.value();</span><br><span class="line">    <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> String.format(<span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>, tag, getXML(vctx), tag);</span><br><span class="line">    setXML(ctx, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON的对象由一系列键值对组成。因此，对于每个object规则在AnObjec备选分支中发现的键值对，将其对应的XML追加到语法分析树中储存的结果之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitAnObject</span><span class="params">(JSONParser.AnObjectContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    buf.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (JSONParser.PairContext pctx : ctx.pair()) &#123;</span><br><span class="line">        buf.append(getXML(pctx));</span><br><span class="line">    &#125;</span><br><span class="line">    setXML(ctx, buf.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitEmptyObject</span><span class="params">(JSONParser.EmptyObjectContext ctx)</span> &#123;</span><br><span class="line">    setXML(ctx, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理数组的方式与之相似，从各子节点中获取XML结果，将其分别放入<code>&lt;element&gt;</code>标签之后连接起来即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitArrayOfValues</span><span class="params">(JSONParser.ArrayOfValuesContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    buf.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (JSONParser.ValueContext vctx : ctx.value()) &#123;</span><br><span class="line">        buf.append(<span class="string">&quot;&lt;element&gt;&quot;</span>);</span><br><span class="line">        buf.append(getXML(vctx));</span><br><span class="line">        buf.append(<span class="string">&quot;&lt;/element&gt;&quot;</span>);</span><br><span class="line">        buf.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setXML(ctx, buf.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitEmptyArray</span><span class="params">(JSONParser.EmptyArrayContext ctx)</span> &#123;</span><br><span class="line">    setXML(ctx, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，需要用最终的结果—-由根元素<code>object</code>或者<code>array</code>生成的结果—-标注语法分析树的根结点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json : object</span><br><span class="line">    | array</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>可以用一个简单的set操作来完成这项工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitJson</span><span class="params">(JSONParser.JsonContext ctx)</span> &#123;</span><br><span class="line">    setXML(ctx, getXML(ctx.getChild(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成调用图"><a href="#生成调用图" class="headerlink" title="生成调用图"></a>生成调用图</h3><p>使用Cymbol语法和DOT语言编写一个调用图生成器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;fact(); a();&#125;</span><br><span class="line"></span><br><span class="line">float fact(int n) &#123;</span><br><span class="line">    print(n);</span><br><span class="line">    if (n == 0) then return 1;</span><br><span class="line">    return n * fact(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">void a() &#123;int x = b(); if false then &#123;c();d();&#125;&#125;</span><br><span class="line">void b() &#123;c();&#125;</span><br><span class="line">void c() &#123;b();&#125;</span><br><span class="line">void d() &#123;&#125;</span><br><span class="line">void e() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>为了生成这样的可视化调用图，需要读取Cymbol程序，根据它产生一个DOT文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line">    ranksep=.25;</span><br><span class="line">    edge [arrowsize=.5]</span><br><span class="line">    node [shape=circle, fontname=&quot;ArialNarrow&quot;,</span><br><span class="line">            fontsize=12, fixedsize=true, height=.45];</span><br><span class="line">    main; fact; a; b; c; d; e;</span><br><span class="line">    main -&gt; fact;</span><br><span class="line">    main -&gt; a;</span><br><span class="line">    fact -&gt; print;</span><br><span class="line">    fact -&gt; fact;</span><br><span class="line">    a -&gt; b;</span><br><span class="line">    a -&gt; c;</span><br><span class="line">    a -&gt; d;</span><br><span class="line">    b -&gt; c;</span><br><span class="line">    c -&gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>策略是：当语法分析器遇到函数声明的时候，程序将会把该函数的名字加入一个列表中，然后在一个名为<code>currentFunctionName</code>的字段中记录它。当语法分析器遇到一个函数调用时，程序将会记录下一条从<code>currentFunctionName</code>到被调用函数名的边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expr</span><br><span class="line">    : ID &#x27;(&#x27; exprList? &#x27;)&#x27;  # Call</span><br><span class="line">    | expr &#x27;[&#x27; expr &#x27;]&#x27;     # Index</span><br><span class="line">    | &#x27;-&#x27; expr              # Negate</span><br><span class="line">    | &#x27;!&#x27; expr              # Not</span><br><span class="line">    | expr &#x27;*&#x27; expr         # Mult</span><br><span class="line">    | expr &#x27;==&#x27; expr        # AddSub</span><br><span class="line">    | ID                    # Equal</span><br><span class="line">    | INT                   # Int</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;          # Parens</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    Set&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">OrderedHashSet</span>&lt;String&gt;();</span><br><span class="line">    MultiMap&lt;String, String&gt; edges = <span class="keyword">new</span> <span class="title class_">MultiMap</span>&lt;String, String&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">edge</span><span class="params">(String source, String target)</span> &#123;</span><br><span class="line">        edges.map(source, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toDOT</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    buf.append(<span class="string">&quot;digraph G &#123;\n&quot;</span>);</span><br><span class="line">    buf.append(<span class="string">&quot;  ranksep=.25;\n&quot;</span>);</span><br><span class="line">    buf.append(<span class="string">&quot;  edge [arrowsize=,5]\n&quot;</span>);</span><br><span class="line">    buf.append(<span class="string">&quot;  node [shape=circle, fontname=\&quot;ArialNarrow\&quot;,\n&quot;</span>);</span><br><span class="line">    buf.append(<span class="string">&quot;        fontsize=12, fixedsize=true, height=.45];\n&quot;</span>);</span><br><span class="line">    buf.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String node : nodes) &#123;</span><br><span class="line">        buf.append(node);</span><br><span class="line">        buf.append(<span class="string">&quot;; &quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    buf.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String src : edges.keySet()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String tag : edges.get(src)) &#123;</span><br><span class="line">            buf.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            buf.append(src);</span><br><span class="line">            buf.append(<span class="string">&quot; -&gt; &quot;</span>);</span><br><span class="line">            buf.append(trg);</span><br><span class="line">            buf.append(<span class="string">&quot;;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf.append(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要做的一切就是使用监听器填充这些数据结构。该监听器需要两个用于记录的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FunctionListener</span> <span class="keyword">extends</span> <span class="title class_">CymbolBaseListener</span> &#123;</span><br><span class="line">    <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentFunctionName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它需要监听两个方法。第一个是当语法分析器遇到函数定义时的方法，令其记录当前函数名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterFuntionDecl</span><span class="params">(CymbolParser.FunctionDeclContext ctx)</span> &#123;</span><br><span class="line">    currentFunctionName = ctx.ID().getText();</span><br><span class="line">    graph.nodes.add(currentFcuntionName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，当语法分析器发现函数调用时，程序就会记录一条从当前函数到被调用的函数的边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitCall</span><span class="params">(CymbolParser.CallContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">funcName</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">    graph.edge(currentFunctionName, funcName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数调用不能出现嵌套的代码块或者声明中，如下面的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void a() &#123; int x = b(); if false then &#123;c(); d();&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>无论语法分析树遍历器在何处遇到函数调用，它都会触发<code>exitCall()</code>监听器方法。</p>
<p>通过语法分析树和上面的FunctionListener类，就可以用在遍历中使用自定义的监听器，并产生期望的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ParseTreeWalker</span> <span class="variable">walk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line"><span class="type">FunctionListener</span> <span class="variable">collector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FunctionListener</span>();</span><br><span class="line">walker.walk(collector, tree);</span><br><span class="line">System.out.println(collector.graph.toString());</span><br><span class="line">System.out.println(collector.graph.toDOT());</span><br></pre></td></tr></table></figure>

<h3 id="验证程序中符号的使用"><a href="#验证程序中符号的使用" class="headerlink" title="验证程序中符号的使用"></a>验证程序中符号的使用</h3><p>在为类似Cymbol的编程语言编写解释器、编译器或者翻译器之前，需要确保Cymbol程序中使用的符号（标识符）用法正确。编写出一个能做出如下校验的Cymbol验证器：</p>
<ul>
<li>引用的扮靓必须有可见的（在作用域中）定义</li>
<li>引用的函数必须有定义（函数可以以任何顺序出现，即函数定义提升）</li>
<li>变量不可用作函数</li>
<li>函数不可用作变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int f(int x, float y) &#123;</span><br><span class="line">    g();    // 前向引用是没问题的</span><br><span class="line">    i = 3;  // 错误，i未定义</span><br><span class="line">    g = 4;  // 错误，g不是变量</span><br><span class="line">    return x + y;  // x, y 已定义，因此是正确的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void g() &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    float y;</span><br><span class="line">    y = g;</span><br><span class="line">    f();</span><br><span class="line">    z();</span><br><span class="line">    y();</span><br><span class="line">    x = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为验证一个程序中的所有内容都符合先前的定义，需要打印函数的列表和它们的局部变量，再加上全局符号（函数和全局变量）。此外，应该在发现问题的时候给出一个错误。解决上述问题的关键在于一种恰当的数据结构，称为<strong>符号表</strong>。程序将符号存储在符号表里，然后通过它来检查标识符引用的正确性。</p>
<h4 id="符号表速成"><a href="#符号表速成" class="headerlink" title="符号表速成"></a>符号表速成</h4><p>语言的实现者通常把存储符号的数据结构称为符号表。实现这样的语言意味着建立复杂的符号表结构。如果一门语言允许相同的标识符在不同的上下文中具备不同含义，那么对应的符号表实现就需要将符号按照作用域分组。一个作用域仅仅是一组符号的集合，例如一组函数的参数列表或者全局作用域中定义的变量和函数。</p>
<p>符号表本身仅仅是符号定义的仓库—-它不进行任何验证工作。需要按照之前确定的规则，检查表达式中引用的变量和函数，以完成代码的验证。符号验证的过程中有两种基本的操作：定义符号和解析符号。定义一个符号意味着将它添加到作用域中。解析一个符号意味着确定该符号引用了哪个定义。在某种意义上，解析一个符号意味着寻找“最接近”的符号定义。最接近的定义域就是最内层的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">void a()</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">    &#123;int y = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line">void b(int z)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证器的架构"><a href="#验证器的架构" class="headerlink" title="验证器的架构"></a>验证器的架构</h4><p>为完成该验证器，从全局的角度进行一下规划。可以将这个问题分解为两个关键的操作：定义和解析。对于定义，需要监听变量和函数定义的事件，生成Symbol对象并将其加入该定义所在的作用域中。在函数定义开始时，需要将一个新的作用域”入栈“，然后在它结束时将该作用域”出栈“。</p>
<p>对于解析和校验符号引用，需要监听表达式中的变量和函数引用的事件。对于每个引用，要验证是否存在一个匹配的符号定义，以及该引用是否正确使用了该符号。一个难题是：一个Cymbol程序可以在函数声明之前就调用它。称之为**前向引用(forward reference)**。为了支持这种情况，需要对语法分析树进行两趟遍历，第一趟遍历—-对包括函数在内的符号进行定义，第二趟遍历中就可以看到文件中的全部函数了。下列代码触发了对语法分析树的两趟遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ParseTreeWalker</span> <span class="variable">walker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line"><span class="type">DefPhase</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefPhase</span>();</span><br><span class="line">walker.walk(def, tree);</span><br><span class="line"><span class="comment">// 新建一个阶段，将def中符号表信息传递给该阶段</span></span><br><span class="line"><span class="type">RefPhase</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefPhase</span>(def.globals. def.scopes);</span><br><span class="line">walker.walk(ref, tree);</span><br></pre></td></tr></table></figure>

<p>在定义阶段，将会创建很多个作用域，必须保持对这些定义域的引用，否则垃圾回收器会将它们清除掉。为保证符号表在从定义阶段到解析阶段的转换过程中始终存在，需要追踪这些作用域。最合乎逻辑的存储位置是语法分析树本身(或者使用一个将节点和值映射起来的标注Map)。这样，在沿语法分析树下降的过程中，查找一个引用对应的作用域就变得十分容易，因为函数或者局部代码块对应的树节点可以获得指向自身作用域的指针。</p>
<h4 id="定义和解析符号"><a href="#定义和解析符号" class="headerlink" title="定义和解析符号"></a>定义和解析符号</h4><p>确定了全局的策略，就可以开始编写验证器了，不妨从DefPhase开始，需要三个字段：一个全局作用域的引用、一个用于追踪创建的作用域的语法分析树标注器，以及一个指向当前作用域的指针。监听器方法<code>enterFile()</code>启动了整个验证过程，并创建了一个全局作用域。最后的exitFile()方法负责打印结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefPhase</span> <span class="keyword">extends</span> <span class="title class_">CymbolBaseListener</span> &#123;</span><br><span class="line">    ParseTreeProperty&lt;Scope&gt; scopes = <span class="keyword">new</span> <span class="title class_">ParseTreeProperty</span>&lt;Scope&gt;();</span><br><span class="line">    GlobalScope globals;</span><br><span class="line">    Scope currentScopes;  <span class="comment">// 当前符号的作用域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterFile</span><span class="params">(CymbolPaser.FileContext ctx)</span> &#123;</span><br><span class="line">        globals = <span class="keyword">new</span> <span class="title class_">GlobalScope</span>(<span class="literal">null</span>);</span><br><span class="line">        currentScope = globals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitFile</span><span class="params">(CymbolParser.FileContext ctx)</span> &#123;</span><br><span class="line">        System.out.println(globals);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当语法分析器发现一个函数定义时，程序需要创建一个<code>FunctionSymbol</code>对象。<code>FunctionSymbol</code>对象有两项职责：作为一个符号，以及作为一个包含参数的作用域。为构造一个嵌套在全局作用域中的函数作用域，将一个函数作用域“入栈”，“入栈”是通过将当前作用域设置为该函数作用域的父作用域，并将它本身设置为当前作用域来完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterFunctionDecl</span><span class="params">(CymbolParser.FunctionDeclContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">    <span class="type">int</span> <span class="variable">typeTokenType</span> <span class="operator">=</span> ctx.type().start.getType();</span><br><span class="line">    Symbol.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> CheckSymbols.getType(typeTokenType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个指向外围作用域的作用域，这样就完成了入栈操作</span></span><br><span class="line">    <span class="type">FunctionSymbol</span> <span class="variable">function</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FunctionSymbol</span>(name, type, currentScope);</span><br><span class="line">    currentScope.define(function);  <span class="comment">// 在当前作用域中定义函数</span></span><br><span class="line">    saveScope(ctx, function);       <span class="comment">// 入栈：设置函数作用域的父作用域为当前作用域</span></span><br><span class="line">    currentScope = function;        <span class="comment">// 现在当前作用域就是函数作用域了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">saveScope</span><span class="params">(ParserRuleContext ctx, Scope s)</span> &#123;scopes.put(ctx, s);&#125;</span><br></pre></td></tr></table></figure>

<p>方法saveScope() 使用新建的函数作用域标注了该functionDecl规则节点，这样之后进行的下一个阶段就能轻易获取相应的作用域。在函数结束时，将函数作用域“出栈”，这样当前作用域就恢复为全局作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitFunctionDecl</span><span class="params">(CymbolParser.FunctionDeclContext ctx)</span> &#123;</span><br><span class="line">    System.out.println(currentScope);</span><br><span class="line">    currentScope = currentScope.getEnclosingScope(); <span class="comment">// 作用域“出栈”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部作用域实现与之类似。在监听器方法enterBlock()中将一个作用域入栈，然后在exitBlock()中将其出栈。接下来完成对参数和变量的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitFormalParameter</span><span class="params">(CymbolParser.FormalParameterContext ctx)</span> &#123;</span><br><span class="line">    defineVar(ctx.type(), ctx.ID().getSymbol());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitVarDecl</span><span class="params">(CymbolParser.VarDeclContext ctx)</span> &#123;</span><br><span class="line">    defineVar(ctx.type(), ctx.ID().getSymbol());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">defineVar</span><span class="params">(CymbolParser.TypeContext typeCtx, Token nameToken)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">typeTokenType</span> <span class="operator">=</span> typeCtx.start.getType();</span><br><span class="line">    Symbol.<span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> CheckSymbols.getType(typeTokenType);</span><br><span class="line">    <span class="type">VariableSymbol</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VariableSymbol</span>(nameToken.getText(), type);</span><br><span class="line">    currentScope.define(<span class="keyword">var</span>);   <span class="comment">// 在当前作用域中定义符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了定义阶段代码的编写，下面编写解析阶段的代码，首先，将当前作用域设置为定义阶段中得到的全局作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RefPhase</span><span class="params">(GlobalScope globals, ParseTreeProperty&lt;Scope&gt; scopes)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.scopes = scopes;</span><br><span class="line">    <span class="built_in">this</span>.globals = globals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterFile</span><span class="params">(CymbolParser.FileContext ctx)</span> &#123;</span><br><span class="line">    currentScope = globals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，当树遍历器触发Cymbol函数和代码的进入和推出方法时，根据定义阶段在树中存储的值，将currentScope设为对应的作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterFunctionDecl</span><span class="params">(CymbolParser.FunctionDeclContext ctx)</span> &#123;</span><br><span class="line">    currentScope = scopes.get(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitFunctionDecl</span><span class="params">(CymbolParser.FunctionDeclContext ctx)</span> &#123;</span><br><span class="line">    currentScope = currentScope.getEnclosingScope();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterBlock</span><span class="params">(CymbolParser.BlockContext ctx)</span> &#123;</span><br><span class="line">    currentScope = scopes.get(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitBlock</span><span class="params">(CymbolParser.BlockContext ctx)</span> &#123;</span><br><span class="line">    currentScope = currentScope.getEnclosingScope();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历器正确设置作用域之后，就可以在变量引用和函数调用的监听器方法中解析符号了。当遍历器遇到一个变量引用时，它调用<code>exitVar()</code>,该方法使用<code>resolve()</code>方法在当前作用域的符号表中查找该变量名。如果<code>resolve</code>方法在当前作用域中没有找到相应的符号，它会沿着外围作用域链查找。必要情况下，<code>resolve</code>将会一直向上查找，直至全局作用域为止。如果它没有找到合适的定义，则返回null。此外，若<code>resolve()</code>方法找到的符号是函数而非变量，就需要生成一个错误消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitVar</span><span class="params">(CymbolParser.VarContext ctx)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ctx.ID().getSymbol().getText();</span><br><span class="line">    <span class="type">Symbol</span> <span class="variable">var</span> <span class="operator">=</span> currentScope.resolve(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">var</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        CheckSymbols.error(ctx.ID().getSymbol(), <span class="string">&quot;no such variable: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">var</span> <span class="keyword">instanceof</span> FunctionSymbol) &#123;</span><br><span class="line">        CheckSymbols.error(ctx.ID().getSymbol(), name + <span class="string">&quot;is not a varible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理函数调用的方法与之基本相同。如果找不到定义，或者找到的定义是变量，那么就输出一个错误。</p>
<h2 id="错误报告与恢复"><a href="#错误报告与恢复" class="headerlink" title="错误报告与恢复"></a>错误报告与恢复</h2><p>同绝大多数软件一样，在开发一门语法的过程中，需要修复很多的错误。直到编写完并调试完语法之后，生成的语法分析器才能识别所有的有效输入语句。在这个过程中，ANTLR的错误消息含有丰富的信息，有助于调试语法过程中产生的问题。一旦拥有了正确的语法，就必须处理不合语法的语句，这些语句可能来源于用户输入，甚至是其他程序在错误情况下自动生成的。</p>
<p>使用ANTLR的开发者将会无偿获得它提供的优秀的错误报告功能和复杂的错误恢复机制。ANTLR生成的语法分析器能够自动地在遇到句法错误时产生丰富的错误消息，并且能在大多数情况下成功地完成重新同步。这样的语法分析器甚至能够保证只为每个句法错误产生一条错误消息。</p>
<h3 id="错误入门处理"><a href="#错误入门处理" class="headerlink" title="错误入门处理"></a>错误入门处理</h3><p>描述ANTLR的错误恢复策略，最好的方法是观察一个ANTLR自动生成的语法分析器对错误输入产生的响应。下面是一个类Java语言的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">grammar Simple;</span><br><span class="line"></span><br><span class="line">prog: classDef+;  // 匹配一个或多个类定义</span><br><span class="line">classDef</span><br><span class="line">    : &#x27;class&#x27; ID &#x27;&#123;&#x27; member+ &#x27;&#125;&#x27;  // 一个类具有若干个成员</span><br><span class="line">        &#123;System.out.println(&quot;class &quot;+$ID.text);&#125;</span><br><span class="line">    ;</span><br><span class="line">member</span><br><span class="line">    : &#x27;int&#x27; ID &#x27;;&#x27;   // 字段定义</span><br><span class="line">        &#123;System.out.println(&quot;var &quot;+$ID.text);&#125;</span><br><span class="line">    | &#x27;int&#x27; f=ID &#x27;(&#x27; ID &#x27;)&#x27; &#x27;&#123;&#x27; stat &#x27;&#125;&#x27; // 方法定义</span><br><span class="line">        &#123;System.out.println(&quot;method: &quot;+$f.text);&#125;</span><br><span class="line">    ;</span><br><span class="line">stat: expr &#x27;;&#x27;</span><br><span class="line">        &#123;System.out.println(&quot;found expr: &quot;+$ctx.getText());&#125;</span><br><span class="line">    | ID &#x27;=&#x27; expr &#x27;;&#x27;</span><br><span class="line">        &#123;System.out.println(&quot;found assign: &quot;+$ctx.getText());&#125;</span><br><span class="line">    ;</span><br><span class="line">expr: INT</span><br><span class="line">    | ID &#x27;(&#x27; INT &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">INT : [0-9]+;</span><br><span class="line">ID  : [a-zA-Z]+;</span><br><span class="line">WS  : [ \t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>其中的<strong>内嵌动作</strong>会打印出语法分析器发现的相应元素。出于方便和简洁的目的，使用<strong>内嵌动作</strong>来代替语法分析树监听器。</p>
<p>当输入的程序遗漏了一个分号时<code>;</code>，语法分析器会在<code>;</code>处报告一个错误，并且给出一个信息2⃣️更大的结果，因为它知道<code>;</code>后面的词法符号是分析器期望看到的。这个特性叫做**单词法符号移除(single-token deletion)**，实现这个特性只需要语法分析器假设多余的那个词法符号不存在，然后继续解析过程即可。</p>
<p>同样，在语法分析器检测到词法符号缺失的时候，它也可以完成**单词法符号补全(single-token insertion)**。</p>
<p>另外一种常见的句法错误发生在语法分析器做出决策的关键位置，剩余的输入文本不符合规则的任意一个备选分支。如果在字段声明中遗漏了变量名，member规则的两个备选分支都无法匹配这样的输入。</p>
<p>如果存在词法错误，ANTLR也会给出一个错误消息，指明它无法将一个或者多个字符匹配为词法符号。例如，如果输入一个完全未知的字符，就会得到一个词法符号识别错误。</p>
<p>如果需要控制语法分析器对这样的词法符号的生成机制，覆盖<code>DefaultErrorStrategy</code>类中的<code>getMissingSymbol()</code>方法即可。</p>
<p>除了产生良好的错误消息和利用剩余的输入进行重新同步之外，语法分析器还必须能够移动到合适的位置继续语法分析过程。</p>
<p>例如，当通过<code>classDef</code>规则中的子规则member匹配类成员时，语法分析器不应该遇到非法的成员定义时结束<code>classDef</code>。这就是语法分析器能够跳过错误的原因—-一个句法错误不应该让语法分析器结束当前规则。语法分析器将会尽最大可能匹配到一个合法的类定义。</p>
<h3 id="修改和转发ANTLR的错误消息"><a href="#修改和转发ANTLR的错误消息" class="headerlink" title="修改和转发ANTLR的错误消息"></a>修改和转发ANTLR的错误消息</h3><p>默认情况下，ANTLR将所有的错误消息送至标准错误(standard error),不过可以通过实现接口<code>ANTLRErrorListener</code>来改变这些消息的目标输出和内容。该接口有一个同时应用于词法分析器和语法分析器<code>syntaxError()</code>方法。<code>syntaxError()</code>方法接收各式各样的信息，无论是错误的位置还是错误的内容。它还接收指向语法分析器的引用，因此能够通过该引用来查询识别过程的状态。</p>
<p>例如，下面错误监听器(error listener)能够在通常的带有词法符号信息的错误消息后打印出规则的调用栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VerboseListener</span> <span class="keyword">extends</span> <span class="title class_">BaseErrorListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syntaxError</span><span class="params">(Recognizer&lt;?,?&gt; recognizer,</span></span><br><span class="line"><span class="params">                            Object offendingSymbol,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> line, <span class="type">int</span> charPositionInLine,</span></span><br><span class="line"><span class="params">                            String msg,</span></span><br><span class="line"><span class="params">                            RecognitionException e)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; stack = ((Parser)recognizer).getRuleInvocationStack();</span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        System.err.println(<span class="string">&quot;rule stack: &quot;</span> + stack);</span><br><span class="line">        System.err.println(<span class="string">&quot;line &quot;</span> + line + <span class="string">&quot;:&quot;</span> + charPositionInLine + <span class="string">&quot; at &quot;</span> + offendingSymbol + <span class="string">&quot;; &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方法，程序就能在语法分析器调用起始规则之前，轻易地为其增加一个错误监听器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleParser</span>(tokens);</span><br><span class="line">parser.removeErrorListener();   <span class="comment">// 移除ConsoleErrorListener</span></span><br><span class="line">parser.addErrorListener(<span class="keyword">new</span> <span class="title class_">VerboseListener</span>()); <span class="comment">// 增加自定义的错误监听器</span></span><br><span class="line">parser.prog();   <span class="comment">// 进行解析过程</span></span><br></pre></td></tr></table></figure>

<h3 id="自动错误恢复机制"><a href="#自动错误恢复机制" class="headerlink" title="自动错误恢复机制"></a>自动错误恢复机制</h3><p>错误恢复指的是允许语法分析器在发现语法错误后还能继续的机制。原则上，最好的错误恢复来自人类在手工编写的递归下降的语法分析器中进行的干预。</p>
<p>ANTLR在必要情况下，语法分析器在遇到无法匹配词法符号的错误时，执行单词法符号补全和单词法符号移除。如果这些方案不奏效，语法分析器将向后查找词法符号，直到它遇到一个符合当前规则的后续部分的合理词法符号为止，接着，语法分析器将会继续语法分析过程，仿佛什么事情都没有发生一样。</p>
<p>ANTLR使用的基本错误恢复策略</p>
<h4 id="通过扫描后续词法符号来恢复"><a href="#通过扫描后续词法符号来恢复" class="headerlink" title="通过扫描后续词法符号来恢复"></a>通过扫描后续词法符号来恢复</h4><p>当面对真正的非法输入时，当前的规则无法继续下去，此时语法分析器将会向后查找词法符号，直到它认为自己已经完成重新同步时，它就返回原先被调用的规则。直到它认为自己已经完成重新同步时，它就返回原先被调用的规则。可以称之为<strong>同步-返回(sync-and-return)**策略，有人称为</strong>应急模式(panic mode)**，不过它的表现相当好。语法分析器知道自己无法使用当前规则匹配当前输入。它会持续丢弃后续词法符号，直到发现一个可以匹配本规则中断为止之后的某条子规则的词法符号。如果在赋值语句中存在一个语法错误，那么语法分析器的做法就非常合理：丢弃后续的词法符号，直到发现一个分号或者其他的语句终结符为止。这种策略较为激进，但是十分有效。</p>
<p>每个ANTLR自动生产的规则方法都被包裹在一个<code>try-catch</code>块内，它对应语法错误的措施是报告该错误，并试图在返回之前从该错误中恢复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RecognitionException re) &#123;</span><br><span class="line">    _errHandler.reportError(<span class="built_in">this</span>, re);</span><br><span class="line">    _errHandler.recover(<span class="built_in">this</span>, re);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以认为<code>recover()</code>会持续消费词法符号，直到发现<code>重新同步集合resynchronization set</code>中的词法符号为止。重新同步集合是调用栈中所有规则的<code>后续符号集合following set</code>的并集。一条**规则引用(rule reference)**的后续符号集合是能够立即延续该规则，从而无须离开当前规则的词法符号集合。</p>
<p>下面是一个同步集合的理解:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grammar F;</span><br><span class="line">group</span><br><span class="line">    : &#x27;[&#x27; expr &#x27;]&#x27;    // expr 规则引用的后续词法符号：&#123;&#x27;]&#x27;&#125;</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;    // expr 规则引用的后续词法符号：&#123;&#x27;)&#x27;&#125;</span><br><span class="line">    ;</span><br><span class="line">expr: atom &#x27;^&#x27; INT;   // atom 规则引用的后续词法符号：&#123;&#x27;^&#x27;&#125;</span><br><span class="line">atom: ID</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br><span class="line">INT : [0-9]+</span><br><span class="line">ID  : [a-zA-Z]+;</span><br><span class="line">WS  : [ \t\r\n] -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>通过调用栈，就能清除地直到语法分析器抵达此处时，紧跟在每条被其调用的规则后面的词法符号的集合。后续符号集合只考虑那些在当前规则中出现的词法符号，因此，在运行时，可以只把当前调用栈对应的后续符号集合组合在一起。换句话说，无法同时途径group的两个备选分支来到规则expr处。</p>
<p>看看当语法分析器遇到错误的输入<code>[]</code>会发生什么：</p>
<p>语法F中的注释里给出了一些后续符号集合，将它们组合在一起，得到了上述输入的重新同步集合<code>&#123;&#39;^&#39;, &#39;]&#39;&#125;</code>。为了完成重新同步，语法分析器将持续消费词法符号，直到它发现重新同步集合中的词法符号为止。在本例中，当前的词法符号<code>]</code>正好是重新同步集合的成员之一，因此语法分析器实际上没有消费任何词法符号就完成了在atom中的重新同步。</p>
<p>在完成atom规则中的恢复过程后，语法分析器返回expr规则，但是它立即发现缺少<code>^</code>词法符号。上述恢复过程将会重复，语法分析器持续消费词法符号，直到发现expr规则的重新同步集合中的元素为止。expr规则的重新同步集合，也就是group规则的第一个备选分支中引用的expr的后续符号集合，即<code>&#123;&#39;]&#39;&#125;</code>。再一次，语法分析器没有消费任何东西就退出了expr规则，返回到了group规则的第一个备选分支中。现在语法分析器知道自己找到了expr规则引用之后的内容—-它成功地匹配到了group规则中的<code>&#39;]&#39;</code>,这样，语法分析器就成功地完成了重新同步。</p>
<p>在恢复过程中，ANTLR语法分析器会避免输出层叠的错误消息。即，对于每个语法错误，直到成功从该错误中恢复，语法分析器才输出一条错误消息。这件事情是通过一个简单的布尔类型的变量完成的，若该变量被置为true，当遇到语法错误时，语法分析器就能避免输出进一步的错误，直到语法分析器成功地匹配到一个词法符号，或者该变量被置为false为止。</p>
<p>在许多情况下，ANTLR能够更加智能地完成恢复，而不仅仅是“寻找重新同步集合中的符号”和“从当前规则返回”。它会尽力尝试“修复”输入文本并继续相同规则。</p>
<h4 id="从不匹配的词法符号中恢复"><a href="#从不匹配的词法符号中恢复" class="headerlink" title="从不匹配的词法符号中恢复"></a>从不匹配的词法符号中恢复</h4><p>在语法分析的过程，最常见的操作之一就是“匹配词法符号”，对于语法中的每个词法符号T，语法分析器都会调用<code>match(T)</code>。如果当前的词法符号不是T，match方法就会通知错误监听器，并试图重新同步。为完成同步，它有三种选择：</p>
<ul>
<li>移除一个词法符号</li>
<li>补全一个词法符号</li>
<li>简单地抛出一个异常以启用基本的同步-返回机制</li>
</ul>
<p>如果能够成功的话，移除当前的词法符号是重新同步最容易的方法。考虑“简单类定义语言”里面的classDef规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classDef</span><br><span class="line">    : &#x27;class&#x27; ID &#x27;&#123;&#x27; member &#x27;&#125;&#x27;</span><br><span class="line">      &#123;System.out.println(&quot;class &quot; + $ID.text);&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>考虑输入文本<code>class 9 T &#123;int i;&#125;</code>,语法分析器会删除9，然后继续同一条规则的语法分析过程—-匹配类的定义体。如果语法分析器无法通过移除一个词法符号的方式重新同步，它会转而尝试补全一个词法符号。</p>
<p>比如，语法分析器调用了<code>match(ID)</code>,期望发现一个标识符，但是实际上发现的却是<code>&#123;</code>。在这种情况下，语法分析器知道<code>&#123;</code>是自己所期望的那个词法符号的下一个，因为<code>classDef</code>规则中位于ID之后。此时<code>match()</code>方法可以假定标识符已经被发现并返回，这样，下一个<code>match(&#39;&#123;&#39;)</code>的调用就会成功。</p>
<p>在忽略内嵌动作的前提下，这种方案表现得相当出色。但是，如果词法符号是<code>null</code>,通过<code>$ID.text</code>引用了缺失词法符号的打印语句就会引起一个异常。因此，错误处理器会创建一个词法符号，而非简单的假定该词法符号存在，详情参见<code>DefaultErrorStrategy</code>中的<code>getMissingSymbol()</code>方法。新创建的词法符号具有语法分析器所期望的类型，以及和当前词法符号相同的行列位置信息。这个新创建的词法符号阻止了监听器和访问器中引用缺失词法符号时引发的异常。</p>
<p>分析语法分析过程最容易的方法是查看语法分析树，它展示了语法分析器识别词法符号的细节。一旦遇到错误，语法分析树就会用红色高亮标注那些词法分析器在重新同步过程中移除或者补全的词法符号。</p>
<p>显然，对词法分析的目的而言，一个<code>&lt;missing ID&gt;</code>标识符没有任何意义，不过，至少错误恢复机制不会引起一堆空指针异常了。</p>
<h4 id="从子规则的错误中恢复"><a href="#从子规则的错误中恢复" class="headerlink" title="从子规则的错误中恢复"></a>从子规则的错误中恢复</h4><p>在语法中手工插入一条空规则的引用，该规则包含特定的、能够在必要时触发错误恢复的动作。ANTLR4会在开始处和循环条件判定处自动插入同步检查，以避免激进的恢复机制。</p>
<ul>
<li><strong>子规则起始位置</strong>-在任意子规则的起始位置，语法分析器会尝试进行单词法符号移除。不过，和词法符号匹配不同的是，语法分析器不会尝试进行单词法符号补全。创建一个词法符号对ANTLR来说是很困难的，因为它必须猜测多个备选分支中的哪一个最终会胜出。</li>
<li><strong>子规则的循环条件判定位置</strong>-如果子规则是一个循环结构，即<code>(...)*</code>或<code>(...)+</code>,在遇到错误时，语法分析器会尝试进行积极的恢复，使得自己留在循环内部。在成功地匹配到循环的某个备选分支之后，语法分析器会持续消费词法符号，直到发现满足下列条件之一的词法符号为止：</li>
</ul>
<ol>
<li>循环的另一次迭代</li>
<li>紧跟在循环之后的内容</li>
<li>当前规则的重新同步集合中的元素</li>
</ol>
<h4 id="捕获失败的语义判定"><a href="#捕获失败的语义判定" class="headerlink" title="捕获失败的语义判定"></a>捕获失败的语义判定</h4><p>目前暂时将语义判定看作断言。它们指定了一些必须在运行时为真的条件，以使得语法分析器能够通过这些条件的验证。如果一个判定结果为假，语法分析器会抛出一个<code>FailedPredicateException</code>异常，该异常会被当前规则的catch语句捕获。语法分析器随即报告一个错误，并运行通用的同步-返回恢复机制。</p>
<p>下面是一个使用语法判定来限制向量中整数数量的例子，它与之前“使用语义判定改变语法分析过程”部分中的语法非常相似。ints规则匹配最多max个整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grammar Vec;</span><br><span class="line">vec4: &#x27;[&#x27; ints[4] &#x27;]&#x27;;</span><br><span class="line">ints[int max]</span><br><span class="line">locals [int i=1]</span><br><span class="line">    : INT ( &#x27;,&#x27; &#123;$i++;&#125; &#123;$i&lt;=$max&#125;? INT )*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>下列测试给出的整数过多，于是会看到一个错误消息，以及错误恢复的过程，在这个过程中，多余的逗号和整数被丢弃了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ antlr4 Vec.g4</span><br><span class="line">$ javac Vec*.java</span><br><span class="line">$ grun Vec vec4</span><br><span class="line">-&gt; [1,2,3,4,5,6]</span><br><span class="line">-&gt; EOF</span><br><span class="line">$ line 1:9 rule ints failed predicate: &#123;<span class="variable">$i</span> &lt;= <span class="variable">$max</span>&#125;?</span><br></pre></td></tr></table></figure>

<p>作为语法设计者，其中的<code>&#123;$i &lt;= $max&#125;</code>错误消息很有帮助，但是用户读不懂。可以修改这条信息，通过语义判定使用<code>fail</code>选项，让它从一堆代码变成一些可读的文字。例如：下面是ints的修改版，通过一个动作来动态生成可读的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ints[int max]</span><br><span class="line">locals [int i=1]</span><br><span class="line">    : INT (&#x27;,&#x27; &#123;$i++;&#125; &#123;$i&lt;=$max&#125;?&lt;fail=&#123;&quot;exceeded max &quot;+$max&#125;&gt; INT)*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>现在在相同的输入下，可以获得更好的错误消息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ line 1:9 rule ints exceeded max 4</span><br></pre></td></tr></table></figure>

<p><code>fail</code>选项接受两种参数：双引号包围的字符串常量或者一个可以得到字符串的动作。如果希望在判定失败时执行一个函数，使用动作是极其方便的，只需在动作中调用该函数即可，例如<code>&#123;...&#125;? &lt;fail=&#123;failedMaxTest()&#125;&gt;</code>.</p>
<p>关于使用语义判定来验证输入有效性这件事情，还有一些需要注意的地方。在上面的向量例子中，判定的强制性针对的是句法规则，所以抛出异常并尝试恢复是没有问题的。但是，如果输入的结构在语法是有效的，但是在语义上是无效的，这时，语义判定就不适用了。</p>
<p>假设存在一种语言，可以给一个变量赋予任何除零之外的值，这意味着”assignment x = 0;”在语法上是有效的，但是在语义上是无效的。显然，这种情况下，需要向用户输出一个错误，但是不应该触发错误处理机制。”x = 0;”在句法上是完全合法的。在某种意义上，语法分析器将会自动地从错误中恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign</span><br><span class="line">    : ID &#x27;=&#x27; v=INT &#123;$v.int&gt;0&#125;? &#x27;;&#x27;</span><br><span class="line">      &#123;System.out.println(&quot;assign &quot;+$ID.text+ &quot; to &quot;);&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>如果<code>assign</code>规则中的判定过程抛出了一个异常，同步-返回机制表现出的行为就会是丢弃判定后的<code>;</code>。这种行为可能能够正常工作，但是面临的风险是不完美的重新同步。更好的解决方案是手工输出一个错误，然后令语法分析器按照正确的与语法继续进行匹配。所以，相比语义判定，应该使用一个带条件语句的动作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; if ($v.int == 0) notifyListeners(&quot;values must be &gt; 0&quot;); &#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误恢复机制的防护措施"><a href="#错误恢复机制的防护措施" class="headerlink" title="错误恢复机制的防护措施"></a>错误恢复机制的防护措施</h4><p>ANTLR的语法分析器具有内置的防护措施，以保证错误恢复过程正常结束。如果在相同的语法分析位置，遇到了相同的输入情况，语法分析器会在尝试进行恢复之前强制消费一个词法符号。</p>
<p>比如输入<code>int int x;</code>—-一个多余的int，语法分析器会检测到错误，从而尝试进行恢复。在正确的重新同步前，语法分析器会多次调用<code>recover()</code>并尝试重新开始语法分析。</p>
<p>输入<code>int int</code>不适用于member的任何一个备选分支，因此语法分析器执行了同步-返回错误恢复策略。它输出了第一条错误消息，然后开始消费词法符号，直到发现当前调用栈<code>[prog, classDef, member]</code>对应的重新同步集合中的词法符号为止。</p>
<p>因为语法中<code>classDef+</code>和<code>member+</code>循环的存在，计算重新同步集合的过程稍显复杂。在member的调用之后，语法分析器可能回到循环开头，再次匹配一个member，或者退出当前循环，匹配类定义尾部的<code>&#125;</code>。在<code>classDef</code>的调用之后，语法分析器可能回到循环开头匹配另外一个类定义，或者简单地退出<code>prog</code>规则。因此，调用栈<code>[prog, classDef, member]</code>对应的重新同步集合就是<code>&#123;&#39;int&#39;, &#39;&#125;&#39;, &#39;class&#39;&#125;</code>。</p>
<p>此时，语法分析器发现，不需要消费词法符号就可以完成恢复，因为当前的输入词法符号int位于重新同步集合中。因此，它返回到了调用者处：<code>classDef</code>规则的<code>member+</code>循环。该循环接着尝试匹配另一个类成员。不幸的是，由于它没有消费任何词法符号，语法分析器随即在返回member时再次检测到了错误。</p>
<p>在第二次错误的恢复中，语法分析器启用了防护措施，因为它在相同的语法分析位置遇到了相同的输入情况。在尝试重新同步之前，防护错误强制消费了一个词法符号。由于int位于重新同步集合中，它没有继续洗消费第二个词法符号。</p>
<h3 id="勘误备选分支"><a href="#勘误备选分支" class="headerlink" title="勘误备选分支"></a>勘误备选分支</h3><p>一些语法错误十分常见，以至于对它们进行特殊处理是值得的。例如，开发者经常在嵌套的函数调用后写错括号的数量。为了对这些情况进行特殊处理，只需增加一些备选分支，匹配这些常见错误即可。下面的语法识别单参数的函数调用，其中参数可能包含嵌套的括号。<code>fcall</code>规则具有两个所谓的<strong>勘误备选分支(error alternative)</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stat: fcall &#x27;;&#x27;;</span><br><span class="line">fcall</span><br><span class="line">    : ID &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    | ID &#x27;(&#x27; expr &#x27;)&#x27; &#x27;)&#x27; &#123;notifyErrorListeners(&quot;Too many parentheses&quot;);&#125;</span><br><span class="line">    | ID &#x27;(&#x27; expr &#123;notifyErrorListeners(&quot;Missing closing &#x27;)&#x27; &quot;);&#125; </span><br><span class="line"></span><br><span class="line">expr: &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>这些勘误备选分支会给ANTLR自动生成的语法分析器带来少量额外的工作，但是不会对他形成干扰。和其他备选分支一样，只要输入文本与之相符，语法分析器就会匹配到它们。</p>
<h3 id="修改ANTLR的错误处理策略"><a href="#修改ANTLR的错误处理策略" class="headerlink" title="修改ANTLR的错误处理策略"></a>修改ANTLR的错误处理策略</h3><p>默认的错误处理机制表现出色，不过还是会遇到一些非典型的、需要修改默认机制的场景。首先，希望关闭某些默认的错误处理功能，它们会带来额外的运行负担。其次，可能希望语法分析器在遇到第一个语法错误时就退出。这种情况的例子是，当处理类似bash的命令行输入时，从错误中恢复是毫无意义的。不能一意孤行地执行有风险的命令，因此语法分析器可以一遇到问题就退出。</p>
<p>首先查看一下<code>ANTLRErrorStrategy</code>接口以及实现类<code>DefaultError-Strategy</code>。该类完成了全部的默认错误处理工作。例如，下面的语句是每个ANTLR自动生成的规则函数中的catch中的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_errHandler.reportError(this, re);</span><br><span class="line">_errHandler.recover(this, re);</span><br></pre></td></tr></table></figure>

<p><code>_errHandler</code>是一个指向<code>DefaultErrorStrategy</code>实例的变量。<code>reportError()</code>方法和<code>recover()</code>方法实现了错误的报告和同步0返回功能。<code>reportError()</code>方法根据抛出的异常类型，将报告错误的职责委托给另外三个方法之一。</p>
<p>对于之前提到的第一种非典型场景：减少错误处理机制给语法分析器带来的运行负担。它是ANTLR根据Simple语法中的<code>member+</code>子规则自动生成的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_errHandler.sync(this);</span><br><span class="line">_la = input.LA(1);</span><br><span class="line">do &#123;</span><br><span class="line">    setState(22);</span><br><span class="line">    member();</span><br><span class="line">    setState(26);</span><br><span class="line">    _errHandler.sync(this);</span><br><span class="line">    _la = _input.LA(1);</span><br><span class="line">&#125; while (_la == 6);</span><br></pre></td></tr></table></figure>

<p>在某些程序中，可以假定输入在句法上是正确的，例如网络协议。在这种情况下，最好避免错误检查和恢复带来的负荷。可以通过以下方法达到这个目的：继承<code>DefaultErrorStrategy</code>类，并使用一个空方法覆盖<code>sync()</code>。Java编译器通常会在后续的优化过程中将<code>_errHandler.sync(this)</code>调用内嵌化，并执行无用代码消除。在下一个例子中，将会看到如何令语法分析器采取不同的错误处理策略。</p>
<p>另外一种非典型场景是令语法分析器在第一个语法错误处退出。为了达到这个目的，需要覆盖三个关键方法，详情如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BailErrorStrategy</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorStrategy</span> &#123;</span><br><span class="line">    <span class="comment">/** 不从异常e中恢复，而是用一个通用的</span></span><br><span class="line"><span class="comment">     *  RuntimeException包装它，这样它</span></span><br><span class="line"><span class="comment">     *  就不会被规则函数中的catch语句捕获</span></span><br><span class="line"><span class="comment">     *  异常e是生成的RuntimeException的cause成员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">(Parser recognizer, RecognitionException e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 确保不会试图执行行内恢复，如果语法分析器</span></span><br><span class="line"><span class="comment">     *  成功地进行了恢复，它就不会抛出一个异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Token <span class="title function_">recoverInline</span><span class="params">(Parser recognizer)</span> <span class="keyword">throws</span> RecognitionException </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">InputMismatchException</span>(recognizer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 确保不会试图从子规则的问题中恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">(Parser recognizer)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出于测试的目的，可以复用一些样例代码。除了创建和启动语法分析器外，还需要创建一个新的<code>BailErrorStrategy</code>实例， 并且令语法分析器使用它来替代默认的错误处理策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.setErrorHandler(<span class="keyword">new</span> <span class="title class_">BailErrorStrategy</span>());</span><br></pre></td></tr></table></figure>

<p>随后，应当令它在第一个词法错误处报错并退出。要达到这个目的，只需覆盖Lexer类中的recover方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BailSimpleLexer</span> <span class="keyword">extends</span> <span class="title class_">SimpleLexer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BailSimpleLexer</span><span class="params">(CharStream input)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">(LexerNoViableAltException e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">// 报错退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改语法分析器的错误报告策略，如果希望修改标准的错误消息“在输入X处没有可行的备选分支”，可以覆盖<code>reportNoViableAlternative()</code>方法，将错误消息改成其他内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyErrorStrategy</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportNoViableAlternative</span><span class="params">(Parser parser, NoViableAltException e)</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">        <span class="comment">// ANTLR基于语法生成的语法分析器是Parser的子类</span></span><br><span class="line">        <span class="comment">// Parser类继承了Recognizer类</span></span><br><span class="line">        <span class="comment">// 方法参数parser指向检测到错误的语法分析器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;can&#x27;t choose between alternatives&quot;</span>;</span><br><span class="line">        parser.notifyErrorListeners(e.getOffendingToken(), msg, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要的仅仅是改变错误消息输出的位置，可以指定一个<code>ANTLRErrorListener</code>。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>了解了错误报告和恢复机制的全部细节。利用<code>ANTLRErrorListener</code>和<code>ANTLRErrorStrategy</code>接口，能够非常灵活地指定错误消息的输出位置、错误消息的内容以及语法分析器从错误中恢复的方法。</p>
<h2 id="ANTLR属性和动作"><a href="#ANTLR属性和动作" class="headerlink" title="ANTLR属性和动作"></a>ANTLR属性和动作</h2><p>之前的内容几乎所有的程序逻辑代码都是与语法分析树遍历器分离的，这意味着代码总是在语法分析完成之后执行。一些语言类应用程序需要在语法分析过程中执行自身的逻辑代码。为了达到这个目的，需要一种手段，将代码片段—-称为动作—-直接注入ANTLR生成的代码中。</p>
<p>内嵌动作的用处：</p>
<ul>
<li>简便：有时，使用少量的动作，避免创建一个监听器或者访问器会使事情变得更加简单。</li>
<li>效率：在资源紧张的程序中，可能不想把宝贵的时间和内存浪费在建立语法分析树上。</li>
<li>带判定的语法分析过程：在某些罕见情况下，必须依赖从之前的输入流中获取的数据才能正常地进行语法分析过程。一些语法需要建立一个符号表，以便在未来根据情况差异化地识别输入的文本。</li>
</ul>
<p>动作就是使用目标语言(即ANTLR生成的代码的语言)编写的、放置在<code>&#123;...&#125;</code>中的任意代码块。可以在动作中编写任意代码，只要它们是合法的目标语言语句。动作的典型用法是操纵词法符号和规则引用的属性(attribute)。例如，可以读取一个词法符号对应的文本或者整个规则匹配的文本。通过词法符号和规则引用中获取的数据，就可以打印结果或者执行任意计算。规则允许参数和返回值，因此可以在规则之间传递数据。</p>
<h3 id="使用带动作的语法编写一个计算器"><a href="#使用带动作的语法编写一个计算器" class="headerlink" title="使用带动作的语法编写一个计算器"></a>使用带动作的语法编写一个计算器</h3><p>目标是在不使用访问器，甚至不建立语法分析树的前提下，重写编写一个功能相同的计算器。可以了解到如何将生成的语法分析树放入包中、定义语法分析器的字段和方法、在备选分支中插入动作、标记语法元素便在动作中使用，以及定义规则的返回值。</p>
<h4 id="在语法规则之外使用动作"><a href="#在语法规则之外使用动作" class="headerlink" title="在语法规则之外使用动作"></a>在语法规则之外使用动作</h4><p>在语法规则之外，希望将两种东西注入自动生成的语法分析器和词法分析器：package/import语句以及类似字段和方法这样的类成员。</p>
<p>下面是一份理想化的代码生成模版，它展示了在语法分析器这样的自动生成代码中，希望注入代码片段的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line"><span class="keyword">public</span> class &lt;grammarName&gt;Parser <span class="keyword">extends</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    &lt;members&gt;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在语法中使用<code>@header&#123;...&#125;</code>来指定一段<code>header</code>动作代码，使用<code>@members&#123;...&#125;</code>向生成的代码中注入字段或者方法。在一个联合了文法和词法的语法中，这些具名的动作会同时应用于语法分析器和词法分析器(ANTLR选项-package允许直接设定包名，而无需使用header动作)。如果需要限制一段动作代码只出现在语法分析器或者词法分析器中，可以使用<code>@parser::name</code>或者<code>@lexer::name</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">@header &#123;</span><br><span class="line">    package tools;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@parser::members &#123;</span><br><span class="line">    /** &quot;memory&quot;字段用于存储变量/变量值对 */</span><br><span class="line">    Map&lt;String, Integer&gt; memory = new Hashmap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    int eval(int left, int op, int right) &#123;</span><br><span class="line">        switch(op) &#123;</span><br><span class="line">            case MUL : return left * right;</span><br><span class="line">            case DIV : return left / right;</span><br><span class="line">            case ADD : return left + right;</span><br><span class="line">            case SUB : return left - right;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在规则中嵌入动作"><a href="#在规则中嵌入动作" class="headerlink" title="在规则中嵌入动作"></a>在规则中嵌入动作</h4><p>这些动作可以生成输出、更新数据结构，或者设置规则的返回值。</p>
<p>stat规则用于识别表达式，变量赋值语句和空行。因为发现空行时什么都不做，所以stat规则只需要两个动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: e NEWLINE  &#123;System.out.println(se.v);&#125;</span><br><span class="line">    | ID &#x27;=&#x27; e NEWLINE &#123;memory.put($ID.text, $e.v);&#125;</span><br><span class="line">    | NEWLINE</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>动作被执行的时机是它前面的语法元素之后，它后面的语法元素之前。在本例中，动作出现在备选分支的末尾，因此它们会在语法分析器匹配到整个语句之后被执行。当stat发现一个后面跟着NEWLINE的表达式时，它应当打印出该表达式的值；当stat发现一个变量赋值语句时，它就应当将该键值对存储到memory字段中。</p>
<p>这些动作代码中唯一陌生的语法是<code>$e.v</code>和<code>$ID.text</code>。通常<code>$x.y</code>是指元素x的y属性，其中x可以是词法符号引用或者规则引用。在这里，<code>$e.v</code>指的是调用规则e的返回值，<code>$ID.text$</code>指的是ID词法符号匹配到的文本。</p>
<p>如果ANTLR无法识别y属性，它就不会转换该属性。在本例中，text是一个词法符号的已知属性，所以ANTLR将它转换为<code>getText()</code>。还可以使用<code>$ID.getText()$</code>来达到相同效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">e returns [int v]</span><br><span class="line">    : a=e op=(&#x27;*&#x27;|&#x27;/&#x27;) b=e &#123;$v = eval($a.v, $op.type. $b.v);&#125;</span><br><span class="line">    | a=e op=(&#x27;+&#x27;|&#x27;-&#x27;) b=e &#123;$v = eval($a.v, $op.type. $b.v);&#125;</span><br><span class="line">    | INT                  &#123;$v = $INT.int;&#125;</span><br><span class="line">    | ID</span><br><span class="line">    &#123;</span><br><span class="line">        String id = $ID.text;</span><br><span class="line">        $v = memory.containsKey(id) ? memory.get(id) : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    | &#x27;(&#x27; e &#x27;)&#x27;  &#123;$v = $e.v;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>上面的例子指定了一个整数类型的返回值v。这就是之前stat的动作中引用<code>$e.v</code>的原因。ANTLR的返回值和Java的返回值的差异在于，需要为它们命名，并且可以有多个返回值。</p>
<p><code>op=(&#39;*&#39;|&#39;/&#39;)</code>标记可以指向一个词法符号，也可以指向在匹配词法符号或规则过程中生成的ParserRuleContext对象。</p>
<p>将一切打包称一个规则上下文对象，ANTLR通过对泽上下文对象(rule context object)来实现语法分析树的节点。每次规则调用都会新建并返回一个规则上下文对象，它存储了相应规则在输入流的特定位置上进行识别工作的所有重要信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> EContext <span class="title function_">e</span><span class="params">(...)</span> <span class="keyword">throws</span> RecognitionException &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>自然地，规则上下文对象非常适合放置与特定规则相关的数据实体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EContext</span> <span class="keyword">extends</span> <span class="title class_">ParserRuleContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> v;       <span class="comment">// 规则e的返回值，源于&quot;returns [int v]&quot;</span></span><br><span class="line">    <span class="keyword">public</span> EContext a;  <span class="comment">// (递归的)规则引用e上的标记a</span></span><br><span class="line">    <span class="keyword">public</span> Token op;    <span class="comment">// 类似(&#x27;*&#x27;|&#x27;/&#x27;)的运算符子规则上的标记</span></span><br><span class="line">    <span class="keyword">public</span> EContext b;  <span class="comment">// (递归的)规则引用e上的标记b</span></span><br><span class="line">    <span class="keyword">public</span> Token INT;   <span class="comment">// 第三个备选分支引用的INT</span></span><br><span class="line">    <span class="keyword">public</span> Token ID;    <span class="comment">// 第四个备选分支引用的ID</span></span><br><span class="line">    <span class="keyword">public</span> EContext e;  <span class="comment">// ed的调用过程对应的上下文对象的引用</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记总是会成为规则上下文对象的成员，但是ANTLR并不总是为类似ID，INT和e的备选分支元素生成字段。ANTLR只有在它们被语法中的动作引用时才为它们生成字段(例如e中的动作)。ANTLR会尽可能地减少上下文对象中字段的数量，</p>
<p>e中的所有动作都通过赋值语句<code>$v=...;</code>来设置返回值。该语句虽然设置了返回值，但是并不会导致对应的规则函数返回（不要在动作中使用return语句，它会使语法分析器崩溃）。下面是开头两个备选分支使用的动作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$v = eval($a.v, $op.type, $b.v);</span><br></pre></td></tr></table></figure>

<p>这段代码计算子表达式的值并将其赋给了e的返回值。<code>eval()</code>方法的参数是两个e引用的返回值<code>$a.v</code>和<code>$b.v$</code>，以及当前备选分支匹配到运算符类型<code>$op.type</code>。<code>$op.type$</code>必然是某个算术运算符的词法符号类型。可以重复使用同一个标记(只要它们指向相同类型的对象)。</p>
<p>第三个备选分支的动作中使用<code>$INT.int$</code>来访问INT词法符号匹配到的文本对应的整数。它仅仅是<code>Integer.valueOf($INT.text)</code>的简写。这些内嵌的动作比等价的访问器方法<code>visitInt()</code>要简单的多（代价是使程序的逻辑代码和语法纠缠在了一起）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** INT */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">visitInt</span><span class="params">(LabledExprParser.IntContext ctx)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(ctx.INT().getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四个备选分支识别一个变量的引用，如果在此之前它的值已经被存储过，就将e的返回值设置为该变量在memory中的值。这段动作代码使用了Java的<code>?:</code>运算符，不过也能轻易地将它改写成<code>if-else</code>的形式。可以在动作中放入任何东西，只要它们能在Java方法中正常工作即可。</p>
<p>最后一个备选分支中的<code>$v = $e.v</code>；动作将返回值设为括号中的表达式的值。</p>
<p>为在不同的表达式之间共享memory字段的值，需要用同一个语法分析器实例处理所有的输入行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExprParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExprParser</span>(<span class="literal">null</span>);   <span class="comment">// 共享同一个语法分析器的实例</span></span><br><span class="line">parser.setBuildParser(<span class="literal">false</span>);               <span class="comment">// 不需要建立语法分析树</span></span><br></pre></td></tr></table></figure>

<p>当读入一行时，需要新建一个词法符号流，将其传给共享的语法分析器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expr != <span class="literal">null</span>) &#123;   <span class="comment">// 当多于一个表达式时</span></span><br><span class="line">    <span class="comment">// 为每行(每个表达式)新建一个词法分析器和词法符号流</span></span><br><span class="line">    <span class="type">ANTLRInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ANTLRInputStream</span>(expr + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="type">ExprLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExprLexer</span>(input);</span><br><span class="line">    lexer.setLine(line);    <span class="comment">// 通知词法分析器输入的位置</span></span><br><span class="line">    lexer.setCharPositionInLine(<span class="number">0</span>); </span><br><span class="line">    <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">    parser.setInputStream(tokens);  <span class="comment">// 用新的词法符号流通知语法分析器</span></span><br><span class="line">    parser.stat();         <span class="comment">// 开始语法分析过程</span></span><br><span class="line">    expr = br.readLine();  <span class="comment">// 检查下一行是否存在</span></span><br><span class="line">    line++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问词法符号和规则的属性"><a href="#访问词法符号和规则的属性" class="headerlink" title="访问词法符号和规则的属性"></a>访问词法符号和规则的属性</h3><p>以CSV语法为基础，理解一些与动作相关的特性。</p>
<p>可以使用<code>locals</code>区域(section)定义局部变量。经过定义参数和返回值后，<code>locals</code>区域中的声明就会成为规则上下文对象的字段。由于在每次规则调用⌚都会获得一个新的规则上下文，可以预料，同时也获得了<code>locals</code>的一份新拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file</span><br><span class="line">locals [int i=0]</span><br><span class="line">    : hdr (row+=row[$hdr.text.split(&quot;,&quot;)] &#123;$i++;&#125; )+</span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println($i + &quot; rows&quot;);</span><br><span class="line">         for (RowContext r : $rows) &#123;</span><br><span class="line">             System.out.println(&quot;row token interval: &quot; + r.getSourceInterval());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>file规则定义了一个局部变量i，并且使用动作代码<code>$i++</code>来统计当前输入的行数。引用局部变量时请不要忘记<code>$</code>前缀，否则编译器会报告变量未定义的错误。ANTLR将<code>$i</code>转换成<code>_localctx.i</code>;在file规则对应的规则函数中，实际上是不存在局部变量i的。</p>
<p>规则调用<code>row[$hdr.text.split(&quot;,&quot;)]</code>显示，使用方括号而非圆括号来向规则传递参数(圆括号已经被ANTLR的子规则语法占用了)。参数表达式<code>$hdr.text.split(&quot;,&quot;)</code>将hdr规则匹配到的文本切分为一组row规则所需的字符串。</p>
<p><code>$hdr</code>是对唯一的hdr规则调用的引用，它指向本次调用的HdrContext对象。无需对hdr规则引用进行标记的原因是<code>$hdr</code>是独一无二的。因此，<code>$hdr.text</code>就是标题行匹配到的文本。使用标准的Java方法<code>String.split()</code>将逗号分隔的标题列切分为一组字符串。稍后会看到row规则接收一个字符串数组作为参数。</p>
<p>对row的调用也引入了一种新的标记，即<code>+=</code>而非<code>=</code>标记符。<code>=</code>用于跟踪单个值，而这里的标记rows是所有的row调用返回的<code>RowContext</code>对象的List。在打印出rows的数量后，file规则中最后的动作代码通过一个循环遍历了所有的<code>RowContext</code>对象。在循环的每次迭代中，它都打印出row规则调用匹配到的词法符号索引值范围。</p>
<p>ANTLR只能看到<code>locals</code>关键字定义的局部变量，而无法看到用户编写的任意内嵌动作中的局部变量。它们之间的差别在于，file规则对应的语法分析树节点只会定义字段i，而不会定义字段r。</p>
<p>现在转到hdr规则，在该规则中，仅仅打印出标题行的内容。可以通过<code>$hdr.text</code>来完成这项工作，就是row规则引用匹配到的文本。另外，也可以直接用<code>$text</code>获得当前的规则匹配到的文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdr : row[null] &#123;System.out.println(&quot;header: &quot; + $text.trim()+&quot;&#x27;&quot;);&#125;;</span><br></pre></td></tr></table></figure>

<p>现在使用row规则中的动作，将每行数据转换成以恶搞从列名到列值的Map。首先，row接收一组列名作为参数，返回一个Map。其次，为了在列名组成的数组中移动，需要一个局部变量col。在解析该行数据之前，需要初始化返回的Map。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 由规则&quot; row : field (&#x27;,&#x27; field)* &#x27;\r&#x27;? &#x27;\n&#x27;; &quot; 衍生而来 */</span><br><span class="line">row[String[] columns] returns [Map&lt;String, String&gt; values]</span><br><span class="line">locals [int col=0]</span><br><span class="line">@init &#123;</span><br><span class="line">    $values = new HashMap&lt;String, String&gt;(); </span><br><span class="line">&#125;</span><br><span class="line">@after &#123;</span><br><span class="line">    if ($values != null &amp;&amp; $values.size() &gt; 0) &#123;</span><br><span class="line">        System.out.println(&quot;values = &quot; + $values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    : field</span><br><span class="line">    &#123;</span><br><span class="line">        if ($columns != null) &#123;</span><br><span class="line">            $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (</span><br><span class="line">        &#x27;,&#x27; field</span><br><span class="line">        &#123;</span><br><span class="line">            if ($columns != null) &#123;</span><br><span class="line">                $values.put($columns[$col++].trim(), $field.text.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )* &#x27;\r&#x27;? &#x27;\n&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>init动作发生在对应规则匹配过程开始之前，无论它有多少个备选分支。同样，after动作发生在对应规则的备选分支之一完成匹配之后。在这个例子中，将打印语句置于row规则的最外层备选分支的末尾，以阐明after动作的功能。</p>
<p><code>field</code>动作的主要部分通过<code>$values.put(...)</code>将列名对应字段的值存储了结果map中。这个方法的第一个参数是这样得到的：获得列名，将索引值增一，然后使用<code>$columns[$col++].trim()</code>移除列名两侧的空白。第二个参数通过<code>$field.text.trim()</code>移除掉最近一次匹配到的字段文本两侧的空白(row中的两段动作代码是完全相同的，所以最好将它们重构为members动作中的一个方法)。</p>
<h3 id="识别关键字不固定的语言"><a href="#识别关键字不固定的语言" class="headerlink" title="识别关键字不固定的语言"></a>识别关键字不固定的语言</h3><p>例如，Java5新增一个一个关键字enum，因此同一个编译器必须能够根据<code> -version</code>选项动态地开启和关闭它。</p>
<p>也许更常见的应用是处理拥有巨量关键字集合的语言。可以令词法分析器分别匹配所有的关键字(作为独立的规则)，也可以编写一条ID规则作为分发器，然后在一个关键字列表中查找该规则匹配到的标识符。如果词法分析器发现该标识符是一个关键字，以它的词法符号类型从原先通用的ID类型改成相应的关键字类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar Keywords;</span><br><span class="line">@lexer::header &#123;</span><br><span class="line">    import java.util.*;</span><br><span class="line">&#125;</span><br><span class="line">stat: BEGIN stat* END</span><br><span class="line">    | IF expr THEN stat</span><br><span class="line">    | WHILE expr stat</span><br><span class="line">    | ID &#x27;=&#x27; expr &#x27;;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: INT | CHAR;</span><br><span class="line"></span><br><span class="line">tokens &#123;BEGIN, END, IF, THEN, WHILE&#125;</span><br></pre></td></tr></table></figure>

<p>将会使用一个Map存放从关键字到其整数词法符号类型的映射作为关键字表。另外，还使用了内联的Java实例化初始化语句（内层的花括号中的代码）定义了一个Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@lexer::membors &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; keywords = new HashMap&lt;String, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(&quot;begin&quot;, KeywordsParser.BEGIN);</span><br><span class="line">        put(&quot;end&quot;, KeywordsParser.END);</span><br><span class="line">        put(&quot;if&quot;, KeywordsParser.IF);</span><br><span class="line">        put(&quot;then&quot;, KeywordsParser.THEN);</span><br><span class="line">        put(&quot;while&quot;, KeywordsParser.WHILE);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配标识符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID : [a-zA-Z]+</span><br><span class="line">    &#123;</span><br><span class="line">        if (keywords.containsKey(getText())) &#123;</span><br><span class="line">            setType(keywords.get(getText())); // 重制词法符号类型</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>Lexer</code>类的<code>getText()</code>方法来获取当前词法符号的文本内容。根据它的文本内容来确定它是否存在于keywords中。如果存在，那么就将该词法符号的类型从ID重置为相应关键字的词法符号类型。</p>
<p>可以使用<code>setText()</code>方法修改一个词法符号的文本内容。它可以用于剥离字符常量或者字符串常量两侧的引号。通常，一个语言类应用程序只需要引号中文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** 将3个字符的‘x’输入序列转换成字符串 */</span><br><span class="line">CHAR : &#x27;\&#x27;&#x27; . &#x27;\.&#x27; &#123;setText(String.valueOf(getText().charAt(1)));&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>setToken()</code>方法指定词法分析器返回的Token对象。这是一种返回自定义的词法符号的方式。另外一种方式是覆盖<code>Lexer</code>的<code>emit()</code>方法。</p>
<p>相比于语法分析器，词法分析器需要动作的情况较少，不过在诸如需要修改词法符号类型或者文本的特定场景下，它们仍然相当有用。除了在对输入文本进行词法分析时执行动作之外，另一种修改词法符号本身的方法是查看词法分析后的词法符号流。</p>
<p>使用动作在语法中嵌入程序逻辑代码可以位于规则内，也可以位于规则外，通过header和members发挥作用。也看到了如何定义和引用规则的参数和返回值。</p>
<p>注意：尽可能地避免使用语法中的动作，因为它将一份语法绑定到了特定的目标变成语言上。不仅如此，动作还将语法绑定到了一个特定的程序上。</p>
<h2 id="使用语义判定修改语法分析过程"><a href="#使用语义判定修改语法分析过程" class="headerlink" title="使用语义判定修改语法分析过程"></a>使用语义判定修改语法分析过程</h2><p>嵌入动作不会影响语法分析器的语法分析过程，就好像记录日志的语句不会影响外围程序一样。内嵌动作仅仅是计算一些值或者打印结果。但是在一些罕见情况下，使用内嵌动作来修改语法分析过程是正确识别某些编程语言语句的唯一方法。</p>
<p>语义判定允许在运行时选择性地关闭部分语言。判定本身是布尔表达式，它会减少语法分析器的在语法分析过程中可选项的数量，适当地减少可选项的数量会增强语法分析器的性能！</p>
<p>语义判定可以在两种常见的情况下发挥作用：</p>
<ul>
<li>可能需要语法分析器处理同一门编程语言稍有差异的多个版本，例如数据库供应商的SQL语法会随着时间演进。</li>
<li>处理语法的歧义性。在某些编程语言中，相同的语法结构具有不同的含义，此时判定机制提供了一种方法，能够在对相同输入文本的不同解释中做出选择。</li>
</ul>
<p>语义判定<code>&#123;...&#125;?</code>提供了这样一种途径：能够基于符号表来“关闭”对输入文本做出的错误解释。这使得语法分析器别无选择，只能采用正确的解释。</p>
<h3 id="识别多种语言的多个版本"><a href="#识别多种语言的多个版本" class="headerlink" title="识别多种语言的多个版本"></a>识别多种语言的多个版本</h3><p>如何使用语义判定来关闭Java语法中的一部分，比如Java5的枚举。通过在运行过程中对布尔表达式求值，它能够达到识别不同方言的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">grammar Enum;</span><br><span class="line">@parser@members &#123;public static boolean java5;&#125;</span><br><span class="line"></span><br><span class="line">prog: ( stat | enumDecl )+;</span><br><span class="line"></span><br><span class="line">stat: id &#x27;=&#x27; expr &#x27;;&#x27; ; &#123;System.out.println($id.text + &quot;=&quot; + $expr.text);&#125;;</span><br><span class="line"></span><br><span class="line">expr: id </span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">enumDecl</span><br><span class="line">    : &#123;java5&#125;? &#x27;enum&#x27; name=id &#x27;&#123;&#x27; id (&#x27;,&#x27; id)* &#x27;&#125;&#x27;</span><br><span class="line">        &#123;System.out.println(&quot;enum &quot; + $name.text);&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">id  : ID</span><br><span class="line">    | &#123;!java5&#125;? &#x27;enum&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p><code>&#123;java5&#125;?</code>判定在运行的时候求值，当结果为假时，该备选分支就被关闭。还可以使用语义判定的非：<code>&#123;!java5&#125;?</code>，这就是利用运行期开关支持多方言语法的编写方法。</p>
<h3 id="关闭词法符号"><a href="#关闭词法符号" class="headerlink" title="关闭词法符号"></a>关闭词法符号</h3><p>还可以在词法分析器而非语法分析器中使用判定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stat: ID &#x27;=&#x27; expr &#x27;;&#x27; &#123; System.out.println($ID.text+&quot;=&quot;+$expr.text); &#125;;</span><br><span class="line">expr: ID</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br><span class="line">ENUM: &#x27;enum&#x27; &#123;java5&#125;?; // 必须放置在ID规则之前</span><br><span class="line">ID  : [a-zA-Z]+ ;</span><br></pre></td></tr></table></figure>

<p>注意：判定出现在词法规则的右侧，而非像文法规则一样的左侧。这是由于在语法分析中，语法分析器会对之后的内容进行预测，因此需要在匹配备选分支之前进行判定。</p>
<p>而词法分析器不进行备选分支的预测。仅仅寻找最长的匹配文本，然后在发现整个词法符号后作出决策。</p>
<p>当<code>java5</code>为假时，该判定关闭了ENUM规则。当它为真时，ENUM和ID同时匹配了字符序列<code>e-n-u-m</code>，此时该输入存在歧义。ANTLR总是通过选择位置靠前的规则来解决词法歧义问题，也就是这里的ENUM。</p>
<p>这种词法判定的解决方案的优雅之处在于，无须在语法分析器中放置一个判定，用于在非Java 5模式下关闭enum结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这里无须判定，因为&#x27;enum&#x27;词法符号在!java5的情况下并未定义</span><br><span class="line">enumDecl</span><br><span class="line">    : &#x27;enum&#x27; name=ID &#x27;&#123;&#x27; ID (&#x27;,&#x27; ID)* &#x27;&#125;&#x27;</span><br><span class="line">        &#123;System.out.println(&quot;enum &quot;+$name.text);&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>其中，备选分支开头的词法符号<code>enum</code>会寻找这样一个关键字词法符号。词法分析器只有在Java 5模式下才会将其输送给语法分析器，因此当java5为假时，enumDecl永远不会得到匹配。</p>
<p>判定会拖慢词法分析器，如果希望完全避免它，可以去掉ENUM规则，然后将enum作为关键字处理，可以对词法符号的类型进行相应修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID  : [a-zA-Z]+</span><br><span class="line">    &#123; if (java5 &amp;&amp; getText().equals(&quot;enum&quot;)) setType(Enum2Parser.ENUM); &#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>如果使用这种方式，需要额外定义一个ENUM类型的词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokens &#123; ENUM &#125;</span><br></pre></td></tr></table></figure>

<p>出于效率和可读性的原因，应该尽量避免语法分析器中的内嵌判定。作为替代方案，可以使用基于词法分析器的解决方案来处理这样的问题。不过，判定同样也会拖慢词法分析器，所以最好完全不使用它们。</p>
<h3 id="识别歧义性文本"><a href="#识别歧义性文本" class="headerlink" title="识别歧义性文本"></a>识别歧义性文本</h3><p>在上下文中，可以了解基于一个简单的布尔变量来关闭部分语法。这种情况下并非用不同的方式匹配相同的输入，仅仅希望关闭特定的语言结构。现在，目标是在处理具有歧义的输入文本时，强制语法分析器只留下一种解释方式，而将其余的解释方式全部关闭。使用迷宫进行类比，可以用同一条通行口令经多条路径通过一个迷宫时，就称该迷宫和通行口令是具有歧义的。</p>
<p>一般的编程语言设计者会有意识地避免歧义性结构，因为会使代码难以阅读。比如Ruby函数调用的括号是可选的，就会带来歧义。</p>
<p>一般情况下，一份语法能够以多种方式匹配输入的文本，那么，通常情况下，这份语法是有问题的。在绝大多数语言中，语法本身仅仅说明如何解释所有的有效语句。这意味着语法对于每个输入的字符流，应当仅以一种方式进行匹配。如果有多种解释方式，就应该重写该语法，除去无效的解释方式。</p>
<p>即便如此，在某些编程语言中，仍然存在一些仅靠语法本身不足以区分其含义的语句。这些语言的语法需要具有一定的歧义性，不过，歧义性语句在具体的上下文中就会具有清晰的含义，例如标识符的定义(作为类名还是函数名)。需要利用判定询问当前的上下文，以对歧义性文本作出正确的解释。如果一个判定能够成功地解决一种输入文本的语法歧义问题，就称这种输入是上下文相关的(context-sensitive)。</p>
<p>C++是最难进行准确语法分析的编程语言。首先是如何区分函数调用和构造器风格的类型转换，然后学习如何区分声明和表达式。</p>
<h4 id="正确识别C-中的T-0"><a href="#正确识别C-中的T-0" class="headerlink" title="正确识别C++中的T(0)"></a>正确识别C++中的T(0)</h4><p>在C++中，表达式T(0)既是函数调用，又是构造器风格的类型转换，它的准确含义取决于T是函数名还是类型名。因为相同的语句能够用两种方式解释，所以该表达式具有歧义性。为进行正确的解释，语法分析器需要依据T的定义关闭某个备选分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** 前两个备选分支中使用了理想化的判定作为区分这两种情况的Demo */</span><br><span class="line">expr: &#123;&lt;&lt;isfunc(ID)&gt;&gt;&#125;? ID &#x27;(&#x27; expr &#x27;)&#x27; // 一个参数的函数调用</span><br><span class="line">    | &#123;&lt;&lt;istype(ID)&gt;&gt;&#125;? ID &#x27;(&#x27; expr &#x27;)&#x27; // 构造器风格的对expr的转换</span><br><span class="line">    | INT        // 整数常量</span><br><span class="line">    | ID         // 标识符</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h4 id="正确识别C-中的T-i"><a href="#正确识别C-中的T-i" class="headerlink" title="正确识别C++中的T(i)"></a>正确识别C++中的T(i)</h4><p>考虑到上文讨论的表达式的变体<code>T(i)</code>。简单起见，假设C++仔鸡中不存在构造器风格的类型转换。此时，<code>T(i)</code>就一定是一个函数调用了。按照语法，它也是一个合法的声明。它等价于<code>T i</code>，定义了一个T类型的变量i。区分二者的唯一方法仍然是通过上下文。如果T是类型名，那么<code>T(i)</code>就是变量i的声明。否则，它就是将i作为参数的函数调用。</p>
<p>可以通过一个小型的C++语法来展示这些位于不同规则中的、有歧义的备选分支。假设C++语句中只包含声明和表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stat: decl &#x27;;&#x27; &#123;System.out.println(&quot;decl &quot;+$decl.text);&#125;</span><br><span class="line">    | expr &#x27;;&#x27; &#123;System.out.println(&quot;decl &quot;+$expr.text);&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">decl: ID ID           // 例如 Point p</span><br><span class="line">    | ID &#x27;(&#x27; ID &#x27;)&#x27;   // 例如 Point (p),和ID ID 等价</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>假设一个表达式只能是整数常量、简单标识符或者单参数的函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr: INT   // 整数常量</span><br><span class="line">    | ID    // 标识符</span><br><span class="line">    | ID &#x27;(&#x27; expr &#x27;)&#x27;  // 函数调用</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>语法分析器首先告诉我们，它在试图使用简单的<code>SLL(*)</code>策略对输入进行语法分析时发现了一个问题。由于该策略失败了，语法分析器就换用了更加强大的<code>ALL(*)</code>机制。使用了全语法分析算法(full grammar analysis algorithm)后，语法分析器再次发现了问题。</p>
<p>输入文本同时匹配了decl的第2个备选分支和expr的第3个备选分支。语法分析器必须在stat规则中做出选择。给定两个可用的备选分支，语法分析器解决歧义问题的策略是选择靠前的那一个(decl)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">decl: ID ID</span><br><span class="line">    | &#123;istype()&#125;? ID &#x27;(&#x27; ID &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr: INT</span><br><span class="line">    | ID</span><br><span class="line">    | &#123;!istype()&#125;? ID &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">@parser::members &#123;</span><br><span class="line">    Set&lt;String&gt; types = new HashSet&lt;String&gt;() &#123; &#123;add(&quot;T&quot;);&#125; &#125;;</span><br><span class="line">    boolean istype() &#123; return types.contains(getCurrentToken().getText()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，还存在一些判定无法解决的歧义问题。</p>
<h4 id="正确识别C-中的T-i-1"><a href="#正确识别C-中的T-i-1" class="headerlink" title="正确识别C++中的T(i)"></a>正确识别C++中的T(i)</h4><p>C++语言规范解决这种歧义问题的方案是：总是选择声明而非表达式。但是，即使加了语义判定，编写一份通常意义上的无歧义的语法也是不可能的。但是ANTLR语法分析器自动地解决了该歧义问题，所以能够正常工作。语法分析器解决歧义问题的原则是选择位置靠前的备选分支。因此，只需要确保stat中，decl备选分支放在expr备选分支之前即可。</p>
<h4 id="解决前向引用问题"><a href="#解决前向引用问题" class="headerlink" title="解决前向引用问题"></a>解决前向引用问题</h4><p>一个真实的C++语法分析器在语法分析的过程中遇到的各种名字时，必须将它们记录下来，以便计算出之前章节提到的类型表或者其他用于区分函数名和类型名的表。有时候，C++允许对符号的前向引用，例如方法和变量名。这意味着在遇到<code>T(i)</code>的时候还不知道T是不是一个函数名。</p>
<p>唯一的解决方案是对输入文本或者输入文本的内部表示如语法分析树进行多躺扫描。</p>
<p>使用ANTLR，最简单的方法是将输入文本处理成词法符号流，然后快速扫描它并记录所有的符号定义，然后再对这些词法符号进行语法分析，获得正确的语法分析树。</p>
<p>绝大多数编程语言不会遇到歧义问题，但是大部分编程语言都支持算术运算，在不指定运算符优先级的情况下就会存在歧义。</p>
<p>语义判定能够开启和关闭备选分支的简单布尔表达式，但是包含多重判定和内嵌动作的语法会变得非常复杂。</p>
<h2 id="ANTLR词法分析技巧"><a href="#ANTLR词法分析技巧" class="headerlink" title="ANTLR词法分析技巧"></a>ANTLR词法分析技巧</h2><p>词法分析器<br>词法分析器进行词法分析工作，有时也需要一些上下文信息对词法符号作出决策，但是这些上下文信息只被语法分析器持有。比如Java的<code>&gt;&gt;</code>运算符，Java词法分析器可以将它匹配成右移运算符或者两个<code>&gt;</code>符号，后者出现在范型声明的结尾处，例如<code>List&lt;List&lt;String&gt;&gt;</code>。</p>
<!-- ANTLR 权威指南中文版 看到了362页 -->
<h3 id="将词法分析器送入不同通道"><a href="#将词法分析器送入不同通道" class="headerlink" title="将词法分析器送入不同通道"></a>将词法分析器送入不同通道</h3><p>绝大多数编程语言忽略词法符号间的空格和注释，这意味着它们可以出现在任何地方。这就给语法分析器带来了一个难题，必须时刻考虑两种可选的词法符号的存在：空白字符和注释。常见的解决方案是，令词法分析器匹配这些词法符号并丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WS : [ \t\n\r]+ -&gt; skip;</span><br><span class="line">SL_COMMENT</span><br><span class="line">    : &#x27;//&#x27; .*? &#x27;\n&#x27; -&gt; skip;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h4 id="填充词法符号通道"><a href="#填充词法符号通道" class="headerlink" title="填充词法符号通道"></a>填充词法符号通道</h4><p>ANTLR的解决方案是将类似标识符的正常词法符号送入语法分析器对应的通道，其余内容送入另外一个通道。通道就像不同的广播频率。词法规则负责将词法符号放入不同的通道，CommonTokenStream类负责只对语法分析器暴露其中一个通道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WS : [ \t\n\r]+ -&gt; channel(WHITESPACE); // channel(1)</span><br><span class="line">SL_COMMENT</span><br><span class="line">    : &#x27;//&#x27; .*? &#x27;\n&#x27; -&gt; channel(COMMENTS); // channel(2)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">@lexer::members &#123;</span><br><span class="line">    public static final int WHITESPACE = 1;</span><br><span class="line">    public static final int COMMENTS = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问隐藏通道"><a href="#访问隐藏通道" class="headerlink" title="访问隐藏通道"></a>访问隐藏通道</h4><p>基本策略是使用TokenStreamRewriter重写词法符号流，提取<code>//...</code>注释，改写为<code>/*...*/</code>注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CommentShifter</span> <span class="keyword">extends</span> <span class="title class_">CymbolBaseListener</span> &#123;</span><br><span class="line">    BufferedTokenStream tokens;</span><br><span class="line">    TokenStreamRewriter rewriter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创建一个绑定到词法符号流上的TokenStreamRewriter</span></span><br><span class="line"><span class="comment">      * 位于词法分析器和语法分析器之间 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommentShifter</span><span class="params">(BufferedTokenStream tokens)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tokens = tokens;</span><br><span class="line">        rewriter = <span class="keyword">new</span> <span class="title class_">TokenStreamRewriter</span>(tokens);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitVarDecl</span><span class="params">(CymbolParser.VarDeclContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">semi</span> <span class="operator">=</span> ctx.getStop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> semi.getTokenIndex();</span><br><span class="line">        List&lt;Token&gt; cmtChannel = </span><br><span class="line">            tokens.getHiddenTokensToRight(i, CymbolLexer.COMMENTS);</span><br><span class="line">        <span class="keyword">if</span> (cmtChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Token</span> <span class="variable">smt</span> <span class="operator">=</span> cmtChannel.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">ctx</span> <span class="operator">=</span> cmt.getText().substring(<span class="number">2</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newCmt</span> <span class="operator">=</span> <span class="string">&quot;/* &quot;</span> + txt.trim() + <span class="string">&quot; */\n&quot;</span>;</span><br><span class="line">                rewriter.insertBefore(ctx.start, newCmt);</span><br><span class="line">                rewriter.replace(cmt, <span class="string">&quot;\n&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的事情都发生在<code>exitVarDecl()</code>中。首先，取得声明语句中的分号的词法符号索引值。因为会寻找它后面的注释。然后询问词法符号流，在分号的右侧的COMMENT通道中是否存在隐藏的词法符号。简单起见，这份代码假定每个声明之后仅存在一条注释。接下来，将旧的注释改写成新风格注释，然后使用TokenStreamRewriter将它插入到变量声明之前。最后，将原先的注释用换行符代替，相当于将它移除。</p>
<h3 id="上下文相关的词法问题"><a href="#上下文相关的词法问题" class="headerlink" title="上下文相关的词法问题"></a>上下文相关的词法问题</h3><p>词法分析器能够得到的上下文信息不如语法分析器多。解决问题的方案包括从语法分析器向词法分析器发送反馈，这样词法分析器就可以向语法分析器输入更加精确的词法符号。由于判定数量的减少，语法分析器可以变得更加简单。然而，这种方案在ANTLR语法中是行不通的，因为ANTLR自动生成的语法分析器经常在词法符号流中进行非常远的前瞻以作出语法分析决策。这意味着，远在语法分析器能够执行提供上下文信息的行为之前，词法分析器就需要将字符流处理为词法符号。</p>
<p>一些上下文相关的词法问题：</p>
<ul>
<li>相同的字符序列在语法分析器中具有不同含义，比如关键字也可以作为标识符</li>
<li>相同的字符序列可以是一个或者多个词法符号。比如Java中的<code>&gt;&gt;</code>既可以是右移运算符，也可以是两个泛型的结束符。</li>
<li>相同的字符恶劣在某些情况下需要被忽略，某些情况下需要被语法分析器识别。比如Python的物理换行符和逻辑换行符。</li>
</ul>
<h4 id="关键字作为标识符"><a href="#关键字作为标识符" class="headerlink" title="关键字作为标识符"></a>关键字作为标识符</h4><p>比如C#可以通过LINQ功能提供对SQL的支持。SQL查询语句以关键字from开始，但是也可以把from当作变量使用：<code>x=from+where;</code>。这是一个没有歧义的表达式，而非查询，因此词法分析器不应该将from当作标识符。问题在于，词法分析器并不会对输入文本进行语法分析，也就无从得知需要将哪种词法符号送给语法分析器。</p>
<p>可以通过两种方式允许关键字在某些上下文中作为标识符。第一种是令词法分析器将所有的关键字当作关键字类型的词法符号送给语法分析器，然后编写一条文法规则id，该规则匹配ID和任意的关键字。第二中是令词法符号将所有的关键字当作标识符，然后在语法分析器中编写如下判定来对标识符的名字进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyIF : &#123;_input.LT(1).getText().equals(&quot;if&quot;)&#125;? ID ;</span><br></pre></td></tr></table></figure>

<h4 id="避免最长匹配带来的歧义性"><a href="#避免最长匹配带来的歧义性" class="headerlink" title="避免最长匹配带来的歧义性"></a>避免最长匹配带来的歧义性</h4><p>通常，词法分析器生成器会作出这样的假设：在每个位置上，词法分析器应当尽可能地匹配最长的词法符号。基于该假设的词法分析器的表现最为自然。例如，对于C语言中的<code>+=</code>，词法分析器应当匹配出单一的词法符号<code>+=</code>，而非两个词法符号<code>+</code>和<code>=</code>。</p>
<p>比如对于问题<code>&gt;&gt;</code>既可以是右移运算符，也可以是两个泛型的结束符，有多种解决该访问的方案，最简单的一种是：令词法分析器从不将<code>&gt;&gt;</code>序列匹配为右移运算符，而将两个<code>&gt;</code>符号送给语法分析器，后者可以利用上下文信息对其进行适当组装。例如：C++语法分析器中识别表达式的规则可以匹配两个右尖括号，而非单一的右移运算符。下面是expr规则中的两个备选分支，它们将单字符的词法符号组装成多字符的运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| expression (&#x27;&lt;&#x27; &#x27;&lt;&#x27; | &#x27;&gt;&#x27; &#x27;&gt;&#x27; &#x27;&gt;&#x27; | &#x27;&gt;&#x27; &#x27;&gt;&#x27;) expression</span><br><span class="line">| expression (&#x27;&lt;&#x27; &#x27;=&#x27; | &#x27;&gt;&#x27; &#x27;=&#x27; | &#x27;&gt;&#x27; | &#x27;&lt;&#x27;) expression</span><br></pre></td></tr></table></figure>

<p>将右移运算符作为两个单独的右尖括号处理的唯一问题在于：语法分析器同样会接受中间包含空格的尖括号<code>&gt;&gt;</code>。想要解决这个问题，可以在语法中加入语义判定，或者使用监听器/访问器检查生成的语法分析树，确保多个&gt;词法符号的序列号是相邻的。在语法分析的过程中使用判定的效率不高，所以最好在语法分析结束后检查右移运算符的正确性。毕竟，大多数语言类应用程序都需要对语法分析树进行遍历（在表达式中使用判定也会破坏ANTLR将左递归规则转换为非左递归规则的机制）</p>
<h4 id="Python换行符"><a href="#Python换行符" class="headerlink" title="Python换行符"></a>Python换行符</h4><p>在Python中，语句的终止标志是换行符而非分号。与此同时，不希望一行语句过长，所以在Python在特定的上下文中会忽略换行符。例如，Python允许将一个函数调用分为多行。</p>
<p>圆括号、方括号或者花括号中的表达式可以分散在多个物理行中。比如在表达式<code>1+2</code>中的<code>+</code>插入一个换行符就会报错，不过<code>(1+2)</code>可以跨行。隐式的续行可以带有注释，以及允许空白的续行。如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>,  <span class="comment"># 第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>,    <span class="comment"># 第二个参数</span></span><br><span class="line">      <span class="comment"># 带有注释的空行</span></span><br><span class="line"><span class="number">3</span>)    <span class="comment"># 第三个参数</span></span><br></pre></td></tr></table></figure>

<p>两个或者多个物理行可以使用反斜杠字符<code>(\)</code>连接成一个逻辑行，方式如下：当一个物理行以一个不在字符串中或注释中的反斜杠结束时，它会和接下来的一行连接形成一个单独的逻辑行，反斜杠和后面的换行符会被删除掉。</p>
<p>上述描述带来的结果是：语法分析器和词法分析器均需要有选择地保留和丢弃部分换行符。在之前对词法符号通道的学习中，令语法分析器始终检查可选的空白字符不是一个好办法。这意味着，处理可选的换行符成为Python词法分析器的职责。就变成了另一个语法上下文决定词法分析器行为的问题。</p>
<p>编写一份识别简单的Python代码的语法，它能够匹配赋值语句和简单的表达式。将忽略字符串，以便专注于处理注释和换行符。下面是文法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">file: stat+ EOF;</span><br><span class="line">stat: assign NEWLINE</span><br><span class="line">    | expr NEWLINE </span><br><span class="line">    | NEWLINE         // 忽略空行 </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assign: ID &#x27;=&#x27; expr;</span><br><span class="line"></span><br><span class="line">expr: expr &#x27;+&#x27; expr</span><br><span class="line">    | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    | call</span><br><span class="line">    | list</span><br><span class="line">    | ID</span><br><span class="line">    | INT</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">call: ID &#x27;(&#x27; (expr (&#x27;,&#x27; expr)* )? &#x27;)&#x27;;</span><br><span class="line"></span><br><span class="line">list: &#x27;[&#x27; expr (&#x27;,&#x27; expr)* &#x27;]&#x27;;</span><br><span class="line"></span><br><span class="line">ID : [a-zA-Z_] [a-zA-Z_0-9]*;</span><br><span class="line"></span><br><span class="line">NEWLINE</span><br><span class="line">    : &#x27;\r&#x27;? &#x27;\n&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/** 注意：这里没有考虑Python的缩进规则 */</span><br><span class="line">WS  : [ \t]+ -&gt; skip;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/** 匹配注释。这里不匹配换行符，因为需要将它送入语法分析器 */</span><br><span class="line">COMMENT</span><br><span class="line">    : &#x27;#&#x27; ~[\r\n]* -&gt; skip;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/**  */</span><br><span class="line">LINE_ESCAPE</span><br><span class="line">    : &#x27;\\&#x27; &#x27;\r&#x27;? &#x27;\n&#x27; -&gt; skip;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/** 嵌套(..) 或者 [..] 中换行符将被忽略 */</span><br><span class="line">IGNORE_NEWLINE</span><br><span class="line">    : &#x27;\r&#x27;? &#x27;\n&#x27; &#123;nesting&gt;0&#125;? -&gt; skip;</span><br><span class="line">    ; </span><br></pre></td></tr></table></figure>

<p>此规则必须放置在NEWLINE之前，这样，当判定为真时，词法分析器就会按照解决歧义性的默认方法，选择IGNORE_NEWLINE规则。也可以将<code>&#123;nesting==0&#125;?</code>判定放在NEWLINE中来达到同样的效果。</p>
<p>在发现方括号和圆括号时，需要适当地调整此变量的值。首先，需要定义该nesting变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@lexer::members &#123;</span><br><span class="line">    int nesting = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPAREN : &#x27;(&#x27; &#123;nesting++;&#125;;</span><br><span class="line">RPAREN : &#x27;)&#x27; &#123;nesting--;&#125;;</span><br><span class="line">LBRACK : &#x27;[&#x27; &#123;nesting++;&#125;;</span><br><span class="line">RBRACK : &#x27;]&#x27; &#123;nesting--;&#125;;</span><br></pre></td></tr></table></figure>

<p>严格而言，需要为方括号和圆括号各设置一个变量，以确保括号的精确匹配。不过，实际上无须担心类似<code>[1,2)</code>这样的不匹配括号，因为语法分析器会检测到该错误。在这样的语法错误中，对换行符的处理偏差是无关紧要的。</p>
<h3 id="字符流中孤岛"><a href="#字符流中孤岛" class="headerlink" title="字符流中孤岛"></a>字符流中孤岛</h3><p>除了类似于CSV，Java，Python和Java文件都只包含这些语言的文本。不过还存在一些格式的文件，其中结构化区域—或者称为孤岛—-被随机的文本所包围。称这样的格式为孤岛语言，并使用孤岛语法来描述它们，比如Letax，markdown，xml等。在XML文件中，结构化的标签和<code>&amp;</code>实体被大片不关心的文本所包围。由于各XML标签内部是结构化的，也可以称XML为群岛语言。</p>
<p>如果编写一个C预处理器，那么预处理器命令就构成了孤岛语言，而C代码就是周围的海洋。如果在为IDE编写C语言的语法分析器，那么它就必须忽略预处理命令构成的“海洋”。</p>
<p>为将XML的标签和普通文本区分开，首先想到的方案是编写一个处理输入字符流的过滤器，丢弃标签之间的全部内容。这样也许能够零词法分析器更加容易识别处孤岛部分，但过滤器会丢弃所有的普通文本内容。例如，对于输入<code>&lt;name&gt;John&lt;/name&gt;</code>，并不希望丢弃John。</p>
<p>真正的解决方案是，首先编写一份子XML语法，它将标签内的文本识别为一种词法符号，标签外的文本识别为另一种词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grammar Tags;</span><br><span class="line">file : (TAG|ENTITY|TEXT|CDATA)* ;</span><br></pre></td></tr></table></figure>

<p>file规则并不验证XML的格式是否正确—-它只识别XML中的各种词法符号。</p>
<p>为正确地分割XML文件，为孤岛部分指定了词法规则，而在最后放置了一条名为TEXT的规则来兜底，它匹配其余的任何内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMENT : &#x27;&lt;!--&#x27; .*? &#x27;--&gt;&#x27; -&gt; skip;</span><br><span class="line">CDATA : &#x27;&lt;![CDATA[&#x27; .*? &#x27;]]&gt;&#x27; ;</span><br><span class="line">TAG : &#x27;&lt;&#x27; .*? &#x27;&gt;&#x27; // 必须放置在其他类似标签的结构之后</span><br><span class="line">ENTITY : &#x27;&amp;&#x27; .*? &#x27;;&#x27; ;</span><br><span class="line">TEXT : ~[&lt;&amp;]+;     // 除&lt;和&amp;之外的任意字符序列</span><br></pre></td></tr></table></figure>

<p>上述规则大量使用了<code>.*?</code>非贪婪匹配，它会一直向后扫描，直至遇到匹配后续规则的内容为止。</p>
<p>TEXT规则匹配一个或多个字符，只要它们不是标签或者实体的起始字符即可。不能用<code>.+</code>代替<code>~[&lt;&amp;]+</code>,那样的话，一旦进入了循环，它就会吞掉所有的输入字符。因为TEXT中<code>.+</code>后面没有任何内容，所以该循环就无法停止。</p>
<p>XML不允许以<code>---&gt;</code> 结尾的注释和包含<code>--</code>的注释。可以为这些非法的注释编写词法规则，输出指定的错误消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BAD_COMMENT1 : &#x27;&lt;!--&#x27; .*? &#x27;---&gt;&#x27;</span><br><span class="line">               &#123;System.out.println(&quot;Can&#x27;t have ---&gt; end comment&quot;);&#125; -&gt; skip;</span><br><span class="line">BAD_COMMENT2 : &#x27;&lt;!--&#x27; (&#x27;--&#x27;|.)*? &#x27;---&gt;&#x27;</span><br><span class="line">               &#123;System.out.println(&quot;Can&#x27;t have -- end comment&quot;);&#125; -&gt; skip;        </span><br></pre></td></tr></table></figure>

<h4 id="使用词法模式处理上下文相关的词法符号"><a href="#使用词法模式处理上下文相关的词法符号" class="headerlink" title="使用词法模式处理上下文相关的词法符号"></a>使用词法模式处理上下文相关的词法符号</h4><p>标签内外的文本实际上是不同的语言。例如，<code>id=&quot;45&quot;</code>在标签外仅仅是普通文本，但是在标签内部是三个词法符号。在某种意义上，希望XML词法分析器根据上下文使用不同的规则进行匹配。ANTLR提供了词法模式(lexical mode)，允许词法分析器在不同的上下文中切换(模式)。</p>
<p>词法模式允许将单个词法分析器分成多个子词法分析器。词法分析器会返回被当前模式下的规则匹配的词法符号。一门语言能够进行模式切换的一个重要要求是包含清晰的词法“哨兵”，它能够触发模式的来回切换，例如尖括号。换言之，模式的切换只依赖于词法分析器可以从输入文本中获得的信息，而不依赖于语义上下文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar MOdeTagsLexer;</span><br><span class="line"></span><br><span class="line">// 默认情况下的规则</span><br><span class="line">OPEN : &#x27;&lt;&#x27;  -&gt; mode(ISLAND);  // 切换到ISLAND模式</span><br><span class="line">TEXT :  ~&#x27;&lt;&#x27;+;                // 收集所有的文本</span><br><span class="line"></span><br><span class="line">mode ISLAND;</span><br><span class="line">CLOSE: &#x27;&gt;&#x27;   -&gt; mode(DEFAULT_MODE); // 回到SEA模式</span><br><span class="line">SLASH: &#x27;/&#x27;;</span><br><span class="line">ID : [a-zA-Z]+;                      // 匹配标签中的ID并将其输送给语法分析器</span><br></pre></td></tr></table></figure>

<p><code>OPEN</code>和<code>TEXT</code>规则位于默认模式下。<code>OPEN</code>匹配单个<code>&lt;</code>，使用词法分析器指令model(ISLAND)来切换模式。之后，词法分析器就只会使用ISLAND模式下的规则进行工作。TEXT匹配任意非标签起始字符的序列。由于这些词法规则中不包含<code>skip</code>指令，因此所有的文本都会被匹配为词法符号送给语法分析器。</p>
<p>在ISLAND模式中，词法分析器匹配<code>&gt;</code>,<code>/</code>和ID词法符号。当词法分析器发现<code>&gt;</code>时，它会执行切换回模式模式的指令，该模式由Lexer类中的常量DEFAULT_MODE标识。这就是词法分析器来回切换模式的方法。</p>
<p>和Tags语法一样，这份稍大的XML语法子集对应的语法分析器能哦股匹配标签和文本块，改进之处在于，现在使用了tag规则来匹配独立的标签元素而非一个单独的标签词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parser grammar ModeTagsParser;</span><br><span class="line"></span><br><span class="line">options &#123;tokenVocab=ModeTagsLexer; &#125; // 使用ModeTagsLexer.g4中的词法符号</span><br><span class="line"></span><br><span class="line">file: (tag|TEXT)*;</span><br><span class="line"></span><br><span class="line">tag : &#x27;&lt;&#x27; ID &#x27;&gt;&#x27;</span><br><span class="line">    | &#x27;&lt;&#x27; &#x27;/&#x27; ID &#x27;&gt;&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>当语法分析器和词法分析器位于不同文件中时，需要确保两个文件中的词法符号类型和词法符号名称一致。例如，词法分析器中的词法符号OPEN必须和语法分析器中的同名词法符号具有相同的词法符号类型。</p>
<p>为了将语法应用于实际程序，既可以使用通常的监听器或者访问器机制，也可以为语法增加动作。</p>
<h3 id="对XML进行语法分析和词法分析"><a href="#对XML进行语法分析和词法分析" class="headerlink" title="对XML进行语法分析和词法分析"></a>对XML进行语法分析和词法分析</h3><p>XML是一门已经被严格定义的语言，标准定义由W3C制定，该XML规范巨大无比。为简单起见，忽略掉在处理XML文件中不需要的东西<code>&lt;!DOCTYPE..&gt;</code>文档类型定义(DTD),<code>&lt;!ENTITY&gt;</code>实体声明，以及<code>&lt;!NOTATION..&gt;</code>符号声明。</p>
<h4 id="XML规范转换为ANTLR文法语法"><a href="#XML规范转换为ANTLR文法语法" class="headerlink" title="XML规范转换为ANTLR文法语法"></a>XML规范转换为ANTLR文法语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">document     ::= prolog element Misc*</span><br><span class="line">prolog       ::= XMLDecl? Misc*</span><br><span class="line">content      ::= CharData? </span><br><span class="line">             ( (element | Reference | CDSect | PI | Comment) CharData? )*</span><br><span class="line">element      ::= EmptyElemTag</span><br><span class="line">             |   STag content ETag</span><br><span class="line">EmptyElemTag ::= &#x27;&lt;&#x27; Name (S Attribute)* S? &#x27;/&gt;&#x27;</span><br><span class="line">STag         ::= &#x27;&lt;&#x27; Name (S Attribute)* S? &#x27;&gt;&#x27;</span><br><span class="line">ETag         ::= &#x27;&lt;/&#x27; Name S? &#x27;&gt;&#x27;</span><br><span class="line">XMLDecl      ::= &#x27;&lt;?xml&gt;&#x27; VersionInfo EncodingDecl? SDDecl? S? &#x27;?&gt;&#x27;</span><br><span class="line">Attribute    ::= Name Eq AttValue</span><br><span class="line">Reference    ::= EntityRef | CharRef</span><br><span class="line">Misc         ::= Comment | PI | S</span><br></pre></td></tr></table></figure>

<p>还需要许多其他的规则，不过它们都是词法规则。不关系注释或者处理指令(Processing Instructions, PI),所以可以令词法分析器将其匹配为文本快。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">parser grammar XMLParser;</span><br><span class="line">options &#123;tokenVocab=XMLLexer;&#125;</span><br><span class="line"></span><br><span class="line">document : prolog ? misc* element misc*;</span><br><span class="line"></span><br><span class="line">prolog   : XMLDeclOpen attribute* SPECIAL_CLOSE;</span><br><span class="line"></span><br><span class="line">content  : chardata?</span><br><span class="line">           ( (element | reference | CDATA | PI | COMMENT) chardata? )*</span><br><span class="line"></span><br><span class="line">element  : &#x27;&lt;&#x27; Name attribute &#x27;&gt;&#x27; content &#x27;&lt;&#x27; &#x27;/&#x27; Name &#x27;&gt;&#x27;</span><br><span class="line">         | &#x27;&lt;&#x27; Name attribute &#x27;/&gt;&#x27;</span><br><span class="line">         ;</span><br><span class="line"></span><br><span class="line">reference : EntityRef | CharRef;</span><br><span class="line"></span><br><span class="line">attribute : Name &#x27;=&#x27; STRING;</span><br><span class="line"></span><br><span class="line">chardata : TEXT | SEA_WS;</span><br><span class="line"></span><br><span class="line">misc : COMMENT | PI | SEA_WS;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prolog      : XMLDecl versionInfo encodingDecl? standalone? SPECIAL_CLOSE;</span><br><span class="line">versionInfo : &#123;_input.LT(1).getText().equals(&quot;version&quot;)&#125;? Name &#x27;=&#x27; STRING;</span><br><span class="line">encodingDecl : &#123;_input.LT(1).getText().equals(&quot;encoding&quot;)&#125;? Name &#x27;=&#x27; STRING;</span><br><span class="line">standalone : &#123;_input.LT(1).getText().equals(&quot;standalone&quot;)&#125;? Name &#x27;=&#x27; STRING;</span><br></pre></td></tr></table></figure>

<h4 id="将XML词法符号化"><a href="#将XML词法符号化" class="headerlink" title="将XML词法符号化"></a>将XML词法符号化</h4><p>通过从规范中提取所需的相关规则，就可以开始编写XML词法分析器了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Comment   ::= &#x27;&lt;!--&#x27; ( (Char - &#x27;-&#x27;) | (&#x27;-&#x27; (Char - &#x27;-&#x27;)) )*  &#x27;--&gt;&#x27;</span><br><span class="line">CDSect    ::= &#x27;&lt;![CDATA[&#x27; CData &#x27;]]&gt;&#x27;</span><br><span class="line">CData     ::= ( Char* - (Char* &#x27;]]&gt;&#x27; Char* ) ) // anything but &#x27;]]&gt;&#x27;</span><br><span class="line">PI        ::= &#x27;&lt;?&#x27; PITarget (S (Char* - (Char* &#x27;?&gt;&#x27; Char* ) ))? &#x27;?&gt;&#x27;</span><br><span class="line">/** 除&#x27;xml&#x27;之外的任何名字 */</span><br><span class="line">PITarget  ::= Name - ( (&#x27;X&#x27;|&#x27;x&#x27;) (&#x27;M&#x27;|&#x27;m&#x27;) (&#x27;l&#x27;|&#x27;L&#x27;) )</span><br><span class="line">/**</span><br><span class="line"> * 规范指出：CharData是不包含任何标记的开始符和CDATA区域结束符&#x27;]]&gt;&#x27;的* 任意字符串</span><br><span class="line"> */</span><br><span class="line">CharData  ::= [^&lt;&amp;]* - ( [^&lt;&amp;]* &#x27;]]&gt;&#x27; [^&lt;&amp;]*  )</span><br><span class="line">EntityRef ::= &#x27;&amp;&#x27; Name &#x27;;&#x27;</span><br><span class="line">CharRef   ::= &#x27;&amp;#&#x27; [0-9]+ &#x27;;&#x27;</span><br><span class="line">          |   &#x27;&amp;#x&#x27; [0-9a-fA-F]+ &#x27;;&#x27;</span><br><span class="line">Name      ::= NameStartChar (NameChar)*</span><br><span class="line">NameChar  ::= NameStartChar | &quot;-&quot; | &quot;.&quot; | [0-9] | #xB7</span><br><span class="line">          |   [#x0300-#x036F] | [#x203F-#x2040]</span><br><span class="line">NameStartChar</span><br><span class="line">          ::= &quot;:&quot; | [A-Z] | &quot; &quot; | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] </span><br><span class="line">          |   [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF]</span><br><span class="line">          |   [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] </span><br><span class="line">          |   [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</span><br><span class="line">AttValue  ::= &#x27;&quot;&#x27; ( [^&lt;&amp;&quot;] | Reference )* &#x27;&quot;&#x27;</span><br><span class="line">          |   &#x27;&quot;&#x27; ( [^&lt;&amp;&#x27;] | Reference )* &#x27;&quot;&#x27;</span><br><span class="line">S         ::= (#x20 | #x9 | #xD | #xA )+</span><br></pre></td></tr></table></figure>

<p>上述文法可以分解为三个不同的模式：标签外，标签内，以及特殊的<code>&lt;?...?&gt;</code>标签内，并逐个编写。匹配并丢弃<code>&lt;!...&gt;</code> 形式的文档、实体和标记声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line">// 默认模式：标签外</span><br><span class="line">COMMENT   :  &#x27;&lt;!--&#x27; .*? &#x27;--&gt;&#x27;;</span><br><span class="line">CDATA     :  &#x27;&lt;!CDATA[&#x27; .*? &#x27;]]&gt;&#x27;;</span><br><span class="line">DTD       :  &#x27;&lt;!&#x27; .*? &#x27;&gt;&#x27;  -&gt; skip;</span><br><span class="line">EntityRef :  &#x27;&amp;&#x27; Name &#x27;;&#x27; ;</span><br><span class="line">CharRef   :  &#x27;&amp;#&#x27; DIGIT+ &#x27;;&#x27;</span><br><span class="line">          |  &#x27;&amp;#x&#x27; HEXDIGIT+ &#x27;;&#x27;</span><br><span class="line">          ;</span><br><span class="line">SEA_WS    :  (&#x27; &#x27; | &#x27;\t&#x27; | &#x27;\r&#x27; ? &#x27;\n&#x27; );</span><br><span class="line"></span><br><span class="line">OPEN      :  &#x27;&lt;&#x27;    -&gt; pushMode(INSIDE);</span><br><span class="line">XMLDeclOpen : &#x27;&lt;?xml&#x27; S    -&gt; pushMode(INSIDE);</span><br><span class="line">SPECIAL_OPEN  &#x27;&lt;?&#x27;  Name  -&gt; more, pushMode(PROC_INSTR);</span><br><span class="line"></span><br><span class="line">TEXT :   ~[&lt;&amp;]+</span><br><span class="line"></span><br><span class="line">mode PROC_INSTR;</span><br><span class="line">PI  :  &#x27;?&gt;&#x27;   -&gt; popMode;</span><br><span class="line">IGNORE :  .  -&gt; more;</span><br><span class="line"></span><br><span class="line">mode INSIDE;</span><br><span class="line"></span><br><span class="line">CLOSE :  &#x27;&gt;&#x27;   -&gt; popMode;</span><br><span class="line">SPECIAL_CLOSE :  &#x27;?&gt;&#x27;   -&gt; popMode;</span><br><span class="line">SLASH :   &#x27;/&#x27; ;</span><br><span class="line">EQUALS  :  &#x27;=&#x27;;</span><br><span class="line">STRING  :  &#x27;&quot;&#x27;  ~[&lt;&quot;]* &#x27;&quot;&#x27;</span><br><span class="line">        |  &#x27;\&#x27;&#x27; ~[&lt;&#x27;]* &#x27;\&#x27;&#x27;</span><br><span class="line">        ;</span><br><span class="line">Name    : NameStartChar NameChar*;</span><br><span class="line">S       : [ \t\r\n]    -&gt; skip; </span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HEXDIGIT : [a-fA-F0-9];</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT  :  [0-9]</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">NameChar  : NameStartChar</span><br><span class="line">          | &#x27;-&#x27; | &#x27;.&#x27; | DIGIT</span><br><span class="line">          | &#x27;\u00B7&#x27;</span><br><span class="line">          | &#x27;\u0300&#x27; .. &#x27;\u036F&#x27;</span><br><span class="line">          | &#x27;\u203F&#x27; .. &#x27;\u2040&#x27;</span><br><span class="line">          ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">NameStartChar </span><br><span class="line">          : [:a-zA-Z]</span><br><span class="line">          | &#x27;\u2070&#x27; .. &#x27;\u218F&#x27;</span><br><span class="line">          | &#x27;\u2C00&#x27; .. &#x27;\u2FEF&#x27;</span><br><span class="line">          | &#x27;\u3001&#x27; .. &#x27;\uD7FF&#x27;</span><br><span class="line">          | &#x27;\uF900&#x27; .. &#x27;\uFDCF&#x27;    </span><br><span class="line">          | &#x27;\uFDF0&#x27; .. &#x27;\uFFFD&#x27;</span><br><span class="line">          ;  </span><br></pre></td></tr></table></figure>

<h2 id="ANTLR运行时API"><a href="#ANTLR运行时API" class="headerlink" title="ANTLR运行时API"></a>ANTLR运行时API</h2><h3 id="包结构概览"><a href="#包结构概览" class="headerlink" title="包结构概览"></a>包结构概览</h3><p>ANTLR运行时由六个包组成，主要的包<code>org.antlr.v4.runtime</code>中的大多数类是面向应用程序的。最长用到的是那些用于启动语法分析器分析输入文本的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XLexer</span>(input);</span><br><span class="line"><span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line"><span class="type">XParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XParser</span>(tokens);</span><br><span class="line"><span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.XstartRule();</span><br><span class="line"><span class="type">ParseTreeWalker</span> <span class="variable">walker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line"><span class="type">MyListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyListener</span>(parser);</span><br><span class="line">walker.walk(listener, tree);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>org.antlr.v4.runtime</strong>-该包包含了最常用的类和接口，例如与输入流、字符和词法符号缓冲区、错误处理、词法符号构建、词法分析和语法分析相关的类体系结构</li>
<li><strong>org.antlr.v4.atn</strong>-该包在ANTLR内部用于自适应<code>LL(*)</code>词法分析和语法分析策略。包名中的atn是<strong>增强转移网络argument transition network</strong>的缩写，它是一种能够表示语法的状态机，其中网络的边代表语法元素。在词法分析和语法分析的过程中，ANTLR沿ATN移动，并基于前瞻符号作出预测。</li>
<li><strong>org.antlr.v4.runtime.dfa</strong>-使用ATN进行决策的代价很高，因此ANTLR在运行过程中将预测解结果缓存在确定<strong>有限状态自动机Deterministic Finite Automata，DFA</strong>中。该包包含了所有的DFA实现类。</li>
<li><strong>org.antlr.v4.runtime.misc</strong>-该包包含各种个样的数据结构，以及最常用的<code>TestRig</code>类，已经通过grun命令使用过它。</li>
<li><strong>org.antlr.v4.runtime.tree</strong>-默认情况下，ANTLR自动生成的语法分析器会建立语法分析树，该包包含实现此功能所需的全部类和接口。这些类和接口中还包括基本的语法分析树监听器、遍历器以及访问器机制。</li>
<li><strong>org.antlr.v4.runtime.tree.gui</strong>-ANTLR自带一个基本的语法分析树查看器，可通过<code>inspect()</code>方法访问。也可以通过<code>save()</code>方法将语法分析树保存为PostScript格式。</li>
</ul>
<h3 id="识别器"><a href="#识别器" class="headerlink" title="识别器"></a>识别器</h3><p>ANTLR自动生成的词法分析器和语法分析器是Lexer和Parser的子类。Recognizer基类抽象了识别字符序列或词法符号序列中语言结构的概念。识别器Recognizer的数据来源是IntStream。</p>
<p>Lexer实现了接口TokenSource，后者包含两个核心的词法分析器方法:nextToken(),getLine()和getCharPositionInLine()。按照一份ANTLR语法实现一个词法分析器并不困难。</p>
<p>手工编写的词法分析器的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Token <span class="title function_">nextToken</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == (<span class="type">char</span>)CharStream.EOF) </span><br><span class="line">            <span class="keyword">return</span> createToken(Token.EOF);</span><br><span class="line">        <span class="keyword">while</span> (Character.isWhiteSpace(c))</span><br><span class="line">            consume();</span><br><span class="line">        startCharIndex = input.index();</span><br><span class="line">        startLine = getLine();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;;&#x27;</span>) &#123;</span><br><span class="line">            consume();</span><br><span class="line">            <span class="keyword">return</span> createToken(SEMI);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                consume();</span><br><span class="line">            <span class="keyword">return</span> createToken(INT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                consume();</span><br><span class="line">            <span class="keyword">return</span> createToken(ID);</span><br><span class="line">        &#125;</span><br><span class="line">        consume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Token <span class="title function_">createToken</span><span class="params">(<span class="type">int</span> ttype)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Pair&lt;TokenSource, CharStream&gt; source = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="built_in">this</span>, input);</span><br><span class="line">    <span class="keyword">return</span> factory.create(source, ttype. text. Token.DEFAULT_CHANNEL, starCharIndex, input.index() - <span class="number">1</span>, startLine, startCharPositionInLine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        line += <span class="number">1</span>;</span><br><span class="line">        charPositionInLine = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c != (<span class="type">char</span>)CharStream.EOF) </span><br><span class="line">        input.consume();</span><br><span class="line">    c = (<span class="type">char</span>)input.LA(<span class="number">1</span>);</span><br><span class="line">    charPositionInLine += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入字符流和词法符号流"><a href="#输入字符流和词法符号流" class="headerlink" title="输入字符流和词法符号流"></a>输入字符流和词法符号流</h3><p>在最高层次的抽象中，词法分析器和语法分析器的主要工作都是分析整数输入流。词法分析器处理字符(短整数型)，语法分析器处理词法符号类型(整数型)。</p>
<p>类和接口继承关系如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                         -&gt; BufferedTokenStream    -&gt; CommonTokenStream </span><br><span class="line">IntStream -&gt; TokenStream -&gt; UnbufferedTokenStream</span><br><span class="line">          -&gt; CharStream  -&gt; ANTLRInputStream     -&gt; ANTLRFileStream</span><br><span class="line">                         -&gt; UnbufferedCharStream       </span><br></pre></td></tr></table></figure>

<p>IntStream接口定义了流的大部分操作，包括消费符号以及获取前瞻符号的方法，即consume()和LA()。由于ANTLR识别器需要向前扫描并倒回原先的位置，IntStream还定义了mark()和seek()方法。</p>
<p>CharStream和TokenStream子接口增加了从流中提取文本的方法。实现它们的类通常会一次读取全部输入并将它们缓存起来。这种方案使得类的编写和访问输入更为容易，同时也更符合常见情况。如果输入过于庞大无法缓存，可以使用UnbufferedTokenStream和UnbufferedCharStream</p>
<h3 id="词法符号和词法符号工厂"><a href="#词法符号和词法符号工厂" class="headerlink" title="词法符号和词法符号工厂"></a>词法符号和词法符号工厂</h3><p>词法分析器和字符流分解成若干词法符号对象，语法分析器则尝试将语法结构应用于生成的词法符号流之上。通常，认为词法符号被创建之后就不再改变，然而有些时候，需要在创建词法符号之后修改它们的某些字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Token -&gt; WritableToken -&gt; CommonToken</span><br></pre></td></tr></table></figure>

<p>若要实现自己的词法符号，继承CommonToken类即可。为了让词法分析器生成这样的特殊词法符号，需要新建一个工厂对象，将其传给词法分析器，并通知语法分析器，使得它的错误处理器能够在必要时候生成正确类型的词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenFactory -&gt; CommonTokenFactory</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTokenFactory</span> <span class="keyword">implements</span> <span class="title class_">TokenFactory</span>&lt;MyToken&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ANTLRInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ANTLRInputStream</span>(args[<span class="number">0</span>]);</span><br><span class="line"><span class="type">MyTokenFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTokenFactory</span>(input);</span><br><span class="line">lexer.setTokenFactory(factory);</span><br><span class="line">parser.setTokenFactory(factory);</span><br></pre></td></tr></table></figure>

<h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>Tree接口定义了一棵包含数据和子节点的树。SyntaxTree是一种如何将TokenStream中的词法符号组装成树节点的树。</p>
<p>ParseTree代表语法分析树中的一个节点。能够返回自己的所有后代中叶子节点包含的文本。RuleNode和TerminalNode对应着子树的根节点和叶子节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tree -&gt; SyntaxTree -&gt; ParseTree -&gt; RuleNode    -&gt; RuleContext -&gt; ParserRuleContext</span><br><span class="line">                                -&gt; TerminalNode -&gt; ErrorNode</span><br><span class="line">                                                -&gt; TerminalNodeImpl -&gt; ErrorNodeImpl</span><br></pre></td></tr></table></figure>

<p>RuleContext对象记录了一条规则的调用过程，通过getParent()链，可以获得调用的上下文。ParserRuleContext包含一个字段，用于在语法分析器建立新子树时追踪其子节点。它们是树节点的主要实现类，ANTLR基于它们，为语法中的每条规则生成一个特殊的子类。</p>
<h3 id="错误监听器和监听策略"><a href="#错误监听器和监听策略" class="headerlink" title="错误监听器和监听策略"></a>错误监听器和监听策略</h3><p>与ANTLR的语法错误处理机制相关的关键接口有两个:ANTLRErrorListener和ANTLRErrorStrategy。监听器郁怒修改错误消息和输出的位置。可以通过实现不同的策略，来改变语法分析器对应错误的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ANTLRErrorListener -&gt; BaseErrorListener -&gt; ConsoleErrorListener</span><br><span class="line">                                        -&gt; DiagnosticErrorListener</span><br><span class="line">                   -&gt; ProxyErrorListener</span><br><span class="line"></span><br><span class="line">ANTLRErrorStrategy -&gt; DefaultErrorStrategy -&gt; BailErrorStrategy</span><br></pre></td></tr></table></figure>

<p>ANTLR根据错误的具体类型，抛出特定的RecognitionException。需要注意的是，它们不受检的运行时异常(unchecked runtime exception)，所以无须在方法上大量的throws语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException -&gt; RecognitionException -&gt; FailedPredicateException</span><br><span class="line">                                                   -&gt; InputMismatchException</span><br><span class="line">                                                   -&gt; LexerNoviableAltException</span><br><span class="line">                                                   -&gt; NoViableAltException</span><br></pre></td></tr></table></figure>

<h3 id="提高语法分析器的速度"><a href="#提高语法分析器的速度" class="headerlink" title="提高语法分析器的速度"></a>提高语法分析器的速度</h3><p>ANTLR 4的自适应语法分析策略功能比ANTLR 3更加强大，不过是以少量的性能损失为代价的。如果想要块的速度和少的内存占用，可以使用两步语法策略：</p>
<ul>
<li>第一步使用功能稍弱的语法分析策略—-<code>SLL(*)</code></li>
<li>如果第一步失败，那么必须使用全功能的<code>LL(*)</code>语法分析</li>
</ul>
<p>如果第二步失败，那就意味着一个真正的语法错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">parser.getInterpreter.setSLL(<span class="literal">true</span>);</span><br><span class="line">parser.removeErrorListeners();</span><br><span class="line">parser.setErrorHandler(<span class="keyword">new</span> <span class="title class_">BailErrorStrategy</span>());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parser.startRule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex.getClass() == RuntimeException.class &amp;&amp; ex.getCause() <span class="keyword">instanceof</span> RecognitionException) &#123;</span><br><span class="line">        tokens.reset();</span><br><span class="line">        parser.addErrorListener(ConsoleErrorListener.INSTANCE);</span><br><span class="line">        parser.setErrorHandler(<span class="keyword">new</span> <span class="title class_">DefaultErrorStrategy</span>());</span><br><span class="line">        parser.getInterpreter().setSLL(<span class="literal">false</span>);</span><br><span class="line">        parser.startRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无缓冲的字符流和词法符号流"><a href="#无缓冲的字符流和词法符号流" class="headerlink" title="无缓冲的字符流和词法符号流"></a>无缓冲的字符流和词法符号流</h3><p>因为ANTLR的识别器在默认情况下会将输入的完整字符流和全部词法符号放入缓冲区，所以它无法处理大小超过内存的文件，也无法处理类似套接字socket连接之类的无限输入流。可以使用字符流和词法符号流的无缓冲版本，它们使用一个滑动窗口来处理流。</p>
<p>一个CSV语法的变体，计算一个文件中两列浮点数的和:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">grammar CSV;</span><br><span class="line"></span><br><span class="line">@members &#123;</span><br><span class="line">    double x, y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file : row+ &#123;System.out.printf(&quot;%f, %f\n&quot;, x, y);&#125;;</span><br><span class="line"></span><br><span class="line">row : a=field &#x27;,&#x27; b=field &#x27;\r&#x27;? &#x27;\n&#x27; </span><br><span class="line">    &#123;</span><br><span class="line">        x += Double.valueof($a.start.getText());</span><br><span class="line">        y += Double.valueof($b.start.getText());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">field : TEXT;</span><br><span class="line"></span><br><span class="line">TEXT : ~[,\n\r]+ ;</span><br></pre></td></tr></table></figure>

<p>关闭ANTLR缓冲功能的三个步骤：</p>
<ul>
<li>使用无缓冲的流代替常见的ANTLRFileStream和CommonTokenStream</li>
<li>给词法分析器传递一个词法符号工厂，将输入流的字符拷贝到生成的词法符号中去</li>
<li>阻止语法分析器建立语法分析树。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnbufferedCharStream</span>(is);</span><br><span class="line"><span class="type">CSVLexer</span> <span class="variable">lex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSVLexer</span>(input);</span><br><span class="line">lex.setTokenFactory(<span class="keyword">new</span> <span class="title class_">CommonTokenFactory</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="type">TokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnbufferedTokenStream</span>&lt;CommonToken&gt;(lex);</span><br><span class="line"><span class="type">CSVParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSVParser</span>(tokens);</span><br><span class="line">parser.setBuildParseTree(<span class="literal">false</span>);</span><br><span class="line">parser.file();</span><br></pre></td></tr></table></figure>

<h3 id="修改ANTLR的代码生成机制"><a href="#修改ANTLR的代码生成机制" class="headerlink" title="修改ANTLR的代码生成机制"></a>修改ANTLR的代码生成机制</h3><p>ANTLR使用两种辅助工具来生成代码：</p>
<ul>
<li>一组StringTemplate文件（包含模版）</li>
<li>一个称为LanguageTarget的Target子类</li>
</ul>
<p>其中Language是语法的language选项，对应的StringTemplate组文件是org/antlr/v4/tool/templates/codegen/Language.stg。若希望修改Java的代码生成模版，拷贝并修改org/antlr/v4/tool/templates/codegen/Java.stg，将它放在ANTLR的jar包之前的CLASSPATH中。ANTLR使用资源加载器获取这些模版，这样，它就能找到修改后的版本。</p>
<p>模版仅仅用于生成特定语法对应的代码，而大多数的常用功能位于运行库中。所以Lexer和Parser都是运行库的一部分。</p>
<h2 id="移除直接左递归"><a href="#移除直接左递归" class="headerlink" title="移除直接左递归"></a>移除直接左递归</h2><p>之前处理算术运算都是通过ANTLR 4语法的左递归完成的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expr : expr &#x27;*&#x27; expr  // 优先级 4</span><br><span class="line">    | expr &#x27;+&#x27; expr   // 优先级 3</span><br><span class="line">    | ID              // 优先级 2</span><br><span class="line">    | INT             // 优先级 1</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>传统的自顶向下的语法ANTLR3无法处理这样的规则。简单而言，ANTLR将左递归替换成一个<code>(...)*</code>，它会比较前一个和下一个运算符的优先级。</p>
<p>熟悉这些规则变换很重要，因为生成的代码反映的是转换后的规则，而非原先的规则。</p>
<h3 id="直接左递归备选分支模式"><a href="#直接左递归备选分支模式" class="headerlink" title="直接左递归备选分支模式"></a>直接左递归备选分支模式</h3><p>ANTLR通过检查下列四种表达式运算模式来认定一条规则为左递归规则：</p>
<ul>
<li><strong>二元</strong>-expr规则的某个备选分支符号<code>expr or expr</code>或者<code>expr (op1|op2|...|opN) expr</code>的形式，或者op是对另外一条规则的引用。</li>
<li><strong>三元</strong>-expr的某个备选分支符号<code>expr op1 expr op2 expr</code>的形式。但是op1和op2必须是单词法符号引用。</li>
<li><strong>一元前缀</strong>-expr的某条规则符号<code>elements expr</code>的形式。ANTLR将任意元素后的尾递归规则引用看作一元前缀模式，前提是它不符合二元和三元模式。</li>
<li><strong>一元后缀</strong>-expr的某条规则符号<code>expr elements</code>形式。和前缀模式相同，ANTLR将任意元素前的直接左递归规则看作一元后缀模式，前提是它不符合二元和三元模式。</li>
</ul>
<p>其他形式的备选分支都被作为<strong>主表达式primary expression</strong>元素处理，例如标识符或者整数，也包括类似<code>&#39;(&#39; expr &#39;)&#39;</code>的形式，因为它不符合上述四种模式的任意一种。</p>
<p>除非额外制定，ANTLR假设所有的运算符都是左结合的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr : expr &#x27;^&#x27;&lt;assoc=right&gt; expr</span><br><span class="line">     | expr &#x27;=&#x27;&lt;assoc=right&gt; expr</span><br><span class="line">     ...</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<h3 id="左递归规则转换"><a href="#左递归规则转换" class="headerlink" title="左递归规则转换"></a>左递归规则转换</h3><p>打开ANTLR命令行的<code> -Xlog</code>选项，就可以在日志文件中看到转换后的左递归规则，通过语义判定判断运算符的优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stat: expr[0] &#x27;;&#x27; ;</span><br><span class="line"></span><br><span class="line">expr[int _p] :   // _p是预期的最低优先级</span><br><span class="line">    (INT | ID)</span><br><span class="line">    ( &#123;4 &gt;= $_p&#125;? &#x27;*&#x27; expr[5] // *具有优先级4</span><br><span class="line">    | &#123;3 &gt;= $_p&#125;? &#x27;+&#x27; expr[4] // +具有优先级3</span><br><span class="line">    )*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>注意：这不是带运算符优先级的语法分析相混淆。带运算符优先级的语法分析无法处理一些特殊情况，例如具有两种不同优先级的负号，一种用于取负，一种用于二元减法。他也无法处理具有两条相邻的规则的备选分支，如<code>expr ops expr</code>.</p>
<p>参数_p的值总是前一个运算符的优先级。_p从0开始，因为对expr的非递归调用会传递0，例如stat会调用<code>expr[0]</code>。</p>
<h2 id="ANTLR-语法参考"><a href="#ANTLR-语法参考" class="headerlink" title="ANTLR 语法参考"></a>ANTLR 语法参考</h2><h3 id="语法词汇表"><a href="#语法词汇表" class="headerlink" title="语法词汇表"></a>语法词汇表</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>ANTLR支持单行、多行、以及Javadoc风格的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注释</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">grammar T;</span><br><span class="line"></span><br><span class="line">/*  多行</span><br><span class="line">  注释</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/** 注释 */</span><br><span class="line">INT : [0-9]+  // 注释</span><br></pre></td></tr></table></figure>

<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>词法符号名和词法规则名总是以大写字母开头，文法规则总是以小写字母开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID, LPAREN, RIGHT_CURLY // 词法符号和词法规则名</span><br><span class="line">expr, simpleDeclarator, d2, header_file // 文法规则名</span><br></pre></td></tr></table></figure>

<p>与java类似，ANTLR允许标识符中出现Unicode字符。</p>
<h4 id="文本常量"><a href="#文本常量" class="headerlink" title="文本常量"></a>文本常量</h4><p>ANTLR不区分字符常量和字符串常量，所有的文本常量都是由单引号括起来的字符串，如<code>&#39;;&#39;</code>,<code>&#39;if&#39;</code>,<code>&#39;\&quot;&#39;</code>等。</p>
<p>文本常量可以包含<code>\uXXXX</code>形式的Unicode转义序列，也能够识别常见的转义序列:’\n’,’\r’,’\t’,’\b’,’\f’，或者直接使用它们的Unicde转义形式。</p>
<p>ANTLR生成的识别器假定语法中的字符都是Unicode字符。ANTLR运行库根据目标语言对输入文件的编码作出假设。例如，对于目标语言是Java的情况，运行库假定输入文件为UTF-8编码。可以使用一些类的构造器来制定编码，比如ANTLRFileStream</p>
<h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><p>动作是使用目标语言编写的代码块。可以在语法中的很多位置使用动作，它们的格式是相同的：有花括号包围的任意文本。内嵌代码可以出现在以<code>@header</code>和<code>@members</code>命名的动作，词法和文法规则、指定异常捕获区、文法规则的属性区域（返回值、参数以及局部变量），以及一些规则元素的选项（当前只有判定）中。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>ANTLR语法中的保留关键字：import,fragment,lexer,parser,grammar,returns,locals,throws,catch,finally,mode,options,tokens。另外，不要使用目标语言中的关键字作为词法符号、标签或者规则名。</p>
<h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p>一份语法由一个语法声明和紧随其后的若干条规则构成，具有如下的通用形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar Name;</span><br><span class="line">options &#123;&#125;</span><br><span class="line">import ;</span><br><span class="line">tokens &#123;&#125;</span><br><span class="line">@actionname &#123;&#125;</span><br><span class="line"></span><br><span class="line">&lt;&lt;rule1&gt;&gt;</span><br><span class="line">&lt;&lt;rule2&gt;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&lt;rulen&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>不带前缀的语法声明是混合语法，可以同时包含词法规则和文法规则，还可以使用单独词法和语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser grammar Name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Name;</span><br></pre></td></tr></table></figure>

<p><em>注意：只有词法规则语法才能包含模式声明</em></p>
<h4 id="语法导入"><a href="#语法导入" class="headerlink" title="语法导入"></a>语法导入</h4><p>语法导入<code>import</code>允许将语法分解成可复用的逻辑但愿。ANTLR处理被导入的语法的方式和面向对象语言中的父类非常相似。一个语法会从其导入的语法中继承所有的规则、词法符号声明和具名的动作。位于主语法中的规则将会覆盖其导入的语法中的规则，以此来实现继承机制。</p>
<p>如果其中存在词法符号声明，主语法会将其合并到词法符号集合中。任意的具名动作，如@members同样也会被合并。通常，应当避免将具名的动作放在被导入语法中的所有选项(options)。</p>
<p>被导入的语法可以导入其他语法。ANTLR按照深度优先的策略处理所有被导入的语法</p>
<ul>
<li>词法语法能导入词法语法</li>
<li>句法语法能导入句法语法</li>
<li>混合语法能导入词法语法或者句法语法</li>
</ul>
<p>ANTLR将被导入的规则放置在主语法的词法规则列表的末尾。这意味着，主语法中的词法规则具有比被导入语法中的规则更高的优先级。</p>
<h4 id="词法符号声明"><a href="#词法符号声明" class="headerlink" title="词法符号声明"></a>词法符号声明</h4><p>tokens区域存在的意义在于，它定义了一份语法所需，但却未在本语法中列出对应规则的词法符号。大多数情况下，tokens区域用于定义本语法中动作所需的词法符号类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tokens &#123;BEGIN, END, IF, THEN, WHILE&#125;</span><br><span class="line">@lexer::membors &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; keywords = new HashMap&lt;String, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(&quot;begin&quot;, KeywordsParser.BEGIN);</span><br><span class="line">        put(&quot;end&quot;, KeywordsParser.END);</span><br><span class="line">        put(&quot;if&quot;, KeywordsParser.IF);</span><br><span class="line">        put(&quot;then&quot;, KeywordsParser.THEN);</span><br><span class="line">        put(&quot;while&quot;, KeywordsParser.WHILE);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tokens区域实际上仅仅是一些会被合并到整体词法符号集合中的词法符号定义。</p>
<h4 id="语法级别的动作"><a href="#语法级别的动作" class="headerlink" title="语法级别的动作"></a>语法级别的动作</h4><p>当前对于Java目标语言而言，只有两种动作，header和members。前者用于将代码注入生成的识别类中的类声明之前，后者用于将代码注入为识别类的字段和方法。</p>
<p>对于混合语法，ANTLR同时将这些代码注入到词法分析器和语法分析器中。<code>@parser::name</code> 或者 <code>@lexer::name</code></p>
<h3 id="文法规则"><a href="#文法规则" class="headerlink" title="文法规则"></a>文法规则</h3><p>语法分析器由一系列文法规则组成，这些规则既可以位于文法语法中，也可以位于混合语法中。Java程序通过调用ANTLR自动生成的，与预期的起始规则相对应的函数来启动语法分析器。规则最基本的形式是规则后面紧接着一个备选分支，然后是一个分号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: retstat</span><br><span class="line">    | &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">    | &#x27;continue&#x27; &#x27;;&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>备选分支是一组可以为空的规则元素列表。例如，下列规则中的空备选分支使得整条规则成为了可选的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">superClass</span><br><span class="line">    : &#x27;extends&#x27; ID</span><br><span class="line">    |</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h4 id="备选分支的标签"><a href="#备选分支的标签" class="headerlink" title="备选分支的标签"></a>备选分支的标签</h4><p>可以使用<code>#</code>给最外层的备选分支添加标签，以获得更加精确的语法分析器监听器事件。一条规则中的备选分支要么全部带上标签，要么全部不带标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grammar AltLabels;</span><br><span class="line">stat : &#x27;return&#x27; e &#x27;;&#x27; # Return</span><br><span class="line">     | &#x27;break&#x27; &#x27;;&#x27;    # Break</span><br><span class="line">     ;</span><br><span class="line">e    : e &#x27;*&#x27; e        # Mult</span><br><span class="line">     | e &#x27;+&#x27; e        # Add</span><br><span class="line">     | INT            # Int</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p>备选分支的标签无须位于行尾，<code>#</code>后的空格也不是必需的。ANTLR为每个标签生成一个规则上下文类。如果一个分选分支名与另外一条规则名产生冲突，ANTLR会提示出错。</p>
<h4 id="规则上下文对象"><a href="#规则上下文对象" class="headerlink" title="规则上下文对象"></a>规则上下文对象</h4><p>ANTLR为每个规则引用生成规则上下文对象（即语法分析树节点）的访问方法。对于只包含一条规则引用的规则，ANTLR会生成一个无参方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inc : e &#x27;++&#x27; ;</span><br></pre></td></tr></table></figure>

<p>在规则中包含不止一个规则引用时，ANTLR也提供了对各上下文对象访问的支持。</p>
<p>ANTLR生成一个单参数方法，其参数是访问第i个规则元素时的索引值，另外它还生成一个方法，返回该规则对应的所有上下文对象。</p>
<p>如果另外一条规则s引用了field，可以通过内嵌动作来访问:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s : field</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;EContext&gt; x = $field.ctx.e();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="规则元素标签"><a href="#规则元素标签" class="headerlink" title="规则元素标签"></a>规则元素标签</h4><p>可以使用<code>=</code>符号给规则元素增加标签，以此为规则上下文对象增加字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat</span><br><span class="line">    : &#x27;return&#x27; value=e &#x27;;&#x27;  # Return</span><br><span class="line">    | &#x27;break&#x27; &#x27;;&#x27;           # Break</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>这里的value就是规则e的返回值，而e是在别处定义的。</p>
<p>标签会成为对应的语法分析树节点类的字段。value标签成为ReturnContext类的字段，因为Return标签的存在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnContext</span> <span class="keyword">extends</span> <span class="title class_">StatContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> EContext value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>+=</code>列表标签(list label)符号来方便地获取一组词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array : &#x27;&#123;&#x27; el+=INT (&#x27;,&#x27; el+=INT)* &#x27;&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p>ANTLR在相应的规则上下文类中生成了一个List字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayContext</span> <span class="keyword">extends</span> <span class="title class_">ParserRuleContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Token&gt; el = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Token&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签列表也适用于规则引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elist : expr+=e (&#x27;,&#x27; exprs+=e)* ;</span><br></pre></td></tr></table></figure>

<h4 id="规则元素"><a href="#规则元素" class="headerlink" title="规则元素"></a>规则元素</h4><p>规则元素指明了语法分析器在特定的时间需要完成的任务，正如编程语言中的语句一样。规则元素可以是一条规则、一个词法符号或者一个字符串常量，例如expression、ID和’return’。下表是规则元素的所有可行值</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td>在当前输入位置上匹配词法符号<code>T</code>。词法符号总是以大写字母开头</td>
</tr>
<tr>
<td><code>&#39;literal&#39;</code></td>
<td>在当前输入位置上匹配字符串常量。一个字符串常量就是一个由固定字符串组成的词法符号</td>
</tr>
<tr>
<td><code>r</code></td>
<td>在当前输入位置上匹配规则<code>r</code>，这相当于像函数一样调用该规则。文法规则名总是以小写字母开头</td>
</tr>
<tr>
<td><code>r[&lt;&lt;args&gt;&gt;]</code></td>
<td>在当前输入位置上匹配<code>r</code>，并且像函数调用一样传递一组参数。方括号中的参数格式依目标语言而定，通常是一组由逗号分隔的表达式列表</td>
</tr>
<tr>
<td><code>&#123;&lt;&lt;action&gt;&gt;&#125;</code></td>
<td>在前一个备选分支元素之后，后一个备选分支元素之前执行一段动作代码。动作中的代码符合目标语言的语法。ANTLR原封不动地将这些动作代码拷贝到生成的类中，除了其中的属性占位符和词法符号引用,如<code>$x</code>和<code>$x.y</code></td>
</tr>
<tr>
<td><code>&#123;&lt;&lt;p&gt;&gt;&#125;?</code></td>
<td>执行语义判定<code>&lt;&lt;p&gt;&gt;</code>。在运行时，如果<code>&lt;&lt;p&gt;&gt;</code>的结果为假值，那么停止对该判定之后的部分进行语法分析。判定多用在预测的场合中，当ANTLR需要区分多个备选分支时，它动态地开启或关闭其对应的某个备选分支。</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配任意除文件结束符之外的语法符号。它被称为通配符(wildcard)</td>
</tr>
</tbody></table>
<p>当需要匹配除了一个/一组词法符号之外的任何东西时，使用<code>~</code>非运算符。该运算符很少被用于语法分析器中，尽管这是可行的。<code>~INT</code>匹配除INT之外的任意词法符号,<code>~&#39;,&#39;</code>匹配除逗号之外的任意词法符号。<code>~(INT|ID)</code>匹配除INT或ID之外的任意词法符号。词法符号、字符串常量以及语义判定这些规则元素可以携带选项(option)。</p>
<h4 id="子规则"><a href="#子规则" class="headerlink" title="子规则"></a>子规则</h4><p>一条规则可以包含称为子规则的备选分支块(即扩展巴克斯-诺尔范式,Extend BNF Notation, EBNF)。子规则和规则相似，只是缺少名字并包裹在圆括号内。在自规则的括号内，可以包含一个或者多个备选分支。子规则不能像规则一样使用local和return定义属性。</p>
<ul>
<li><code>?</code>:匹配至多一次</li>
<li><code>*</code>:匹配零次或多次</li>
<li><code>+</code>:匹配一次或多次</li>
</ul>
<p>作为简写，在子规则仅包含一个备选分支时，可以忽略子规则两侧的括号。例如<code>ann+</code>和<code>(ann)+</code>相同，<code>ID+</code>和<code>(ID)+</code>相同。简写的方式也适用于标签。<code>ids+=INT+</code>会生成一列INT对象。</p>
<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>当在一条规则中发生语法错误时，ANTLR会捕获该异常，报告错误，并试图从中恢复(可能通过消费更多的词法符号来完成此过程)，然后从规则中返回。每条规则都包裹在一个<code>try/catch/finally</code>语句中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">r</span><span class="params">()</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        &lt;&lt;rule-body&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RecognitionException re) &#123;</span><br><span class="line">        _errHandler.reportError(<span class="built_in">this</span>, re);</span><br><span class="line">        _errHandler.recover(<span class="built_in">this</span>, re);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        exitRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要修改单单条规则的异常处理机制，可以在规则定义后指定一个异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r   : ...</span><br><span class="line">    ;</span><br><span class="line">    catch[RecognitionException e] &#123; throw e; &#125;</span><br></pre></td></tr></table></figure>

<p>这个例子展示了如何避免使用默认的错误报告和处理机制。r抛出的异常应当被更高层的规则所报告。指定任意异常都会令ANTLR不再生成默认的处理RecognitionException的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r   : ...</span><br><span class="line">    ;</span><br><span class="line">    catch[FailPredicateException fpe] &#123; ... &#125;</span><br><span class="line">    catch[RecognitionException e] &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>在花括号中的代码片段以及作为“参数”的异常必须使用目标语言编写—-在这个例子中就是Java。可将即使异常发生也需要执行的动作代码放入finally语句中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r   : ...</span><br><span class="line">    ;</span><br><span class="line">    // 首先是catch语句块</span><br><span class="line">    finally &#123; System.out.println(&quot;exit rule r&quot;); &#125;</span><br></pre></td></tr></table></figure>

<p>finally语句会在规则返回时触发的exitRule()之前执行。如果需要在规则完成对备选分支的匹配之后，清理工作开始之前执行一段动作代码，可以使用after。</p>
<p>五种ANTLR异常规则：</p>
<ul>
<li>RecognitionException -&gt;</li>
<li>FailedPredicateException</li>
<li>InputMismatchException</li>
<li>LexerNoviableAltException</li>
<li>NoViableAltException</li>
</ul>
<h3 id="规则属性定义"><a href="#规则属性定义" class="headerlink" title="规则属性定义"></a>规则属性定义</h3><p>需要了解许多与规则和动作相关的语法元素。规则可以像编程语言中的函数一样，包含参数、返回值以及局部变量。ANTLR会将定义的所有变量收集起来并存储到规则上下文对象中，这些变量通常称为属性。下面的通用形式展示了所有可行的属性定义位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rulename[&lt;&lt;args&gt;&gt;] returns [&lt;&lt;retvals&gt;&gt;] locals [&lt;&lt;localvars&gt;&gt;] : ... ;</span><br></pre></td></tr></table></figure>

<p>定义在<code>[...]</code>中的属性的使用方法和其他任意变量一样。下面的示例规则将参数值传递给返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add[int x] returns [int result] : &#x27;+=&#x27; INT </span><br><span class="line">    &#123; $result = $x + $INT.int; &#125;;</span><br></pre></td></tr></table></figure>

<p>在语法层面上，可以指定规则级的具名动作。这样的有效命名包括init和after。语法分析器在试图匹配相应规则之前执行init动作，在结束对相应的匹配之后立即执行after工作。ANTLR的after动作不会作为自动生成的规则函数的finally代码块的一个部分。可以使用ANTLR的finally动作来放置在规则函数的finally块中执行的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">row[String[] columns] returns [Map&lt;String, String&gt; values]</span><br><span class="line">locals [int col = 0]</span><br><span class="line">@init &#123;</span><br><span class="line">    $value = new HashMap&lt;String, String&gt;();</span><br><span class="line">&#125;</span><br><span class="line">@after &#123;</span><br><span class="line">    if ($value != null &amp;&amp; $values.size() &gt; 0) &#123;</span><br><span class="line">        System.out.println(&quot;values = &quot; + $values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>row规则接受参数columns，返回values，且定义了局部变量col。方括号中的内容将直接拷贝到生成的代码里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSVParser</span> <span class="keyword">extends</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RowContext</span> <span class="keyword">extends</span> <span class="title class_">ParserRuleContext</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String[] columns;</span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, String&gt; values;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的规则函数的参数即规则的参数，它们已经被拷贝到了局部的RowContext对象中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CSVParser</span> <span class="keyword">extends</span> <span class="title class_">Parser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">RowContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowContext</span>(_ctx, <span class="number">4</span>, columns);</span><br><span class="line">    enterRule(_localctx, RULE_row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ANTLR能够自动分析嵌套在动作中的<code>[...]</code>，因此<code>String[] columns</code>能够得到正确的解析。它也能分析出尖括号，所以泛型参数中的逗号不会被错误解析成属性的分隔符。例如，<code>Map&lt;String, String&gt;</code>是一个属性定义。</p>
<p>一个动作可以包含多个属性，即使是作为返回值的动作。在同一段动作代码中，使用逗号分隔多个属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[Map&lt;String, String&gt; x, int y] : ...;</span><br></pre></td></tr></table></figure>

<p>ANTLR将上述代码解析为两个参数x和y。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AContext <span class="title function_">a</span><span class="params">(Map&lt;String, String&gt; x, <span class="type">int</span> y)</span> <span class="keyword">throws</span> RecognitionException &#123;</span><br><span class="line">    <span class="type">AContext</span> <span class="variable">_localctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AContext</span>(_ctx, <span class="number">0</span>, x, y);</span><br><span class="line">    enterRule(_localctx, RULE_a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="起始规则和文件结束符"><a href="#起始规则和文件结束符" class="headerlink" title="起始规则和文件结束符"></a>起始规则和文件结束符</h4><p>起始规则是语法分析器最初应用的规则，它对应的规则函数被语言类应用程序所调用。例如，一个解析Java的语言类应用程序可能会调用parser.compliationUnit()，其中的parser是一个JavaParser对象。语法中的任意规则都可以作为起始规则。</p>
<p>起始规则不需要消费全部的输入文本。它们只消费能够匹配本规则的备份分支之一的、尽可能多的输入文本。例如，下列规则能够根据输入情况，自动匹配一个、两个或三个词法符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s : ID</span><br><span class="line">  | ID &#x27;+&#x27;</span><br><span class="line">  | ID &#x27;+&#x27; INT</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>对于<code>a+3</code>，规则s匹配第三个备选分支。对于<code>a+b</code>，它匹配第二个备选分支，忽略b。对于<code>a b</code>，它匹配第一个备选分支，忽略<code>b</code>。在后两个例子中，语法分析器并没有消费掉全部的输入文本，因为规则s并没有明确指明，文件结束符必须出现在匹配的备选分支之后。</p>
<p>另一方面，描述整个输入文件的规则应该引用特殊的预定义词法符号EOF。下列规则是一份语法的一部分，它负责读取配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config : element*; // 能够“匹配”带有无效内容的输入文本</span><br></pre></td></tr></table></figure>

<p>无效输入会使config不匹配任何输入，立即返回，且不报告错误，下面是正确的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file : element* EOF;  // 不要提前结束，必须匹配所有输入文本</span><br></pre></td></tr></table></figure>

<h3 id="动作和属性"><a href="#动作和属性" class="headerlink" title="动作和属性"></a>动作和属性</h3><p>动作是以目标语言编写的，位于花括号中的文本块，识别器根据它们在语法中的位置，在不同的时机触发之。例如，下列规则在语法分析器发现有效的定义后，打印出found a decl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decl : type ID &#x27;;&#x27; &#123;System.out.println(&quot;found a decl&quot;);&#125;;</span><br><span class="line">type : &#x27;int&#x27; | &#x27;float&#x27;;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，动作会访问特定词法符号和规则引用的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decl : type ID &#x27;;&#x27;</span><br><span class="line">       &#123;System.out.println(&quot;var &quot;+$ID.text+&quot;:&quot;+$type.text+&quot;;&quot;);&#125;</span><br><span class="line">     | t=ID id=ID &#x27;;&#x27;</span><br><span class="line">       &#123;System.out.println(&quot;var &quot;+$id.text+&quot;:&quot;+$t.text+&quot;;&quot;);&#125;</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<h4 id="词法符号属性"><a href="#词法符号属性" class="headerlink" title="词法符号属性"></a>词法符号属性</h4><p>所有的词法符号都包含一组预定义的只读属性。这些属性包括一些有用的数据，例如词法符号类型以及其匹配的文本。动作可以通过<code>$label.attribute</code>方式访问这些属性，其中<code>label</code>代表一个特定的词法符号。通常情况下，一个特定的词法符号在规则中只会出现一次，此时，在动作中，用词法符号名来引用它是不会产生歧义的。下面的例子展示了词法符号的属性表达式的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r   : INT &#123;int x = $INT.line;&#125;</span><br><span class="line">      ( ID &#123;if ($INT.line == $ID.line) ...; &#125; )?</span><br><span class="line">      a=FLOAT b=FLOAT &#123;if ($a.line == $b.line) ...;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p><code>(...)?</code>子规则中的动作能够访问到自己之前的外层INT词法符号。其中，由于存在两个FLOAT词法符号引用，动作中的<code>$FLOAT</code>并不是唯一的，必须使用标签来指定欲访问的词法符号引用。</p>
<p>在不同的备选分支中，相同的词法符号引用是唯一的，因为在任何规则的调用中，它们之中只有一个会得到匹配。例如，在下列规则中，两个备选分支的动作都可以直接引用$ID，而无须使用标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r   : ... ID &#123;System.out.println($ID.text);&#125;</span><br><span class="line">    | ... ID &#123;System.out.println($ID.text);&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>想要访问字符串常量匹配的词法符号，则必须使用标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat:  r=&#x27;return&#x27; expr &#x27;;&#x27; &#123;System.out.println(&quot;line=&quot;+$r.line);&#125;;</span><br></pre></td></tr></table></figure>

<p>大多数情况下需要访问的都是词法符号的属性，不过有时候也需要访问Token对象本身，因为它聚合起了所有的属性。此外，可以使用它来测试一条可选的子规则是否匹配到了一个词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stat: &#x27;if&#x27; expr &#x27;then&#x27; stat (el=&#x27;else&#x27; stat)?</span><br><span class="line">      &#123;if ($el!=null) System.out.println(&quot;found an else&quot;); &#125;</span><br><span class="line">    | ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p><code>$T</code>和<code>$l</code>分别为解析成名为T的词法符号和标签为l的词法符号。<code>$ll</code>会被解析成列表标签II对应的<code>List&lt;Token&gt;</code>。<code>$T.attr</code>会被解析成类型为T的词法符号。</p>
<p>词法属性attr对应的类型和值</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>String</td>
<td>词法符号匹配到的文本，它会被替换成getText()方法调用。例如$ID.text</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td>词法符号对应的正整数类型值，如INT。它会转换成getType()方法调用。例如$ID.type</td>
</tr>
<tr>
<td>line</td>
<td>int</td>
<td>词法符号所处的行号，从1开始计数。它会被转换成getLine()方法调用，例如$ID.line</td>
</tr>
<tr>
<td>pos</td>
<td>int</td>
<td>词法符号的第一个字符在行内的位置，从0开始计数。它会被转换成getCharPositionInLine()方法调用。例如：$ID.pos</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td>词法符号在词法符号流中的全局索引值，从0开始计数。它会转换成getTokenIndex()方法调用。例如：$ID.index</td>
</tr>
<tr>
<td>channel</td>
<td>int</td>
<td>词法符号所在的通道数。语法分析器只处理一个通道的词法符号。忽略其他通道的词法符号。默认的通道是0（Token.DEFAULT_CHANNEL）,默认的隐藏通道是Token.HIDDEN_CHANNEL。它会被转换成getChannel()方法调用。例如：$ID.channel</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
<td>词法符号持有的整数值。它假设词法符号的文本是有效的数字。对于计算器之类的程序，这个属性非常有用。它会被转换成Integer.valueOf(text-of-token)。例如：$INT.int</td>
</tr>
</tbody></table>
<h4 id="文法规则属性"><a href="#文法规则属性" class="headerlink" title="文法规则属性"></a>文法规则属性</h4><p>ANTLR预定义了一系列只读的文法规则属性，供动作使用。动作只能访问自己前面的规则属性。访问名字或者标签为r的规则属性语法是$r.attr。例如，下面的$expr.text返回expr规则匹配的全部文本的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnStat : &#x27;return&#x27; expr &#123;System.out.println(&quot;matched &quot;+$expr.text);&#125;;</span><br></pre></td></tr></table></figure>

<p>规则标签的用法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnStat : &#x27;return&#x27; e=expr &#123;System.out.println(&quot;matched &quot;+$e.text);&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>$</code>后跟属性名来访问当前执行的规则的相应属性。例如，$start是当前规则的起始词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnStat : &#x27;return&#x27; expr &#123; System.out.println(&quot;first token &quot;+$start.getText();) &#125;;</span><br></pre></td></tr></table></figure>

<p>文法属性attr对应的类型和值</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>String</td>
<td>一条规则匹配的文本或者从这条规则的起始位置到$text当前位置对应的文本。需要注意的是，它包含了隐藏通道中的全部词法符号，这通常是正确的，因为其中含有全部的空白字符和注释。当作为当前规则的属性时，它可以在任何动作中使用，包括异常处理动作</td>
</tr>
<tr>
<td>start</td>
<td>Token</td>
<td>在主要词法符号通道上被规则匹配到第一个词法符号。换句话说，该属性永远不会位于隐藏通道中。对于那些不匹配任何词法符号的规则，这个属性指向第一个后续的词法符号。当作为当前规则的属性时，它可以在规则内的任何动作中使用</td>
</tr>
<tr>
<td>stop</td>
<td>Token</td>
<td>规则匹配到最后一个非隐藏通道的词法符号。当作为当前规则的属性时，它仅能在after和finally动作中使用</td>
</tr>
<tr>
<td>ctx</td>
<td>ParseRuleContext</td>
<td>一条规则调用对应的规则上下文对象。通过这个属性可以访问其余全部属性。例如：$ctx.start当问当前规则上下文对象的start字段。它等价于$start。</td>
</tr>
</tbody></table>
<h4 id="动态作用域属性"><a href="#动态作用域属性" class="headerlink" title="动态作用域属性"></a>动态作用域属性</h4><p>和通用编程语言中的函数一样，可以使用参数向规则传递信息，并使用返回值接收信息。但是，编程语言通常不允许其他函数访问局部变量或者参数。</p>
<p>例如，在Java中，从嵌套函数中访问局部变量x是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    g();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span> &#123;</span><br><span class="line">    h();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">h</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x; <span class="comment">// 对函数f中的局部变量x的非法引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量x只能在f()的作用域中使用，该作用域是由花括号所决定的词法作用域。因此，Java的作用域是词法作用域。词法作用域是大多数编程语言采用的方案。允许方法沿着调用链向上访问之前定义的局部变量的编程语言被称为具有动态作用域。其中的“动态”指的是编译器无法通过静态方式决定可见的变量集合。这是由于对于一个方法而言，可见变量的集合取决于它的调用者。</p>
<p>在语法层面上，有时候相距很远的两条规则需要进行通信，大多数情况下是为了向调用链之下的规则提供上下文信息。ANTLR允许这样的动作中的动态作用域，即使用<code>$r::x</code>访问调用者规则中的属性，其中r是规则名，而x是该规则中的属性。需要开发者自行保证，r是当前规则的调用者，否则，当访问<code>$r::x</code>时，一个运行时异常会被抛出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">grammar DynScope;</span><br><span class="line"></span><br><span class="line">prog: block</span><br><span class="line">    ;</span><br><span class="line">block</span><br><span class="line">/* 在这个代码块中定义的符号列表 */</span><br><span class="line">locals [</span><br><span class="line">    List&lt;String&gt; symbols = new ArrayList&lt;String&gt;()</span><br><span class="line">]</span><br><span class="line">    : &#x27;&#123;&#x27; decl* stat+ &#x27;&#125;&#x27;</span><br><span class="line">        // 打印block中的所有符号</span><br><span class="line">        // $block::symbols即作用域定义的符号列表</span><br><span class="line">        &#123;System.out.println(&quot;symbols=&quot;+$symbols);&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/** 匹配一个变量声明，并将其标识符加入符号列表 */</span><br><span class="line">decl: &#x27;int&#x27; ID &#123;$block::symbols.add($ID.text);&#125; &#x27;;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/** 匹配一个赋值语句，检查符号列表，确保赋值语句 </span><br><span class="line">  * 左侧的变量名已经存在</span><br><span class="line">  * contains()方法是List.contains(),因为$block::symbols</span><br><span class="line">  * 是一个List</span><br><span class="line">  */</span><br><span class="line">stat: ID &#x27;=&#x27; INT &#x27;;&#x27;</span><br><span class="line">    &#123;</span><br><span class="line">        if ( !$block::symbols.contains($ID.text)) &#123;</span><br><span class="line">            System.err.println(&quot;undefined variable: &quot;+$ID.text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    | block</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">ID : [a-z]+;</span><br><span class="line">INT: [0-9]+;</span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>在使用@members进行的简单字段定义和动态作用域之间存在一个重要区别。symbols是一个局部变量，所以block规则的每次调用都会生成一份拷贝。这正是所期望的行为，可以在内部代码块中复用相同的输入变量名。</p>
<h3 id="词法规则"><a href="#词法规则" class="headerlink" title="词法规则"></a>词法规则</h3><p>词法语法由词法规则组成，并且可被分解成多个模式，正如使用词法模式处理上下文相关的词法符号。词法模式允许将一份词法语法分解成多个子语法。词法分析器只能返回当前模式下的规则匹配到的词法符号。</p>
<p>词法规则的定义方式和文法规则非常相似，除了一些例外：词法规则不能包含参数、返回值或者局部变量。词法规则名必须以大写字母开头，以和文法规则名区分开。</p>
<p>也可以定义一些规则，它们不是词法符号，但是却可以在识别过程中提供词法符号的功能。这样的fragment规则不会生成语法分析器可见的词法符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fragment HelperTokenRule : ... | ...;</span><br></pre></td></tr></table></figure>

<h4 id="词法模式"><a href="#词法模式" class="headerlink" title="词法模式"></a>词法模式</h4><p>词法模式允许将词法规则按照上下文分组，例如XML标签内外。这和以下情况类似：多个子词法分析器负责处理业务，另外一个子词法分析器负责处理上下文。词法分析器只能返回当前模式下的规则匹配到的词法符号，词法分析器以默认模式开始。除非使用mode指令指定，所有的规则都处于默认模式下。模式只能出现在词法语法中，在混合语法中不允许出现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;rules in default mode&gt;&gt;</span><br><span class="line">...</span><br><span class="line">mode MODE1;</span><br><span class="line">&lt;&lt;rules in MODE1&gt;&gt;</span><br><span class="line">...</span><br><span class="line">mode MODEN;</span><br><span class="line">&lt;&lt;rules in MODEN&gt;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="词法规则元素"><a href="#词法规则元素" class="headerlink" title="词法规则元素"></a>词法规则元素</h4><p>有两种结构不能出现在文法规则中，但却可以出现在词法规则中即：<code>..</code>范围运算符和方括号包围的字符集合标记<code>[characters]</code>。不要将字符集合和文法规则中的参数相混淆。<code>[characters]</code>在词法分析器中仅仅意味着一个字符集合。</p>
<p>词法规则元素总结如下表:</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;literal&#39;</code></td>
<td>匹配指定的字符或者字符序列.例如:’while’或者’=’</td>
</tr>
<tr>
<td><code>[char set]</code></td>
<td>匹配字符集中的一个字符。x-y意为x到y的字符集合(包括x和y)。下列转义字符会被解释为单个字符：’\n’,’\r’,’\b’,’\t’和’\f’。如果需要表达],\或者-，则必须使用\进行转义。此外，还可以使用Unicode字符形式：\uXXXX。</td>
</tr>
<tr>
<td><code>&#39;x&#39; .. &#39;y&#39;</code></td>
<td>匹配x与y之间的单个字符(包括x和y)。例如<code>&#39;a&#39; .. &#39;z&#39;</code> 等价于<code>[a-z]</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td>调用词法规则T。允许一般情况下的递归，但是不允许左递归。T可以是一个常规的词法符号或者fragment规则</td>
</tr>
<tr>
<td><code>&#123;&lt;&lt;action&gt;&gt;&#125;</code></td>
<td>词法动作必须出现在最外层的备选分支末尾。如果一个词法规则包含多于一个备选分支，需要将它们放置在括号中，并令动作紧随其后。和文法规则不同，它不会翻译形如<code>$x.y</code>这样的表达式</td>
</tr>
<tr>
<td><code>&#123;&lt;&lt;p&gt;&gt;&#125;?</code></td>
<td>对语义判定<code>&lt;&lt;p&gt;&gt;</code>求值。如果<code>&lt;&lt;p&gt;&gt;</code>在运行时结果为假值，其对应的规则将会变得不可见。表达式<code>&lt;&lt;p&gt;&gt;</code>遵循目标语言的语法。虽然语义判定可以出现在词法规则的任意位置，但是出于效率的考虑，最好将它们放置在规则末尾。语义判定必须出现在词法动作之前</td>
</tr>
<tr>
<td><code>~x</code></td>
<td>匹配任意不属于集合x的单个字符。结合x可以是单个字符常量、一个范围，或者是一条形如`~(‘x’</td>
</tr>
</tbody></table>
<p>和文法规则一样，词法规则也允许括号包围的子规则和EBNF符号的存在：<code>?</code>,<code>*</code>,<code>+</code>。同时，在词法规则中，也可以在上述EBNF符号后使用非贪婪后缀<code>?</code>。</p>
<h4 id="递归词法规则"><a href="#递归词法规则" class="headerlink" title="递归词法规则"></a>递归词法规则</h4><p>和大多数词法语法工具不同的是，ANTLR词法规则可以是递归的。这在某些情况下带来了极大的便利。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Recur;</span><br><span class="line">ACTION : &#x27;&#123;&#x27; ( ACTION | ~[&#123;&#125;] )* &#x27;&#125;&#x27;;</span><br><span class="line">WS     : [ \r\t\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<h4 id="冗余字符串常量"><a href="#冗余字符串常量" class="headerlink" title="冗余字符串常量"></a>冗余字符串常量</h4><p>不要在多条词法规则的右侧指定相同的字符串常量。这样的字符串常量存在歧义，它将能够匹配多种类型的词法符号。ANTLR会使这些字符串常量对语法分析器不可用。这同样适用于跨模式的规则。</p>
<h4 id="词法规则动作"><a href="#词法规则动作" class="headerlink" title="词法规则动作"></a>词法规则动作</h4><p>ANTLR词法分析器在匹配到一条词法规则后会生成一个词法符号对象。每个对词法符号的请求都从Lexer.nextToken()开始，该方法对每个识别到的词法符号调用一次<code>emit()</code>一次。<code>emit()</code>从词法分析器的当前状态收集信息，生成词法符号。它访问字段_type,_text,_channel,_tokenStartCharIndex,_tokenStartLien,以及_tokenStartCharPositionInLine。可以通过类似setType()的setter方法设置这些状态。例如，若enumIsKeyword为假值，下列规则将enum转换成一个标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENUM : &#x27;enum&#x27; &#123; if(!enumIsKeyword) setType(Identifier); &#125;;</span><br></pre></td></tr></table></figure>

<p>在词法规则动作中，ANTLR不会对特殊的$x进行翻译。一条词法规则无论包含多少个备选分支，它最多只能包含一段动作。</p>
<h4 id="词法分析器指令"><a href="#词法分析器指令" class="headerlink" title="词法分析器指令"></a>词法分析器指令</h4><p>为避免语法和特定目标语言的耦合，ANTLR支持词法分析器指令。和任意的内嵌动作不同，这些指令遵循独立的语法，并且数量有限。词法分析器指令出现在词法规则定义的最外层备选分支末尾。每条词法符号规则最多只能包含一条指令。词法分析器指令由-&gt;运算符及其后的一个或多个指令名组成，可以携带参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TokenName : &lt;&lt;alternative&gt;&gt; -&gt; commmand_name(&lt;&lt;identifier or integer&gt;&gt;);</span><br></pre></td></tr></table></figure>

<p>一个备选分支可以以逗号分隔的形式携带多个指令。下面是有效的指令名：</p>
<ul>
<li><strong>skip</strong>-此规则不会将对应的词法符号返回给语法分析器。它常用于处理空白字符</li>
<li><strong>more</strong>-匹配此规则，但是使用这些文本继续进行词法符号匹配。下一条词法符号规则匹配的文本将会包含当前规则匹配的文本。此指令通常应用于词法模式中。</li>
<li><strong>type(T)</strong>-为当前词法符号设置类型。</li>
<li><strong>channel(C)</strong>-为当前词法符号设置通道，默认值为Token.DEFAULT_CHANNEL。可以自行定义一些常量然后使用。</li>
<li><strong>mode(M)</strong>-在匹配当前词法符号后，将词法分析器切换到M模式。随后，词法分析器将只会使用M模式中的规则匹配词法符号。M可以是一个定义于相同语法文件的模式名或者一个整数常量。</li>
<li><strong>pushMode(M)</strong>-它和mode的作用大致相同，不过它除了设置模式M之外，还会将当前模式推入一个栈中。它应当与popMode联合使用。</li>
<li><strong>popMode</strong>-从模式栈中弹出一个模式，并将栈顶模式设置为当前模式。它应当与pushMode联合使用。</li>
</ul>
<h3 id="通配符与非贪婪子规则"><a href="#通配符与非贪婪子规则" class="headerlink" title="通配符与非贪婪子规则"></a>通配符与非贪婪子规则</h3><p>诸如<code>(...)?</code>，<code>(...)*</code>和<code>(...)+</code>的EBNF子规则是贪婪的(greedy)—-它们会消费尽可能多的输入文本，在某些情况下，这是不希望看到的。在词法分析器和部分语法分析器中，类似<code>.*</code>的结构会持续匹配到输入文本的末尾。若希望这样的循环是非贪婪的(nongreedy),则需要使用另外一种从正则表达式中借鉴来的语法:<code>.*?</code>。可以通过添加<code>?</code>后缀的方式使任意以?，*或+结尾的子规则变成非贪婪的。非贪婪子规则在词法分析器和语法分析器中都是被允许的，不过在词法分析器中的应用更为广泛。</p>
<h4 id="非贪婪词法子规则"><a href="#非贪婪词法子规则" class="headerlink" title="非贪婪词法子规则"></a>非贪婪词法子规则</h4><p>下面是一条匹配C风格注释的词法规则，它会消费所有的字符，直至遇到结尾的’*/‘为止：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMENT : &#x27;/*&#x27; .*? &#x27;*/&#x27;  -&gt; skip;  // .*?匹配任意字符，直至遇到第一个*/为止。</span><br></pre></td></tr></table></figure>

<p>下列语法匹配允许转义双引号<code>\&quot;</code>存在的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grammar Nongreedy;</span><br><span class="line">s : STRING+;</span><br><span class="line">STRING : &#x27;&quot;&#x27; ( &#x27;\\&quot;&#x27; | . )*? &#x27;&quot;&#x27; ; // 匹配&quot;foo&quot;,&quot;\&quot;&quot;,&quot;x\&quot;\&quot;y&quot;,...</span><br><span class="line">WS : [ \r\t\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>应当尽量少用非贪婪子规则，因为它们增加了识别的复杂度，有时甚至会使语法分析器匹配文本的过程变得棘手。词法分析器选择词法符号规则的方法如下：</p>
<ul>
<li>首要目标是匹配能够识别最多输入字符的词法规则</li>
<li>如果多于一条词法规则匹配相同的输入序列，那么在语法文件中位置靠前的规则具有更高的优先级</li>
<li>非贪婪子规则匹配能够满足该规则的最少的字符序列</li>
<li>在词法规则中非贪婪匹配子规则之后的所有决策都遵循“首先匹配”原则</li>
</ul>
<p>例如: <code>.*? (&#39;a&#39;|&#39;ab&#39;)</code>右侧的备选分支<code>&#39;ab&#39;</code>是无用代码，它将永远不会被匹配到。如果输入文本是ab，那么第一个备选分支<code>&#39;a&#39;</code>就会匹配第一个字符并结束匹配过程。与之相比，<code>(&#39;a&#39;|&#39;ab&#39;)</code>本身能够使用第二个备选分支正确匹配输入ab。这种现象是非贪婪匹配的过程中有意为之，目的是降低复杂度。</p>
<h4 id="非贪婪文法子规则"><a href="#非贪婪文法子规则" class="headerlink" title="非贪婪文法子规则"></a>非贪婪文法子规则</h4><p>在文法规则中，若语法分析器的目标是按照粗略的语法从输入文件中提取信息，即进行“模糊匹配”，非贪婪的子规则和通配符也是非常有用的。相对于词法分析器中的非贪婪决策，语法分析器总是能够作出全局性的正确决策。换句话说，语法分析器的决策不会使得合法输入在后面的某个时刻失败。非贪婪文法子规则的核心思想是：对于有效的输入序列，匹配使语法分析过程成功的最短词法符号序列。</p>
<p>下面的语法展示了从任意Java文件中提取整数常量的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">grammar FuzzyJava;</span><br><span class="line">/** 匹配constant规则匹配到的结果之间的任意文本 */</span><br><span class="line">file : .*? (constant .*?)+;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 另一个更快的版本(ANTLR工具会对.*子规则给出一条警告，可忽略掉)</span><br><span class="line"> */</span><br><span class="line">altfile : (constant | .)* ; // 匹配一个常量或者任意词法符号0次或多次</span><br><span class="line"></span><br><span class="line">/** 匹配类似&quot;public static final SIZE&quot;的文本 */</span><br><span class="line">constant</span><br><span class="line">    : &#x27;public&#x27; &#x27;static&#x27; &#x27;final&#x27; &#x27;int&#x27; Identifier</span><br><span class="line">      &#123;System.out.println(&quot;constant: &quot;+$Identifier.text);&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">Identifier : [a-zA-Z_$] [a-zA-Z_$0-9]* // 简化的标识符</span><br></pre></td></tr></table></figure>

<h3 id="语义判定"><a href="#语义判定" class="headerlink" title="语义判定"></a>语义判定</h3><p>语义判定<code>&#123;...&#125;?</code>是使用目标语言编写的布尔表达式，它指示了沿当前判定所守护的路径继续进行语法分析的可行性。和动作一样，判定可以可以出现在文法规则的任意位置，但是只有出现在备选分支左侧的判定才具备影响分支预测的能力。</p>
<h4 id="进行带判定的语法分析决策"><a href="#进行带判定的语法分析决策" class="headerlink" title="进行带判定的语法分析决策"></a>进行带判定的语法分析决策</h4><p>ANTLR的通用决策机制是在所有的可行备选分支中选择，忽略那些在当前结果为假值的判定所守护的备选分支(可行的备选分支指的是匹配当前输入的备选分支)。如果剩余的备选分支多于一个，那么语法分析器就选择在决策中位置靠前的那个。</p>
<p>假设有一种C++语言的变体，其中的数组引用可以用圆括号代替方括号。如果仅仅对其中的一个备选分支应用判定，那么expr规则仍会面临歧义性选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr:                ID &#x27;(&#x27; expr &#x27;)&#x27;  // 数组引用(ANTLR选择此条规则)</span><br><span class="line">    |    &#123;istype()&#125;? ID &#x27;(&#x27; expr &#x27;)&#x27; // 构造器风格的类型转换</span><br><span class="line">    |                ID &#x27;(&#x27; expr &#x27;)&#x27; // 函数调用</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>在上例中，三个分支都可以匹配输入<code>x(i)</code>。当x不是类型时，判定为假值，此时expr中可行的备选分支只剩下了第一个和第三个。ANTLR自动选择第一个来解决歧义问题。令ANTLR自行在多个备选分支中作出选择的原因是判定的数量太少.对于n个可行的备选分支，最好使用至少n-1个判定。换句话说，不要使用判定数量像expr一样过少。</p>
<p>语法分析器会遇到与单个选择相关联的多个判定。ANTLR能够在运行时将这些判定用合适的逻辑运算符连接起来，组成一个新的判定。</p>
<p>例如，在规则stat中，决策过程如下：将expr的备选分支上的判定用||连接，生成的结果用于守护stat的第二个备选分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stat: decl | expr;</span><br><span class="line">decl: ID ID;</span><br><span class="line">expr: &#123;istype()?&#125; ID &#x27;(&#x27; expr &#x27;)&#x27;  // 构造器风格的转换</span><br><span class="line">    | &#123;isfunc()?&#125; ID &#x27;(&#x27; expr &#x27;)&#x27;  // 函数调用</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>如果多个判定形成了一个序列，语法分析器会将它们用&amp;&amp;运算符连接起来。</p>
<h4 id="寻找可见的判定"><a href="#寻找可见的判定" class="headerlink" title="寻找可见的判定"></a>寻找可见的判定</h4><p>在预测过程中，语法分析器不会对动作或者词法符号引用之后的判定求值。</p>
<p>ANTLR对动作代码块中的内容一无所知，所以它必须假设任意判定都可能依赖动作中的副作用。设想一下，某段动作代码计算x的值，而另一个判定使用了x。在动作创建x之前就对该判定求值违背语法中指定的顺序。</p>
<p>更重要的是，语法分析器必须先决定匹配哪个备选分支，然后才能执行相应的动作。这是因为动作具有副作用，无法撤销打印输出之类的语句。</p>
<p>预测过程中也不能读取词法符号引用。读取词法符号引用具有副作用，会使得符号流向前流动一个符号。如果一个判定读取了当前的符号，整个符号流就会失去同步。</p>
<p>stat中的决策无法对这些判定求值的原因在于，在stat的起始位置，当前的词法符号是一个左花括号。为了保持语义，ANTLR不会在该决策过程中对判定求值。</p>
<p>可见的判定(visible predicate)是指那些预测过程中，在动作或者词法符号之前的判定。预测过程忽略不可见的判定，把它们当作不存在。</p>
<p>在某些罕见情况下，语法分析器不能使用判定，即使它对于特定的决策过程是可见的。</p>
<h4 id="使用上下文相关判定"><a href="#使用上下文相关判定" class="headerlink" title="使用上下文相关判定"></a>使用上下文相关判定</h4><p>一个依赖于周围规则的参数或者局部变量的判定称为上下文相关判定(context-dependent predicate)。显然，只能在它们被定义的规则中对它们求值。例如，在下列的prog中对上下文相关判定{$i&lt;=5}? 求值是没有意义的。局部变量$i并没有在prog中定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prog: vec5</span><br><span class="line">    | ...</span><br><span class="line">    ;</span><br><span class="line">vec5</span><br><span class="line">locals [int i = 1]</span><br><span class="line">    : ( &#123;$i&lt;=5&#125;? INT &#123;$i++;&#125; )* // 匹配5个INT</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>ANTLR忽略那些无法在正确的上下文中求值的上下文相关判定。通常情况下，正确的上下文就是定义该判定的规则，但是某些时候，语法分析器即使在同一条规则中也无法对上下文相关判定求值。这些情况的检测是在运行时由自适应LL(*)预测完成的。</p>
<p>例如，stat规则中，可选的else分支子规则使得stat规则结束，语法分析器返回调用它的prog规则继续寻找符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prog: stat+; </span><br><span class="line">stat</span><br><span class="line">locals [int i = 0]</span><br><span class="line">    : &#123;$i == 0&#125;? &#x27;if&#x27; expr &#x27;then&#x27; stat &#123;$i = 5;&#125; (&#x27;else&#x27; stat)?</span><br><span class="line">    | &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>预测过程试图在if语句后寻找除else子句之外的内容。由于同行输入中可能包含多个stat，else可选分支的预测流程重新返回了stat。在下一个stat的处理过程中，它生成了一份新的$i拷贝，其值为0，而非5。此时，ANTLR忽略上下文相关判定{$i==0}，因为它知道语法分析器已经不在原先的stat调用中了。判定过程面对的是一个不同版本的$i，所以语法分析器不能对它求值。</p>
<p>有关词法分析器中判定的细节与之大致相同，除了一些例外：词法规则不能包含参数和局部变量。将在下一节详细讲述有所与词法分析器相关的内容。</p>
<h4 id="词法规则中的判定"><a href="#词法规则中的判定" class="headerlink" title="词法规则中的判定"></a>词法规则中的判定</h4><p>在文法规则中，判定必须出现在备选分支的左侧，以辅助对备选分支的预测过程。然而，在词法分析器中，判定必须出现在词法规则的右侧，因为词法分析器在看到一个词法符号的全部文本后才会选择合适的规则。原则上，词法规则中的判定可以出现在规则中的任何位置。不过，某些位置会比其他位置更有效率，ANTLR不保证最优位置。即使在单词法符号匹配的过程中，规则中的一个判定也可能被执行多次。可以在每条词法规则中嵌入多个判定，它们会在词法规则匹配并到达它们时被求值。</p>
<p>简单而言，词法分析器的目标是选择匹配最多输入字符的规则。在每个字符前，词法分析器都会检查当前还有哪些规则可用。最终，应当只有一条规则保持可用状态。此时，词法分析器就根据该规则的词法符号类型以及自己匹配到的文本，创建一个词法符号对象。</p>
<p>有些时候，词法分析器面对的可用规则会多一条。例如，输入enum能够匹配ENUM规则和ID规则。如果enum的下一个字符是空格。那么二者都可以成立。词法分析器解决这样的歧义性的方法是选择位置靠前的那条可行规则。这就是必须将关键字的规则放置在匹配标识符的规则之前的原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENUM : &#x27;enum&#x27; ;</span><br><span class="line">ID   : [a-z]+ ;</span><br></pre></td></tr></table></figure>

<p>不过，如果enum的下一个字符是字母，那么就只有ID是可用的了。</p>
<p>判定的的动作远离是修改可行词法规则的集合。当词法分析器遇到一个值为假的判定时，和语法分析器一样，它会关闭该判定对应的规则。</p>
<p>和语法判定一样，词法判定也不能依赖于词法动作的副作用。这是因为，动作是在词法分析器成功选定规则之后执行的，而判定是规则选择过程的一部分，它们不能依赖于动作的副作用。在词法规则中，动作必须出现在判定之后。例如，下面是另外一种在词法分析器中匹配enum关键字的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENUM : [a-z]+ &#123;getText().equals(&quot;enum&quot;)&#125;?</span><br><span class="line">       &#123;System.out.println(&quot;enum!&quot;);&#125;</span><br><span class="line">ID   : [a-z]+ &#123;System.out.println(&quot;ID &quot; + getText());&#125;</span><br><span class="line">     ;</span><br></pre></td></tr></table></figure>

<p>ENUM中的打印动作出现在末尾，只有当前输入匹配<code>[a-z]+</code>和判定为真时，它才会被执行。</p>
<h3 id="ANTLR-选项options"><a href="#ANTLR-选项options" class="headerlink" title="ANTLR 选项options"></a>ANTLR 选项options</h3><p>有许多语法元素和规则元素级别的选项可被设定（当前，暂时还没有规则选项）。它们能够改变ANTLR根据语法生成代码的方式。通用形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options &#123;name1=value1;...nameN=valueN;&#125; // 与目标语言的语法无关</span><br></pre></td></tr></table></figure>

<p>其中的value可以是标识符、全限定标识符(如a.b.c)、字符串、花括号包围的多行字符串，以及整数。</p>
<h4 id="语法选项"><a href="#语法选项" class="headerlink" title="语法选项"></a>语法选项</h4><p>所有的语法都可以使用下列选项。在混合语法中，除language之外的所有选项都只和生成的语法分析器相关。选项的设定方式是通过在语法文件中使用之前介绍的options，或者使用ANTLR命令行的-D参数传入。下面的例子展示了这两种方法的使用，需要注意的是：-D参数会覆盖语法中的options：</p>
<ul>
<li><strong>superClass</strong>-设定生成的语法分析器或词法分析器的父类。对于混合语法，它设定语法分析器的父类</li>
<li><strong>language</strong>-如果可行的话，生成指定语言的代码。</li>
<li><strong>tokenVocab</strong>-在遇到文件中的词法符号时，ANTLR将词法符号的类型赋予它们。如果需要使用不同的词法符号值，例如独立的词法分析器，可以使用此选项令ANTLR使用指定的”.tokens”文件。ANTLR会为每个语法生成一个”.tokens”文件。</li>
<li><strong>TokenLabelType</strong>-在生成词法符号对象时，ANTLR通常使用Token类型。如果希望传给自定义的语法分析器和词法分析器一个能够生成自定义词法符号的TokenFactory，应当将这个选项的值设为该类型。这样可以保证上下文对象清楚地知道字段和方法的返回值类型。</li>
</ul>
<h4 id="规则选项"><a href="#规则选项" class="headerlink" title="规则选项"></a>规则选项</h4><p>当前，还没有有效的规则级别的选项，不过ANTLR仍然支持下列语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rulename</span><br><span class="line">options &#123;...&#125;</span><br><span class="line">    :    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h4 id="规则元素选项"><a href="#规则元素选项" class="headerlink" title="规则元素选项"></a>规则元素选项</h4><p>词法符号选项的形式是<code>T&lt;name=value&gt;</code>,唯一可用的词法符号选项是<strong>assoc</strong>,它的可行值是left和right。下例示出了左递归表达式规则指定的<code>^</code>幂运算符的词法符号选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar ExprLR;</span><br><span class="line"></span><br><span class="line">expr : expr &#x27;^&#x27;&lt;assoc=right&gt; expr</span><br><span class="line">     | expr &#x27;*&#x27; expr</span><br><span class="line">     | expr &#x27;+&#x27; expr</span><br><span class="line">     | INT</span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">INT  : &#x27;0&#x27; .. &#x27;9&#x27;</span><br><span class="line">WS   : [ \n]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<p>语义判定也能接收选项，每个“捕获失败的语义判定”能够接收一个选项。唯一可用的选项是fail选项，它的值可以是双引号包围的字符串常量值，也可以是求值结果为字符串的动作。该字符串，或者说动作的结果字符串应当是相应判定失败后输出的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ints[int max]</span><br><span class="line">locals [int i = 1]</span><br><span class="line">    : INT (&#x27;,&#x27; &#123;$i++;&#125; &#123;$i&lt;=$max&#125;?&lt;fail=&#123;&quot;exceeded max &quot;+$max&#125;&gt; INT )*</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>当判定失败时，动作可以在执行一个函数的同时返回字符串，如:<code>&#123;...&#125;? &lt;fail=&#123;doSomething-AndReturnAString()&#125;&gt;</code></p>
<h4 id="ANTLR命令行参数"><a href="#ANTLR命令行参数" class="headerlink" title="ANTLR命令行参数"></a>ANTLR命令行参数</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ANTLR Parser Generator  Version <span class="number">4</span>.<span class="number">8</span></span><br><span class="line"> -o ___              specify output directory where all output is generated 指定所有的生成文件的输出位置</span><br><span class="line"> -lib ___            specify location of grammars, tokens files  指定语法和tokens文件的位置</span><br><span class="line"> -atn                generate rule augmented transition network diagrams 生成规则增强转移网络图</span><br><span class="line"> -encoding ___       specify grammar file encoding; e.g., euc-jp 指定语法文件的编码，例如euc-jp</span><br><span class="line"> -message-<span class="built_in">format</span> ___ specify output style <span class="keyword">for</span> messages <span class="keyword">in</span> antlr, gnu, vs2005 指定消息的输出风格：antlr/gun/vs2005</span><br><span class="line"> -long-messages      show exception details when available <span class="keyword">for</span> errors and warnings  </span><br><span class="line"> -listener           generate parse <span class="built_in">tree</span> listener (default) 生成语法分析树监听器</span><br><span class="line"> -no-listener        don&#x27;t generate parse <span class="built_in">tree</span> listener 不生成语法分析树监听器</span><br><span class="line"> -visitor            generate parse <span class="built_in">tree</span> visitor 生成语法分析树访问器</span><br><span class="line"> -no-visitor         don&#x27;t generate parse <span class="built_in">tree</span> visitor 不生成语法分析树访问器(default)</span><br><span class="line"> -package ___        specify a package/namespace <span class="keyword">for</span> the generated code 指定生成代码的包</span><br><span class="line"> -depend             generate file dependencies 生成文件依赖</span><br><span class="line"> -D&lt;option&gt;=value    <span class="built_in">set</span>/override a grammar-level option 设定/覆盖一个语法级的选项</span><br><span class="line"> -Werror             treat warnings as errors 将警告当作错误处理</span><br><span class="line"> -XdbgST             launch StringTemplate visualizer on generated code 对生成的代码启动StringTemplate 可视化器</span><br><span class="line"> -XdbgSTWait         wait <span class="keyword">for</span> STViz to close before continuing </span><br><span class="line"> -Xforce-atn         use the ATN simulator <span class="keyword">for</span> all predictions 对所有的预测启动ATN模拟器</span><br><span class="line"> -Xlog               dump lots of logging info to antlr-timestamp.log 将详细日志保存为antlr-timestamp.log</span><br><span class="line"> -Xexact-output-<span class="built_in">dir</span>  all output goes into -o <span class="built_in">dir</span> regardless of paths/package</span><br></pre></td></tr></table></figure>

<h2 id="ANTLR4-示例"><a href="#ANTLR4-示例" class="headerlink" title="ANTLR4 示例"></a>ANTLR4 示例</h2><h3 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">grammar Math;</span><br><span class="line"></span><br><span class="line">@header&#123;package com.src.ANTLR4;&#125; </span><br><span class="line"></span><br><span class="line">prog : stat+;</span><br><span class="line"></span><br><span class="line">stat: expr NEWLINE          # printExpr</span><br><span class="line">    | ID &#x27;=&#x27; expr NEWLINE   # assign</span><br><span class="line">    | NEWLINE               # blank</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:  expr op=(&#x27;*&#x27;|&#x27;/&#x27;) expr   # MulDiv</span><br><span class="line">| expr op=(&#x27;+&#x27;|&#x27;-&#x27;) expr        # AddSub</span><br><span class="line">| INT                           # int</span><br><span class="line">| ID                            # id</span><br><span class="line">| &#x27;(&#x27; expr &#x27;)&#x27;                  # parens</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">MUL : &#x27;*&#x27; ; // assigns token name to &#x27;*&#x27; used above in grammar</span><br><span class="line">DIV : &#x27;/&#x27; ;</span><br><span class="line">ADD : &#x27;+&#x27; ;</span><br><span class="line">SUB : &#x27;-&#x27; ;</span><br><span class="line">ID : [a-zA-Z]+ ;</span><br><span class="line">INT : [0-9]+ ;</span><br><span class="line">NEWLINE:&#x27;\r&#x27;? &#x27;\n&#x27; ;</span><br><span class="line">WS : [ \t]+ -&gt; skip;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.src.antlr4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CommonTokenStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.ParseTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">input</span> <span class="operator">=</span> CharStreams.fromString(<span class="string">&quot;12*2+12\r\n&quot;</span>);</span><br><span class="line">        <span class="type">MathLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathLexer</span>(input);</span><br><span class="line">        <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        <span class="type">MathParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathParser</span>(tokens);</span><br><span class="line">        <span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.prog(); <span class="comment">// parse</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单C语言编译器"><a href="#简单C语言编译器" class="headerlink" title="简单C语言编译器"></a>简单C语言编译器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br></pre></td><td class="code"><pre><span class="line">grammar C;</span><br><span class="line"></span><br><span class="line">// 词法部分</span><br><span class="line">Identifier</span><br><span class="line">    :   [a-zA-Z_]</span><br><span class="line">        (   [a-zA-Z_]</span><br><span class="line">        |   [0-9]</span><br><span class="line">        )*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">Constant</span><br><span class="line">    :   IntegerConstant</span><br><span class="line">    |   FloatingConstant</span><br><span class="line">    |   CharacterConstant</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">IntegerConstant</span><br><span class="line">    :   DecimalConstant IntegerSuffix?</span><br><span class="line">    |   OctalConstant IntegerSuffix?</span><br><span class="line">    |   HexadecimalConstant IntegerSuffix?</span><br><span class="line">    |	BinaryConstant</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryConstant</span><br><span class="line">	:	&#x27;0&#x27; [bB] [0-1]+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DecimalConstant</span><br><span class="line">    :   NonzeroDigit Digit*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalConstant</span><br><span class="line">    :   &#x27;0&#x27; OctalDigit*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalConstant</span><br><span class="line">    :   HexadecimalPrefix HexadecimalDigit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalPrefix</span><br><span class="line">    :   &#x27;0&#x27; [xX]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">NonzeroDigit</span><br><span class="line">    :   [1-9]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalDigit</span><br><span class="line">    :   [0-7]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalDigit</span><br><span class="line">    :   [0-9a-fA-F]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">IntegerSuffix</span><br><span class="line">    :   UnsignedSuffix LongSuffix?</span><br><span class="line">    |   UnsignedSuffix LongLongSuffix</span><br><span class="line">    |   LongSuffix UnsignedSuffix?</span><br><span class="line">    |   LongLongSuffix UnsignedSuffix?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">UnsignedSuffix</span><br><span class="line">    :   [uU]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">LongSuffix</span><br><span class="line">    :   [lL]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">LongLongSuffix</span><br><span class="line">    :   &#x27;ll&#x27; | &#x27;LL&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">FloatingConstant</span><br><span class="line">    :   DecimalFloatingConstant</span><br><span class="line">    |   HexadecimalFloatingConstant</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DecimalFloatingConstant</span><br><span class="line">    :   FractionalConstant ExponentPart? FloatingSuffix?</span><br><span class="line">    |   DigitSequence ExponentPart FloatingSuffix?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalFloatingConstant</span><br><span class="line">    :   HexadecimalPrefix HexadecimalFractionalConstant BinaryExponentPart FloatingSuffix?</span><br><span class="line">    |   HexadecimalPrefix HexadecimalDigitSequence BinaryExponentPart FloatingSuffix?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">FractionalConstant</span><br><span class="line">    :   DigitSequence? &#x27;.&#x27; DigitSequence</span><br><span class="line">    |   DigitSequence &#x27;.&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ExponentPart</span><br><span class="line">    :   &#x27;e&#x27; Sign? DigitSequence</span><br><span class="line">    |   &#x27;E&#x27; Sign? DigitSequence</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">Sign</span><br><span class="line">    :   &#x27;+&#x27; | &#x27;-&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">DigitSequence</span><br><span class="line">    :   Digit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalFractionalConstant</span><br><span class="line">    :   HexadecimalDigitSequence? &#x27;.&#x27; HexadecimalDigitSequence</span><br><span class="line">    |   HexadecimalDigitSequence &#x27;.&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryExponentPart</span><br><span class="line">    :   &#x27;p&#x27; Sign? DigitSequence</span><br><span class="line">    |   &#x27;P&#x27; Sign? DigitSequence</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalDigitSequence</span><br><span class="line">    :   HexadecimalDigit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">FloatingSuffix</span><br><span class="line">    :   &#x27;f&#x27; | &#x27;l&#x27; | &#x27;F&#x27; | &#x27;L&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">CharacterConstant</span><br><span class="line">    :   &#x27;\&#x27;&#x27; CCharSequence &#x27;\&#x27;&#x27;</span><br><span class="line">    |   &#x27;L\&#x27;&#x27; CCharSequence &#x27;\&#x27;&#x27;</span><br><span class="line">    |   &#x27;u\&#x27;&#x27; CCharSequence &#x27;\&#x27;&#x27;</span><br><span class="line">    |   &#x27;U\&#x27;&#x27; CCharSequence &#x27;\&#x27;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">CCharSequence</span><br><span class="line">    :   CChar+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">CChar</span><br><span class="line">    :   ~[&#x27;\\\r\n]</span><br><span class="line">    |   EscapeSequence</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">EscapeSequence</span><br><span class="line">    :   SimpleEscapeSequence</span><br><span class="line">    |   OctalEscapeSequence</span><br><span class="line">    |   HexadecimalEscapeSequence</span><br><span class="line">    |   UniversalCharacterName</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">SimpleEscapeSequence</span><br><span class="line">    :   &#x27;\\&#x27; [&#x27;&quot;?abfnrtv\\]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalEscapeSequence</span><br><span class="line">    :   &#x27;\\&#x27; OctalDigit</span><br><span class="line">    |   &#x27;\\&#x27; OctalDigit OctalDigit</span><br><span class="line">    |   &#x27;\\&#x27; OctalDigit OctalDigit OctalDigit</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalEscapeSequence</span><br><span class="line">    :   &#x27;\\x&#x27; HexadecimalDigit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">StringLiteral</span><br><span class="line">    :   EncodingPrefix? &#x27;&quot;&#x27; SCharSequence? &#x27;&quot;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">EncodingPrefix</span><br><span class="line">    :   &#x27;u8&#x27;</span><br><span class="line">    |   &#x27;u&#x27;</span><br><span class="line">    |   &#x27;U&#x27;</span><br><span class="line">    |   &#x27;L&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">SCharSequence</span><br><span class="line">    :   SChar+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">SChar</span><br><span class="line">    :   ~[&quot;\\\r\n]</span><br><span class="line">    |   EscapeSequence</span><br><span class="line">    |   &#x27;\\\n&#x27;   // Added line</span><br><span class="line">    |   &#x27;\\\r\n&#x27; // Added line</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">ComplexDefine</span><br><span class="line">    :   &#x27;#&#x27; Whitespace? &#x27;define&#x27;  ~[#]*</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line">         </span><br><span class="line">IncludeDirective</span><br><span class="line">    :   &#x27;#&#x27; Whitespace? &#x27;include&#x27; Whitespace? ((&#x27;&quot;&#x27; ~[\r\n]* &#x27;&quot;&#x27;) | (&#x27;&lt;&#x27; ~[\r\n]* &#x27;&gt;&#x27; )) Whitespace? Newline</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">AsmBlock</span><br><span class="line">    :   &#x27;asm&#x27; ~&#x27;&#123;&#x27;* &#x27;&#123;&#x27; ~&#x27;&#125;&#x27;* &#x27;&#125;&#x27;</span><br><span class="line">	-&gt; skip</span><br><span class="line">    ;</span><br><span class="line">	</span><br><span class="line">// ignore the lines generated by c preprocessor                                   </span><br><span class="line">// sample line : &#x27;#line 1 &quot;/home/dm/files/dk1.h&quot; 1&#x27;                           </span><br><span class="line">LineAfterPreprocessing</span><br><span class="line">    :   &#x27;#line&#x27; Whitespace* ~[\r\n]*</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;  </span><br><span class="line"></span><br><span class="line">LineDirective</span><br><span class="line">    :   &#x27;#&#x27; Whitespace? DecimalConstant Whitespace? StringLiteral ~[\r\n]*</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">PragmaDirective</span><br><span class="line">    :   &#x27;#&#x27; Whitespace? &#x27;pragma&#x27; Whitespace ~[\r\n]*</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">Whitespace</span><br><span class="line">    :   [ \t]+</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">Newline</span><br><span class="line">    :   (   &#x27;\r&#x27; &#x27;\n&#x27;?</span><br><span class="line">        |   &#x27;\n&#x27;</span><br><span class="line">        )</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">BlockComment</span><br><span class="line">    :   &#x27;/*&#x27; .*? &#x27;*/&#x27;</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">LineComment</span><br><span class="line">    :   &#x27;//&#x27; ~[\r\n]*</span><br><span class="line">        -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">// 关键字和标识符</span><br><span class="line"></span><br><span class="line">Auto : &#x27;auto&#x27;;</span><br><span class="line">Break : &#x27;break&#x27;;</span><br><span class="line">Case : &#x27;case&#x27;;</span><br><span class="line">Char : &#x27;char&#x27;;</span><br><span class="line">Const : &#x27;const&#x27;;</span><br><span class="line">Continue : &#x27;continue&#x27;;</span><br><span class="line">Default : &#x27;default&#x27;;</span><br><span class="line">Do : &#x27;do&#x27;;</span><br><span class="line">Double : &#x27;double&#x27;;</span><br><span class="line">Else : &#x27;else&#x27;;</span><br><span class="line">Enum : &#x27;enum&#x27;;</span><br><span class="line">Extern : &#x27;extern&#x27;;</span><br><span class="line">Float : &#x27;float&#x27;;</span><br><span class="line">For : &#x27;for&#x27;;</span><br><span class="line">Goto : &#x27;goto&#x27;;</span><br><span class="line">If : &#x27;if&#x27;;</span><br><span class="line">Inline : &#x27;inline&#x27;;</span><br><span class="line">Int : &#x27;int&#x27;;</span><br><span class="line">Long : &#x27;long&#x27;;</span><br><span class="line">Register : &#x27;register&#x27;;</span><br><span class="line">Restrict : &#x27;restrict&#x27;;</span><br><span class="line">Return : &#x27;return&#x27;;</span><br><span class="line">Short : &#x27;short&#x27;;</span><br><span class="line">Signed : &#x27;signed&#x27;;</span><br><span class="line">Sizeof : &#x27;sizeof&#x27;;</span><br><span class="line">Static : &#x27;static&#x27;;</span><br><span class="line">Struct : &#x27;struct&#x27;;</span><br><span class="line">Switch : &#x27;switch&#x27;;</span><br><span class="line">Typedef : &#x27;typedef&#x27;;</span><br><span class="line">Union : &#x27;union&#x27;;</span><br><span class="line">Unsigned : &#x27;unsigned&#x27;;</span><br><span class="line">Void : &#x27;void&#x27;;</span><br><span class="line">Volatile : &#x27;volatile&#x27;;</span><br><span class="line">While : &#x27;while&#x27;;</span><br><span class="line"></span><br><span class="line">Alignas : &#x27;_Alignas&#x27;;</span><br><span class="line">Alignof : &#x27;_Alignof&#x27;;</span><br><span class="line">Atomic : &#x27;_Atomic&#x27;;</span><br><span class="line">Bool : &#x27;_Bool&#x27;;</span><br><span class="line">Complex : &#x27;_Complex&#x27;;</span><br><span class="line">Generic : &#x27;_Generic&#x27;;</span><br><span class="line">Imaginary : &#x27;_Imaginary&#x27;;</span><br><span class="line">Noreturn : &#x27;_Noreturn&#x27;;</span><br><span class="line">StaticAssert : &#x27;_Static_assert&#x27;;</span><br><span class="line">ThreadLocal : &#x27;_Thread_local&#x27;;</span><br><span class="line"></span><br><span class="line">LeftParen : &#x27;(&#x27;;</span><br><span class="line">RightParen : &#x27;)&#x27;;</span><br><span class="line">LeftBracket : &#x27;[&#x27;;</span><br><span class="line">RightBracket : &#x27;]&#x27;;</span><br><span class="line">LeftBrace : &#x27;&#123;&#x27;;</span><br><span class="line">RightBrace : &#x27;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">Less : &#x27;&lt;&#x27;;</span><br><span class="line">LessEqual : &#x27;&lt;=&#x27;;</span><br><span class="line">Greater : &#x27;&gt;&#x27;;</span><br><span class="line">GreaterEqual : &#x27;&gt;=&#x27;;</span><br><span class="line">LeftShift : &#x27;&lt;&lt;&#x27;;</span><br><span class="line">RightShift : &#x27;&gt;&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">Plus : &#x27;+&#x27;;</span><br><span class="line">PlusPlus : &#x27;++&#x27;;</span><br><span class="line">Minus : &#x27;-&#x27;;</span><br><span class="line">MinusMinus : &#x27;--&#x27;;</span><br><span class="line">Star : &#x27;*&#x27;;</span><br><span class="line">Div : &#x27;/&#x27;;</span><br><span class="line">Mod : &#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line">And : &#x27;&amp;&#x27;;</span><br><span class="line">Or : &#x27;|&#x27;;</span><br><span class="line">AndAnd : &#x27;&amp;&amp;&#x27;;</span><br><span class="line">OrOr : &#x27;||&#x27;;</span><br><span class="line">Caret : &#x27;^&#x27;;</span><br><span class="line">Not : &#x27;!&#x27;;</span><br><span class="line">Tilde : &#x27;~&#x27;;</span><br><span class="line"></span><br><span class="line">Question : &#x27;?&#x27;;</span><br><span class="line">Colon : &#x27;:&#x27;;</span><br><span class="line">Semi : &#x27;;&#x27;;</span><br><span class="line">Comma : &#x27;,&#x27;;</span><br><span class="line"></span><br><span class="line">Assign : &#x27;=&#x27;;</span><br><span class="line">// &#x27;*=&#x27; | &#x27;/=&#x27; | &#x27;%=&#x27; | &#x27;+=&#x27; | &#x27;-=&#x27; | &#x27;&lt;&lt;=&#x27; | &#x27;&gt;&gt;=&#x27; | &#x27;&amp;=&#x27; | &#x27;^=&#x27; | &#x27;|=&#x27;</span><br><span class="line">StarAssign : &#x27;*=&#x27;;</span><br><span class="line">DivAssign : &#x27;/=&#x27;;</span><br><span class="line">ModAssign : &#x27;%=&#x27;;</span><br><span class="line">PlusAssign : &#x27;+=&#x27;;</span><br><span class="line">MinusAssign : &#x27;-=&#x27;;</span><br><span class="line">LeftShiftAssign : &#x27;&lt;&lt;=&#x27;;</span><br><span class="line">RightShiftAssign : &#x27;&gt;&gt;=&#x27;;</span><br><span class="line">AndAssign : &#x27;&amp;=&#x27;;</span><br><span class="line">XorAssign : &#x27;^=&#x27;;</span><br><span class="line">OrAssign : &#x27;|=&#x27;;</span><br><span class="line"></span><br><span class="line">Equal : &#x27;==&#x27;;</span><br><span class="line">NotEqual : &#x27;!=&#x27;;</span><br><span class="line"></span><br><span class="line">Arrow : &#x27;-&gt;&#x27;;</span><br><span class="line">Dot : &#x27;.&#x27;;</span><br><span class="line">Ellipsis : &#x27;...&#x27;;</span><br><span class="line"></span><br><span class="line">// 以下是语法部分</span><br><span class="line">primaryExpression</span><br><span class="line">    :   Identifier</span><br><span class="line">    |   Constant</span><br><span class="line">    |   StringLiteral+</span><br><span class="line">    |   &#x27;(&#x27; expression &#x27;)&#x27;</span><br><span class="line">    |   genericSelection</span><br><span class="line">    |   &#x27;__extension__&#x27;? &#x27;(&#x27; compoundStatement &#x27;)&#x27; // Blocks (GCC extension)</span><br><span class="line">    |   &#x27;__builtin_va_arg&#x27; &#x27;(&#x27; unaryExpression &#x27;,&#x27; typeName &#x27;)&#x27;</span><br><span class="line">    |   &#x27;__builtin_offsetof&#x27; &#x27;(&#x27; typeName &#x27;,&#x27; unaryExpression &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">genericSelection</span><br><span class="line">    :   &#x27;_Generic&#x27; &#x27;(&#x27; assignmentExpression &#x27;,&#x27; genericAssocList &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">genericAssocList</span><br><span class="line">    :   genericAssociation</span><br><span class="line">    |   genericAssocList &#x27;,&#x27; genericAssociation</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">genericAssociation</span><br><span class="line">    :   typeName &#x27;:&#x27; assignmentExpression</span><br><span class="line">    |   &#x27;default&#x27; &#x27;:&#x27; assignmentExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">postfixExpression</span><br><span class="line">    :   primaryExpression</span><br><span class="line">    |   postfixExpression &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">    |   postfixExpression &#x27;(&#x27; argumentExpressionList? &#x27;)&#x27;</span><br><span class="line">    |   postfixExpression &#x27;.&#x27; Identifier</span><br><span class="line">    |   postfixExpression &#x27;-&gt;&#x27; Identifier</span><br><span class="line">    |   postfixExpression &#x27;++&#x27;</span><br><span class="line">    |   postfixExpression &#x27;--&#x27;</span><br><span class="line">    |   &#x27;(&#x27; typeName &#x27;)&#x27; &#x27;&#123;&#x27; initializerList &#x27;&#125;&#x27;</span><br><span class="line">    |   &#x27;(&#x27; typeName &#x27;)&#x27; &#x27;&#123;&#x27; initializerList &#x27;,&#x27; &#x27;&#125;&#x27;</span><br><span class="line">    |   &#x27;__extension__&#x27; &#x27;(&#x27; typeName &#x27;)&#x27; &#x27;&#123;&#x27; initializerList &#x27;&#125;&#x27;</span><br><span class="line">    |   &#x27;__extension__&#x27; &#x27;(&#x27; typeName &#x27;)&#x27; &#x27;&#123;&#x27; initializerList &#x27;,&#x27; &#x27;&#125;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">argumentExpressionList</span><br><span class="line">    :   assignmentExpression</span><br><span class="line">    |   argumentExpressionList &#x27;,&#x27; assignmentExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">unaryExpression</span><br><span class="line">    :   postfixExpression</span><br><span class="line">    |   &#x27;++&#x27; unaryExpression</span><br><span class="line">    |   &#x27;--&#x27; unaryExpression</span><br><span class="line">    |   unaryOperator castExpression</span><br><span class="line">    |   &#x27;sizeof&#x27; unaryExpression</span><br><span class="line">    |   &#x27;sizeof&#x27; &#x27;(&#x27; typeName &#x27;)&#x27;</span><br><span class="line">    |   &#x27;_Alignof&#x27; &#x27;(&#x27; typeName &#x27;)&#x27;</span><br><span class="line">    |   &#x27;&amp;&amp;&#x27; Identifier // GCC extension address of label</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">unaryOperator</span><br><span class="line">    :   &#x27;&amp;&#x27; | &#x27;*&#x27; | &#x27;+&#x27; | &#x27;-&#x27; | &#x27;~&#x27; | &#x27;!&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">castExpression</span><br><span class="line">    :   &#x27;(&#x27; typeName &#x27;)&#x27; castExpression</span><br><span class="line">    |   &#x27;__extension__&#x27; &#x27;(&#x27; typeName &#x27;)&#x27; castExpression</span><br><span class="line">    |   unaryExpression</span><br><span class="line">    |   DigitSequence // for</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">multiplicativeExpression</span><br><span class="line">    :   castExpression</span><br><span class="line">    |   multiplicativeExpression &#x27;*&#x27; castExpression</span><br><span class="line">    |   multiplicativeExpression &#x27;/&#x27; castExpression</span><br><span class="line">    |   multiplicativeExpression &#x27;%&#x27; castExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">additiveExpression</span><br><span class="line">    :   multiplicativeExpression</span><br><span class="line">    |   additiveExpression &#x27;+&#x27; multiplicativeExpression</span><br><span class="line">    |   additiveExpression &#x27;-&#x27; multiplicativeExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">shiftExpression</span><br><span class="line">    :   additiveExpression</span><br><span class="line">    |   shiftExpression &#x27;&lt;&lt;&#x27; additiveExpression</span><br><span class="line">    |   shiftExpression &#x27;&gt;&gt;&#x27; additiveExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">relationalExpression</span><br><span class="line">    :   shiftExpression</span><br><span class="line">    |   relationalExpression &#x27;&lt;&#x27; shiftExpression</span><br><span class="line">    |   relationalExpression &#x27;&gt;&#x27; shiftExpression</span><br><span class="line">    |   relationalExpression &#x27;&lt;=&#x27; shiftExpression</span><br><span class="line">    |   relationalExpression &#x27;&gt;=&#x27; shiftExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">equalityExpression</span><br><span class="line">    :   relationalExpression</span><br><span class="line">    |   equalityExpression &#x27;==&#x27; relationalExpression</span><br><span class="line">    |   equalityExpression &#x27;!=&#x27; relationalExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">andExpression</span><br><span class="line">    :   equalityExpression</span><br><span class="line">    |   andExpression &#x27;&amp;&#x27; equalityExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">exclusiveOrExpression</span><br><span class="line">    :   andExpression</span><br><span class="line">    |   exclusiveOrExpression &#x27;^&#x27; andExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">inclusiveOrExpression</span><br><span class="line">    :   exclusiveOrExpression</span><br><span class="line">    |   inclusiveOrExpression &#x27;|&#x27; exclusiveOrExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">logicalAndExpression</span><br><span class="line">    :   inclusiveOrExpression</span><br><span class="line">    |   logicalAndExpression &#x27;&amp;&amp;&#x27; inclusiveOrExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">logicalOrExpression</span><br><span class="line">    :   logicalAndExpression</span><br><span class="line">    |   logicalOrExpression &#x27;||&#x27; logicalAndExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">conditionalExpression</span><br><span class="line">    :   logicalOrExpression (&#x27;?&#x27; expression &#x27;:&#x27; conditionalExpression)?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignmentExpression</span><br><span class="line">    :   conditionalExpression</span><br><span class="line">    |   unaryExpression assignmentOperator assignmentExpression</span><br><span class="line">    |   DigitSequence // for</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignmentOperator</span><br><span class="line">    :   &#x27;=&#x27; | &#x27;*=&#x27; | &#x27;/=&#x27; | &#x27;%=&#x27; | &#x27;+=&#x27; | &#x27;-=&#x27; | &#x27;&lt;&lt;=&#x27; | &#x27;&gt;&gt;=&#x27; | &#x27;&amp;=&#x27; | &#x27;^=&#x27; | &#x27;|=&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expression</span><br><span class="line">    :   assignmentExpression</span><br><span class="line">    |   expression &#x27;,&#x27; assignmentExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">constantExpression</span><br><span class="line">    :   conditionalExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">declaration</span><br><span class="line">    :   declarationSpecifiers initDeclaratorList &#x27;;&#x27;</span><br><span class="line">	| 	declarationSpecifiers &#x27;;&#x27;</span><br><span class="line">    |   staticAssertDeclaration</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">declarationSpecifiers</span><br><span class="line">    :   declarationSpecifier+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">declarationSpecifiers2</span><br><span class="line">    :   declarationSpecifier+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">declarationSpecifier</span><br><span class="line">    :   storageClassSpecifier</span><br><span class="line">    |   typeSpecifier</span><br><span class="line">    |   typeQualifier</span><br><span class="line">    |   functionSpecifier</span><br><span class="line">    |   alignmentSpecifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">initDeclaratorList</span><br><span class="line">    :   initDeclarator</span><br><span class="line">    |   initDeclaratorList &#x27;,&#x27; initDeclarator</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">initDeclarator</span><br><span class="line">    :   declarator</span><br><span class="line">    |   declarator &#x27;=&#x27; initializer</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">storageClassSpecifier</span><br><span class="line">    :   &#x27;typedef&#x27;</span><br><span class="line">    |   &#x27;extern&#x27;</span><br><span class="line">    |   &#x27;static&#x27;</span><br><span class="line">    |   &#x27;_Thread_local&#x27;</span><br><span class="line">    |   &#x27;auto&#x27;</span><br><span class="line">    |   &#x27;register&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">typeSpecifier</span><br><span class="line">    :   (&#x27;void&#x27;</span><br><span class="line">    |   &#x27;char&#x27;</span><br><span class="line">    |   &#x27;short&#x27;</span><br><span class="line">    |   &#x27;int&#x27;</span><br><span class="line">    |   &#x27;long&#x27;</span><br><span class="line">    |   &#x27;float&#x27;</span><br><span class="line">    |   &#x27;double&#x27;</span><br><span class="line">    |   &#x27;signed&#x27;</span><br><span class="line">    |   &#x27;unsigned&#x27;</span><br><span class="line">    |   &#x27;_Bool&#x27;</span><br><span class="line">    |   &#x27;_Complex&#x27;</span><br><span class="line">    |   &#x27;__m128&#x27;</span><br><span class="line">    |   &#x27;__m128d&#x27;</span><br><span class="line">    |   &#x27;__m128i&#x27;)</span><br><span class="line">    |   &#x27;__extension__&#x27; &#x27;(&#x27; (&#x27;__m128&#x27; | &#x27;__m128d&#x27; | &#x27;__m128i&#x27;) &#x27;)&#x27;</span><br><span class="line">    |   atomicTypeSpecifier</span><br><span class="line">    |   structOrUnionSpecifier</span><br><span class="line">    |   enumSpecifier</span><br><span class="line">    |   typedefName</span><br><span class="line">    |   &#x27;__typeof__&#x27; &#x27;(&#x27; constantExpression &#x27;)&#x27; // GCC extension</span><br><span class="line">    |   typeSpecifier pointer</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">structOrUnionSpecifier</span><br><span class="line">    :   structOrUnion Identifier? &#x27;&#123;&#x27; structDeclarationList &#x27;&#125;&#x27;</span><br><span class="line">    |   structOrUnion Identifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">structOrUnion</span><br><span class="line">    :   &#x27;struct&#x27;</span><br><span class="line">    |   &#x27;union&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">structDeclarationList</span><br><span class="line">    :   structDeclaration</span><br><span class="line">    |   structDeclarationList structDeclaration</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">structDeclaration</span><br><span class="line">    :   specifierQualifierList structDeclaratorList? &#x27;;&#x27;</span><br><span class="line">    |   staticAssertDeclaration</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">specifierQualifierList</span><br><span class="line">    :   typeSpecifier specifierQualifierList?</span><br><span class="line">    |   typeQualifier specifierQualifierList?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">structDeclaratorList</span><br><span class="line">    :   structDeclarator</span><br><span class="line">    |   structDeclaratorList &#x27;,&#x27; structDeclarator</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">structDeclarator</span><br><span class="line">    :   declarator</span><br><span class="line">    |   declarator? &#x27;:&#x27; constantExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">enumSpecifier</span><br><span class="line">    :   &#x27;enum&#x27; Identifier? &#x27;&#123;&#x27; enumeratorList &#x27;&#125;&#x27;</span><br><span class="line">    |   &#x27;enum&#x27; Identifier? &#x27;&#123;&#x27; enumeratorList &#x27;,&#x27; &#x27;&#125;&#x27;</span><br><span class="line">    |   &#x27;enum&#x27; Identifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">enumeratorList</span><br><span class="line">    :   enumerator</span><br><span class="line">    |   enumeratorList &#x27;,&#x27; enumerator</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">enumerator</span><br><span class="line">    :   enumerationConstant</span><br><span class="line">    |   enumerationConstant &#x27;=&#x27; constantExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">enumerationConstant</span><br><span class="line">    :   Identifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">atomicTypeSpecifier</span><br><span class="line">    :   &#x27;_Atomic&#x27; &#x27;(&#x27; typeName &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">typeQualifier</span><br><span class="line">    :   &#x27;const&#x27;</span><br><span class="line">    |   &#x27;restrict&#x27;</span><br><span class="line">    |   &#x27;volatile&#x27;</span><br><span class="line">    |   &#x27;_Atomic&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">functionSpecifier</span><br><span class="line">    :   (&#x27;inline&#x27;</span><br><span class="line">    |   &#x27;_Noreturn&#x27;</span><br><span class="line">    |   &#x27;__inline__&#x27; // GCC extension</span><br><span class="line">    |   &#x27;__stdcall&#x27;)</span><br><span class="line">    |   gccAttributeSpecifier</span><br><span class="line">    |   &#x27;__declspec&#x27; &#x27;(&#x27; Identifier &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">alignmentSpecifier</span><br><span class="line">    :   &#x27;_Alignas&#x27; &#x27;(&#x27; typeName &#x27;)&#x27;</span><br><span class="line">    |   &#x27;_Alignas&#x27; &#x27;(&#x27; constantExpression &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">declarator</span><br><span class="line">    :   pointer? directDeclarator gccDeclaratorExtension*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">directDeclarator</span><br><span class="line">    :   Identifier</span><br><span class="line">    |   &#x27;(&#x27; declarator &#x27;)&#x27;</span><br><span class="line">    |   directDeclarator &#x27;[&#x27; typeQualifierList? assignmentExpression? &#x27;]&#x27;</span><br><span class="line">    |   directDeclarator &#x27;[&#x27; &#x27;static&#x27; typeQualifierList? assignmentExpression &#x27;]&#x27;</span><br><span class="line">    |   directDeclarator &#x27;[&#x27; typeQualifierList &#x27;static&#x27; assignmentExpression &#x27;]&#x27;</span><br><span class="line">    |   directDeclarator &#x27;[&#x27; typeQualifierList? &#x27;*&#x27; &#x27;]&#x27;</span><br><span class="line">    |   directDeclarator &#x27;(&#x27; parameterTypeList &#x27;)&#x27;</span><br><span class="line">    |   directDeclarator &#x27;(&#x27; identifierList? &#x27;)&#x27;</span><br><span class="line">    |   Identifier &#x27;:&#x27; DigitSequence  // bit field</span><br><span class="line">    |   &#x27;(&#x27; typeSpecifier? pointer directDeclarator &#x27;)&#x27; // function pointer like: (__cdecl *f)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">gccDeclaratorExtension</span><br><span class="line">    :   &#x27;__asm&#x27; &#x27;(&#x27; StringLiteral+ &#x27;)&#x27;</span><br><span class="line">    |   gccAttributeSpecifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">gccAttributeSpecifier</span><br><span class="line">    :   &#x27;__attribute__&#x27; &#x27;(&#x27; &#x27;(&#x27; gccAttributeList &#x27;)&#x27; &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">gccAttributeList</span><br><span class="line">    :   gccAttribute (&#x27;,&#x27; gccAttribute)*</span><br><span class="line">    |   // empty</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">gccAttribute</span><br><span class="line">    :   ~(&#x27;,&#x27; | &#x27;(&#x27; | &#x27;)&#x27;) // relaxed def for &quot;identifier or reserved word&quot;</span><br><span class="line">        (&#x27;(&#x27; argumentExpressionList? &#x27;)&#x27;)?</span><br><span class="line">    |   // empty</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">nestedParenthesesBlock</span><br><span class="line">    :   (   ~(&#x27;(&#x27; | &#x27;)&#x27;)</span><br><span class="line">        |   &#x27;(&#x27; nestedParenthesesBlock &#x27;)&#x27;</span><br><span class="line">        )*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">pointer</span><br><span class="line">    :   &#x27;*&#x27; typeQualifierList?</span><br><span class="line">    |   &#x27;*&#x27; typeQualifierList? pointer</span><br><span class="line">    |   &#x27;^&#x27; typeQualifierList? // Blocks language extension</span><br><span class="line">    |   &#x27;^&#x27; typeQualifierList? pointer // Blocks language extension</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">typeQualifierList</span><br><span class="line">    :   typeQualifier</span><br><span class="line">    |   typeQualifierList typeQualifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">parameterTypeList</span><br><span class="line">    :   parameterList</span><br><span class="line">    |   parameterList &#x27;,&#x27; &#x27;...&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">parameterList</span><br><span class="line">    :   parameterDeclaration</span><br><span class="line">    |   parameterList &#x27;,&#x27; parameterDeclaration</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">parameterDeclaration</span><br><span class="line">    :   declarationSpecifiers declarator</span><br><span class="line">    |   declarationSpecifiers2 abstractDeclarator?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">identifierList</span><br><span class="line">    :   Identifier</span><br><span class="line">    |   identifierList &#x27;,&#x27; Identifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">typeName</span><br><span class="line">    :   specifierQualifierList abstractDeclarator?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">abstractDeclarator</span><br><span class="line">    :   pointer</span><br><span class="line">    |   pointer? directAbstractDeclarator gccDeclaratorExtension*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">directAbstractDeclarator</span><br><span class="line">    :   &#x27;(&#x27; abstractDeclarator &#x27;)&#x27; gccDeclaratorExtension*</span><br><span class="line">    |   &#x27;[&#x27; typeQualifierList? assignmentExpression? &#x27;]&#x27;</span><br><span class="line">    |   &#x27;[&#x27; &#x27;static&#x27; typeQualifierList? assignmentExpression &#x27;]&#x27;</span><br><span class="line">    |   &#x27;[&#x27; typeQualifierList &#x27;static&#x27; assignmentExpression &#x27;]&#x27;</span><br><span class="line">    |   &#x27;[&#x27; &#x27;*&#x27; &#x27;]&#x27;</span><br><span class="line">    |   &#x27;(&#x27; parameterTypeList? &#x27;)&#x27; gccDeclaratorExtension*</span><br><span class="line">    |   directAbstractDeclarator &#x27;[&#x27; typeQualifierList? assignmentExpression? &#x27;]&#x27;</span><br><span class="line">    |   directAbstractDeclarator &#x27;[&#x27; &#x27;static&#x27; typeQualifierList? assignmentExpression &#x27;]&#x27;</span><br><span class="line">    |   directAbstractDeclarator &#x27;[&#x27; typeQualifierList &#x27;static&#x27; assignmentExpression &#x27;]&#x27;</span><br><span class="line">    |   directAbstractDeclarator &#x27;[&#x27; &#x27;*&#x27; &#x27;]&#x27;</span><br><span class="line">    |   directAbstractDeclarator &#x27;(&#x27; parameterTypeList? &#x27;)&#x27; gccDeclaratorExtension*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">typedefName</span><br><span class="line">    :   Identifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">initializer</span><br><span class="line">    :   assignmentExpression</span><br><span class="line">    |   &#x27;&#123;&#x27; initializerList &#x27;&#125;&#x27;</span><br><span class="line">    |   &#x27;&#123;&#x27; initializerList &#x27;,&#x27; &#x27;&#125;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">initializerList</span><br><span class="line">    :   designation? initializer</span><br><span class="line">    |   initializerList &#x27;,&#x27; designation? initializer</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">designation</span><br><span class="line">    :   designatorList &#x27;=&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">designatorList</span><br><span class="line">    :   designator</span><br><span class="line">    |   designatorList designator</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">designator</span><br><span class="line">    :   &#x27;[&#x27; constantExpression &#x27;]&#x27;</span><br><span class="line">    |   &#x27;.&#x27; Identifier</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">staticAssertDeclaration</span><br><span class="line">    :   &#x27;_Static_assert&#x27; &#x27;(&#x27; constantExpression &#x27;,&#x27; StringLiteral+ &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">statement</span><br><span class="line">    :   labeledStatement</span><br><span class="line">    |   compoundStatement</span><br><span class="line">    |   expressionStatement</span><br><span class="line">    |   selectionStatement</span><br><span class="line">    |   iterationStatement</span><br><span class="line">    |   jumpStatement</span><br><span class="line">    |   (&#x27;__asm&#x27; | &#x27;__asm__&#x27;) (&#x27;volatile&#x27; | &#x27;__volatile__&#x27;) &#x27;(&#x27; (logicalOrExpression (&#x27;,&#x27; logicalOrExpression)*)? (&#x27;:&#x27; (logicalOrExpression (&#x27;,&#x27; logicalOrExpression)*)?)* &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">labeledStatement</span><br><span class="line">    :   Identifier &#x27;:&#x27; statement</span><br><span class="line">    |   &#x27;case&#x27; constantExpression &#x27;:&#x27; statement</span><br><span class="line">    |   &#x27;default&#x27; &#x27;:&#x27; statement</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">compoundStatement</span><br><span class="line">    :   &#x27;&#123;&#x27; blockItemList? &#x27;&#125;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">blockItemList</span><br><span class="line">    :   blockItem</span><br><span class="line">    |   blockItemList blockItem</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">blockItem</span><br><span class="line">    :   statement</span><br><span class="line">    |   declaration</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expressionStatement</span><br><span class="line">    :   expression? &#x27;;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">selectionStatement</span><br><span class="line">    :   &#x27;if&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statement (&#x27;else&#x27; statement)?</span><br><span class="line">    |   &#x27;switch&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statement</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">iterationStatement</span><br><span class="line">    :   While &#x27;(&#x27; expression &#x27;)&#x27; statement</span><br><span class="line">    |   Do statement While &#x27;(&#x27; expression &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">    |   For &#x27;(&#x27; forCondition &#x27;)&#x27; statement</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">//    |   &#x27;for&#x27; &#x27;(&#x27; expression? &#x27;;&#x27; expression?  &#x27;;&#x27; forUpdate? &#x27;)&#x27; statement</span><br><span class="line">//    |   For &#x27;(&#x27; declaration  expression? &#x27;;&#x27; expression? &#x27;)&#x27; statement</span><br><span class="line"></span><br><span class="line">forCondition</span><br><span class="line">	:   forDeclaration &#x27;;&#x27; forExpression? &#x27;;&#x27; forExpression?</span><br><span class="line">	|   expression? &#x27;;&#x27; forExpression? &#x27;;&#x27; forExpression?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">forDeclaration</span><br><span class="line">    :   declarationSpecifiers initDeclaratorList</span><br><span class="line">	| 	declarationSpecifiers</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">forExpression</span><br><span class="line">    :   assignmentExpression</span><br><span class="line">    |   forExpression &#x27;,&#x27; assignmentExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">jumpStatement</span><br><span class="line">    :   &#x27;goto&#x27; Identifier &#x27;;&#x27;</span><br><span class="line">    |   &#x27;continue&#x27; &#x27;;&#x27;</span><br><span class="line">    |   &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">    |   &#x27;return&#x27; expression? &#x27;;&#x27;</span><br><span class="line">    |   &#x27;goto&#x27; unaryExpression &#x27;;&#x27; // GCC extension</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">compilationUnit</span><br><span class="line">    :   translationUnit? EOF</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">translationUnit</span><br><span class="line">    :   externalDeclaration</span><br><span class="line">    |   translationUnit externalDeclaration</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">externalDeclaration</span><br><span class="line">    :   functionDefinition</span><br><span class="line">    |   declaration</span><br><span class="line">    |   &#x27;;&#x27; // stray ;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">functionDefinition</span><br><span class="line">    :   declarationSpecifiers? declarator declarationList? compoundStatement</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">declarationList</span><br><span class="line">    :   declaration</span><br><span class="line">    |   declarationList declaration</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<h3 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br></pre></td><td class="code"><pre><span class="line">grammar Java9;</span><br><span class="line"></span><br><span class="line">// 关键字</span><br><span class="line"></span><br><span class="line">ABSTRACT : &#x27;abstract&#x27;;</span><br><span class="line">ASSERT : &#x27;assert&#x27;;</span><br><span class="line">BOOLEAN : &#x27;boolean&#x27;;</span><br><span class="line">BREAK : &#x27;break&#x27;;</span><br><span class="line">BYTE : &#x27;byte&#x27;;</span><br><span class="line">CASE : &#x27;case&#x27;;</span><br><span class="line">CATCH : &#x27;catch&#x27;;</span><br><span class="line">CHAR : &#x27;char&#x27;;</span><br><span class="line">CLASS : &#x27;class&#x27;;</span><br><span class="line">CONST : &#x27;const&#x27;;</span><br><span class="line">CONTINUE : &#x27;continue&#x27;;</span><br><span class="line">DEFAULT : &#x27;default&#x27;;</span><br><span class="line">DO : &#x27;do&#x27;;</span><br><span class="line">DOUBLE : &#x27;double&#x27;;</span><br><span class="line">ELSE : &#x27;else&#x27;;</span><br><span class="line">ENUM : &#x27;enum&#x27;;</span><br><span class="line">EXTENDS : &#x27;extends&#x27;;</span><br><span class="line">FINAL : &#x27;final&#x27;;</span><br><span class="line">FINALLY : &#x27;finally&#x27;;</span><br><span class="line">FLOAT : &#x27;float&#x27;;</span><br><span class="line">FOR : &#x27;for&#x27;;</span><br><span class="line">IF : &#x27;if&#x27;;</span><br><span class="line">GOTO : &#x27;goto&#x27;;</span><br><span class="line">IMPLEMENTS : &#x27;implements&#x27;;</span><br><span class="line">IMPORT : &#x27;import&#x27;;</span><br><span class="line">INSTANCEOF : &#x27;instanceof&#x27;;</span><br><span class="line">INT : &#x27;int&#x27;;</span><br><span class="line">INTERFACE : &#x27;interface&#x27;;</span><br><span class="line">LONG : &#x27;long&#x27;;</span><br><span class="line">NATIVE : &#x27;native&#x27;;</span><br><span class="line">NEW : &#x27;new&#x27;;</span><br><span class="line">PACKAGE : &#x27;package&#x27;;</span><br><span class="line">PRIVATE : &#x27;private&#x27;;</span><br><span class="line">PROTECTED : &#x27;protected&#x27;;</span><br><span class="line">PUBLIC : &#x27;public&#x27;;</span><br><span class="line">RETURN : &#x27;return&#x27;;</span><br><span class="line">SHORT : &#x27;short&#x27;;</span><br><span class="line">STATIC : &#x27;static&#x27;;</span><br><span class="line">STRICTFP : &#x27;strictfp&#x27;;</span><br><span class="line">SUPER : &#x27;super&#x27;;</span><br><span class="line">SWITCH : &#x27;switch&#x27;;</span><br><span class="line">SYNCHRONIZED : &#x27;synchronized&#x27;;</span><br><span class="line">THIS : &#x27;this&#x27;;</span><br><span class="line">THROW : &#x27;throw&#x27;;</span><br><span class="line">THROWS : &#x27;throws&#x27;;</span><br><span class="line">TRANSIENT : &#x27;transient&#x27;;</span><br><span class="line">TRY : &#x27;try&#x27;;</span><br><span class="line">VOID : &#x27;void&#x27;;</span><br><span class="line">VOLATILE : &#x27;volatile&#x27;;</span><br><span class="line">WHILE : &#x27;while&#x27;;</span><br><span class="line">UNDER_SCORE : &#x27;_&#x27;;//Introduced in Java 9</span><br><span class="line"></span><br><span class="line">// 词法</span><br><span class="line"></span><br><span class="line">// 整数字面量</span><br><span class="line">IntegerLiteral</span><br><span class="line">	:	DecimalIntegerLiteral</span><br><span class="line">	|	HexIntegerLiteral</span><br><span class="line">	|	OctalIntegerLiteral</span><br><span class="line">	|	BinaryIntegerLiteral</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DecimalIntegerLiteral</span><br><span class="line">	:	DecimalNumeral IntegerTypeSuffix?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexIntegerLiteral</span><br><span class="line">	:	HexNumeral IntegerTypeSuffix?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalIntegerLiteral</span><br><span class="line">	:	OctalNumeral IntegerTypeSuffix?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryIntegerLiteral</span><br><span class="line">	:	BinaryNumeral IntegerTypeSuffix?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">IntegerTypeSuffix</span><br><span class="line">	:	[lL]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DecimalNumeral</span><br><span class="line">	:	&#x27;0&#x27;</span><br><span class="line">	|	NonZeroDigit (Digits? | Underscores Digits)</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">Digits</span><br><span class="line">	:	Digit (DigitsAndUnderscores? Digit)?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">Digit</span><br><span class="line">	:	&#x27;0&#x27;</span><br><span class="line">	|	NonZeroDigit</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">NonZeroDigit</span><br><span class="line">	:	[1-9]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DigitsAndUnderscores</span><br><span class="line">	:	DigitOrUnderscore+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DigitOrUnderscore</span><br><span class="line">	:	Digit</span><br><span class="line">	|	&#x27;_&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">Underscores</span><br><span class="line">	:	&#x27;_&#x27;+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexNumeral</span><br><span class="line">	:	&#x27;0&#x27; [xX] HexDigits</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexDigits</span><br><span class="line">	:	HexDigit (HexDigitsAndUnderscores? HexDigit)?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexDigit</span><br><span class="line">	:	[0-9a-fA-F]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexDigitsAndUnderscores</span><br><span class="line">	:	HexDigitOrUnderscore+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexDigitOrUnderscore</span><br><span class="line">	:	HexDigit</span><br><span class="line">	|	&#x27;_&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalNumeral</span><br><span class="line">	:	&#x27;0&#x27; Underscores? OctalDigits</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalDigits</span><br><span class="line">	:	OctalDigit (OctalDigitsAndUnderscores? OctalDigit)?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalDigit</span><br><span class="line">	:	[0-7]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalDigitsAndUnderscores</span><br><span class="line">	:	OctalDigitOrUnderscore+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalDigitOrUnderscore</span><br><span class="line">	:	OctalDigit</span><br><span class="line">	|	&#x27;_&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryNumeral</span><br><span class="line">	:	&#x27;0&#x27; [bB] BinaryDigits</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryDigits</span><br><span class="line">	:	BinaryDigit (BinaryDigitsAndUnderscores? BinaryDigit)?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryDigit</span><br><span class="line">	:	[01]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryDigitsAndUnderscores</span><br><span class="line">	:	BinaryDigitOrUnderscore+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryDigitOrUnderscore</span><br><span class="line">	:	BinaryDigit</span><br><span class="line">	|	&#x27;_&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// §3.10.2 Floating-Point Literals</span><br><span class="line"></span><br><span class="line">FloatingPointLiteral</span><br><span class="line">	:	DecimalFloatingPointLiteral</span><br><span class="line">	|	HexadecimalFloatingPointLiteral</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DecimalFloatingPointLiteral</span><br><span class="line">	:	Digits &#x27;.&#x27; Digits? ExponentPart? FloatTypeSuffix?</span><br><span class="line">	|	&#x27;.&#x27; Digits ExponentPart? FloatTypeSuffix?</span><br><span class="line">	|	Digits ExponentPart FloatTypeSuffix?</span><br><span class="line">	|	Digits FloatTypeSuffix</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ExponentPart</span><br><span class="line">	:	ExponentIndicator SignedInteger</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ExponentIndicator</span><br><span class="line">	:	[eE]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">SignedInteger</span><br><span class="line">	:	Sign? Digits</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">Sign</span><br><span class="line">	:	[+-]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">FloatTypeSuffix</span><br><span class="line">	:	[fFdD]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexadecimalFloatingPointLiteral</span><br><span class="line">	:	HexSignificand BinaryExponent FloatTypeSuffix?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexSignificand</span><br><span class="line">	:	HexNumeral &#x27;.&#x27;?</span><br><span class="line">	|	&#x27;0&#x27; [xX] HexDigits? &#x27;.&#x27; HexDigits</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryExponent</span><br><span class="line">	:	BinaryExponentIndicator SignedInteger</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">BinaryExponentIndicator</span><br><span class="line">	:	[pP]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// §3.10.3 Boolean Literals</span><br><span class="line"></span><br><span class="line">BooleanLiteral</span><br><span class="line">	:	&#x27;true&#x27;</span><br><span class="line">	|	&#x27;false&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// §3.10.4 Character Literals</span><br><span class="line"></span><br><span class="line">CharacterLiteral</span><br><span class="line">	:	&#x27;\&#x27;&#x27; SingleCharacter &#x27;\&#x27;&#x27;</span><br><span class="line">	|	&#x27;\&#x27;&#x27; EscapeSequence &#x27;\&#x27;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">SingleCharacter</span><br><span class="line">	:	~[&#x27;\\\r\n]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// §3.10.5 String Literals</span><br><span class="line"></span><br><span class="line">StringLiteral</span><br><span class="line">	:	&#x27;&quot;&#x27; StringCharacters? &#x27;&quot;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">StringCharacters</span><br><span class="line">	:	StringCharacter+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">StringCharacter</span><br><span class="line">	:	~[&quot;\\\r\n]</span><br><span class="line">	|	EscapeSequence</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// §3.10.6 Escape Sequences for Character and String Literals</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">EscapeSequence</span><br><span class="line">	:	&#x27;\\&#x27; [btnfr&quot;&#x27;\\]</span><br><span class="line">	|	OctalEscape</span><br><span class="line">    |   UnicodeEscape // This is not in the spec but prevents having to preprocess the input</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">OctalEscape</span><br><span class="line">	:	&#x27;\\&#x27; OctalDigit</span><br><span class="line">	|	&#x27;\\&#x27; OctalDigit OctalDigit</span><br><span class="line">	|	&#x27;\\&#x27; ZeroToThree OctalDigit OctalDigit</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ZeroToThree</span><br><span class="line">	:	[0-3]</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// This is not in the spec but prevents having to preprocess the input</span><br><span class="line">fragment</span><br><span class="line">UnicodeEscape</span><br><span class="line">    :   &#x27;\\&#x27; &#x27;u&#x27;+ HexDigit HexDigit HexDigit HexDigit</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">// §3.10.7 The Null Literal</span><br><span class="line"></span><br><span class="line">NullLiteral</span><br><span class="line">	:	&#x27;null&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// §3.11 Separators</span><br><span class="line"></span><br><span class="line">LPAREN : &#x27;(&#x27;;</span><br><span class="line">RPAREN : &#x27;)&#x27;;</span><br><span class="line">LBRACE : &#x27;&#123;&#x27;;</span><br><span class="line">RBRACE : &#x27;&#125;&#x27;;</span><br><span class="line">LBRACK : &#x27;[&#x27;;</span><br><span class="line">RBRACK : &#x27;]&#x27;;</span><br><span class="line">SEMI : &#x27;;&#x27;;</span><br><span class="line">COMMA : &#x27;,&#x27;;</span><br><span class="line">DOT : &#x27;.&#x27;;</span><br><span class="line">ELLIPSIS : &#x27;...&#x27;;</span><br><span class="line">AT : &#x27;@&#x27;;</span><br><span class="line">COLONCOLON : &#x27;::&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// §3.12 Operators</span><br><span class="line"></span><br><span class="line">ASSIGN : &#x27;=&#x27;;</span><br><span class="line">GT : &#x27;&gt;&#x27;;</span><br><span class="line">LT : &#x27;&lt;&#x27;;</span><br><span class="line">BANG : &#x27;!&#x27;;</span><br><span class="line">TILDE : &#x27;~&#x27;;</span><br><span class="line">QUESTION : &#x27;?&#x27;;</span><br><span class="line">COLON : &#x27;:&#x27;;</span><br><span class="line">ARROW : &#x27;-&gt;&#x27;;</span><br><span class="line">EQUAL : &#x27;==&#x27;;</span><br><span class="line">LE : &#x27;&lt;=&#x27;;</span><br><span class="line">GE : &#x27;&gt;=&#x27;;</span><br><span class="line">NOTEQUAL : &#x27;!=&#x27;;</span><br><span class="line">AND : &#x27;&amp;&amp;&#x27;;</span><br><span class="line">OR : &#x27;||&#x27;;</span><br><span class="line">INC : &#x27;++&#x27;;</span><br><span class="line">DEC : &#x27;--&#x27;;</span><br><span class="line">ADD : &#x27;+&#x27;;</span><br><span class="line">SUB : &#x27;-&#x27;;</span><br><span class="line">MUL : &#x27;*&#x27;;</span><br><span class="line">DIV : &#x27;/&#x27;;</span><br><span class="line">BITAND : &#x27;&amp;&#x27;;</span><br><span class="line">BITOR : &#x27;|&#x27;;</span><br><span class="line">CARET : &#x27;^&#x27;;</span><br><span class="line">MOD : &#x27;%&#x27;;</span><br><span class="line">//LSHIFT : &#x27;&lt;&lt;&#x27;;</span><br><span class="line">//RSHIFT : &#x27;&gt;&gt;&#x27;;</span><br><span class="line">//URSHIFT : &#x27;&gt;&gt;&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">ADD_ASSIGN : &#x27;+=&#x27;;</span><br><span class="line">SUB_ASSIGN : &#x27;-=&#x27;;</span><br><span class="line">MUL_ASSIGN : &#x27;*=&#x27;;</span><br><span class="line">DIV_ASSIGN : &#x27;/=&#x27;;</span><br><span class="line">AND_ASSIGN : &#x27;&amp;=&#x27;;</span><br><span class="line">OR_ASSIGN : &#x27;|=&#x27;;</span><br><span class="line">XOR_ASSIGN : &#x27;^=&#x27;;</span><br><span class="line">MOD_ASSIGN : &#x27;%=&#x27;;</span><br><span class="line">LSHIFT_ASSIGN : &#x27;&lt;&lt;=&#x27;;</span><br><span class="line">RSHIFT_ASSIGN : &#x27;&gt;&gt;=&#x27;;</span><br><span class="line">URSHIFT_ASSIGN : &#x27;&gt;&gt;&gt;=&#x27;;</span><br><span class="line"></span><br><span class="line">// §3.8 Identifiers (must appear after all keywords in the grammar)</span><br><span class="line"></span><br><span class="line">Identifier</span><br><span class="line">	:	JavaLetter JavaLetterOrDigit*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">JavaLetter</span><br><span class="line">	:	[a-zA-Z$_] // these are the &quot;java letters&quot; below 0x7F</span><br><span class="line">	|	// covers all characters above 0x7F which are not a surrogate</span><br><span class="line">		~[\u0000-\u007F\uD800-\uDBFF]</span><br><span class="line">		&#123;Character.isJavaIdentifierStart(_input.LA(-1))&#125;?</span><br><span class="line">	|	// covers UTF-16 surrogate pairs encodings for U+10000 to U+10FFFF</span><br><span class="line">		[\uD800-\uDBFF] [\uDC00-\uDFFF]</span><br><span class="line">		&#123;Character.isJavaIdentifierStart(Character.toCodePoint((char)_input.LA(-2), (char)_input.LA(-1)))&#125;?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">JavaLetterOrDigit</span><br><span class="line">	:	[a-zA-Z0-9$_] // these are the &quot;java letters or digits&quot; below 0x7F</span><br><span class="line">	|	// covers all characters above 0x7F which are not a surrogate</span><br><span class="line">		~[\u0000-\u007F\uD800-\uDBFF]</span><br><span class="line">		&#123;Character.isJavaIdentifierPart(_input.LA(-1))&#125;?</span><br><span class="line">	|	// covers UTF-16 surrogate pairs encodings for U+10000 to U+10FFFF</span><br><span class="line">		[\uD800-\uDBFF] [\uDC00-\uDFFF]</span><br><span class="line">		&#123;Character.isJavaIdentifierPart(Character.toCodePoint((char)_input.LA(-2), (char)_input.LA(-1)))&#125;?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Whitespace and comments</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">WS  :  [ \t\r\n\u000C]+ -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">COMMENT</span><br><span class="line">    :   &#x27;/*&#x27; .*? &#x27;*/&#x27; -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">LINE_COMMENT</span><br><span class="line">    :   &#x27;//&#x27; ~[\r\n]* -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">// 语法</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §3 (Lexical Structure)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 字面量类型</span><br><span class="line">literal</span><br><span class="line">	:	IntegerLiteral            // 整数：十进制，二进制，八进制，十六进制浮点数，相比于C语言整数可以加下划线</span><br><span class="line">	|	FloatingPointLiteral      // 浮点数：分为十进制和十六进制浮点数</span><br><span class="line">	|	BooleanLiteral            // 布尔类型</span><br><span class="line">	|	CharacterLiteral          // 字符字面量</span><br><span class="line">	|	StringLiteral             // 字符串字面量</span><br><span class="line">	|	NullLiteral               // 空类型</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §4 (Types, Values, and Variables) 类型，值，变量</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 原始类型</span><br><span class="line">primitiveType</span><br><span class="line">	:	annotation* numericType  // 注解</span><br><span class="line">	|	annotation* &#x27;boolean&#x27;    </span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 基本数值类型</span><br><span class="line">numericType</span><br><span class="line">	:	integralType</span><br><span class="line">	|	floatingPointType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 整数类型</span><br><span class="line">integralType</span><br><span class="line">	:	&#x27;byte&#x27;</span><br><span class="line">	|	&#x27;short&#x27;</span><br><span class="line">	|	&#x27;int&#x27;</span><br><span class="line">	|	&#x27;long&#x27;</span><br><span class="line">	|	&#x27;char&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 浮点类型</span><br><span class="line">floatingPointType</span><br><span class="line">	:	&#x27;float&#x27;</span><br><span class="line">	|	&#x27;double&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 引用类型</span><br><span class="line">referenceType</span><br><span class="line">	:	classOrInterfaceType      // 类或者接口类型</span><br><span class="line">	|	typeVariable              // 类型变量</span><br><span class="line">	|	arrayType                 // 数组类型</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*classOrInterfaceType</span><br><span class="line">	:	classType</span><br><span class="line">	|	interfaceType</span><br><span class="line">	;</span><br><span class="line">*/</span><br><span class="line">// 类或者接口类型</span><br><span class="line">classOrInterfaceType</span><br><span class="line">	:	(	classType_lfno_classOrInterfaceType</span><br><span class="line">		|	interfaceType_lfno_classOrInterfaceType</span><br><span class="line">		)</span><br><span class="line">		(	classType_lf_classOrInterfaceType</span><br><span class="line">		|	interfaceType_lf_classOrInterfaceType</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// class对象类型</span><br><span class="line">classType</span><br><span class="line">	:	annotation* identifier typeArguments?</span><br><span class="line">	|	classOrInterfaceType &#x27;.&#x27; annotation* identifier typeArguments?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类的.类或者接口类型</span><br><span class="line">classType_lf_classOrInterfaceType</span><br><span class="line">	:	&#x27;.&#x27; annotation* identifier typeArguments?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// .类或者接口类型</span><br><span class="line">classType_lfno_classOrInterfaceType</span><br><span class="line">	:	annotation* identifier typeArguments?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口类型</span><br><span class="line">interfaceType</span><br><span class="line">	:	classType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口的类的.类或者接口类型</span><br><span class="line">interfaceType_lf_classOrInterfaceType</span><br><span class="line">	:	classType_lf_classOrInterfaceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口的类的类或者接口类型</span><br><span class="line">interfaceType_lfno_classOrInterfaceType</span><br><span class="line">	:	classType_lfno_classOrInterfaceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型变量</span><br><span class="line">typeVariable</span><br><span class="line">	:	annotation* identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 数组类型</span><br><span class="line">arrayType</span><br><span class="line">	:	primitiveType dims</span><br><span class="line">	|	classOrInterfaceType dims</span><br><span class="line">	|	typeVariable dims</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 数组和多维数组</span><br><span class="line">dims</span><br><span class="line">	:	annotation* &#x27;[&#x27; &#x27;]&#x27; (annotation* &#x27;[&#x27; &#x27;]&#x27;)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型参数</span><br><span class="line">typeParameter</span><br><span class="line">	:	typeParameterModifier* identifier typeBound?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型参数修饰器</span><br><span class="line">typeParameterModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型约束</span><br><span class="line">typeBound</span><br><span class="line">	:	&#x27;extends&#x27; typeVariable</span><br><span class="line">	|	&#x27;extends&#x27; classOrInterfaceType additionalBound*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 附加类型约束</span><br><span class="line">additionalBound</span><br><span class="line">	:	&#x27;&amp;&#x27; interfaceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 泛型参数</span><br><span class="line">typeArguments</span><br><span class="line">	:	&#x27;&lt;&#x27; typeArgumentList &#x27;&gt;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型参数列表</span><br><span class="line">typeArgumentList</span><br><span class="line">	:	typeArgument (&#x27;,&#x27; typeArgument)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型参数</span><br><span class="line">typeArgument</span><br><span class="line">	:	referenceType   // 引用类型</span><br><span class="line">	|	wildcard        // Java泛型约束</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// Java泛型约束</span><br><span class="line">wildcard</span><br><span class="line">	:	annotation* &#x27;?&#x27; wildcardBounds?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// Java泛型约束类型</span><br><span class="line">wildcardBounds</span><br><span class="line">	:	&#x27;extends&#x27; referenceType</span><br><span class="line">	|	&#x27;super&#x27; referenceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §6 (Names)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 模块名称</span><br><span class="line">moduleName</span><br><span class="line">	:	identifier                 // 标识符</span><br><span class="line">	|	moduleName &#x27;.&#x27; identifier  // 带点的级联模块</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 包名称</span><br><span class="line">packageName</span><br><span class="line">	:	identifier</span><br><span class="line">	|	packageName &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型名称，单独的一个标识或者带包名的标识</span><br><span class="line">typeName</span><br><span class="line">	:	identifier</span><br><span class="line">	|	packageOrTypeName &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 带包名类型或者标识符类型</span><br><span class="line">packageOrTypeName</span><br><span class="line">	:	identifier</span><br><span class="line">	|	packageOrTypeName &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 表达式名称</span><br><span class="line">expressionName</span><br><span class="line">	:	identifier</span><br><span class="line">	|	ambiguousName &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法名称</span><br><span class="line">methodName</span><br><span class="line">	:	identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 模糊名称</span><br><span class="line">ambiguousName</span><br><span class="line">	:	identifier</span><br><span class="line">	|	ambiguousName &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §7 (Packages)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 完整的Java文件声明</span><br><span class="line">compilationUnit</span><br><span class="line">	:	ordinaryCompilation</span><br><span class="line">	|	modularCompilation</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 带Java类型的文件声明</span><br><span class="line">ordinaryCompilation</span><br><span class="line">	:	packageDeclaration? importDeclaration* typeDeclaration* EOF</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 模块</span><br><span class="line">modularCompilation</span><br><span class="line">	:	importDeclaration* moduleDeclaration</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 包声明</span><br><span class="line">packageDeclaration</span><br><span class="line">	:	packageModifier* &#x27;package&#x27; packageName &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 包名指示器</span><br><span class="line">packageModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// import语法</span><br><span class="line">importDeclaration</span><br><span class="line">	:	singleTypeImportDeclaration</span><br><span class="line">	|	typeImportOnDemandDeclaration</span><br><span class="line">	|	singleStaticImportDeclaration</span><br><span class="line">	|	staticImportOnDemandDeclaration   // 静态导入类</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 单类型导入</span><br><span class="line">singleTypeImportDeclaration</span><br><span class="line">	:	&#x27;import&#x27; typeName &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 导入整个包</span><br><span class="line">typeImportOnDemandDeclaration</span><br><span class="line">	:	&#x27;import&#x27; packageOrTypeName &#x27;.&#x27; &#x27;*&#x27; &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 单个方法静态导入</span><br><span class="line">singleStaticImportDeclaration</span><br><span class="line">	:	&#x27;import&#x27; &#x27;static&#x27; typeName &#x27;.&#x27; identifier &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 静态导入整个类型</span><br><span class="line">staticImportOnDemandDeclaration</span><br><span class="line">	:	&#x27;import&#x27; &#x27;static&#x27; typeName &#x27;.&#x27; &#x27;*&#x27; &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型声明 </span><br><span class="line">typeDeclaration</span><br><span class="line">	:	classDeclaration         // 类声明</span><br><span class="line">	|	interfaceDeclaration     // 接口声明</span><br><span class="line">	|	&#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 模块声明</span><br><span class="line">moduleDeclaration</span><br><span class="line">	:	annotation* &#x27;open&#x27;? &#x27;module&#x27; moduleName &#x27;&#123;&#x27; moduleDirective* &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">moduleDirective</span><br><span class="line">	:	&#x27;requires&#x27; requiresModifier* moduleName &#x27;;&#x27;</span><br><span class="line">	|	&#x27;exports&#x27; packageName (&#x27;to&#x27; moduleName (&#x27;,&#x27; moduleName)*)? &#x27;;&#x27;</span><br><span class="line">	|	&#x27;opens&#x27; packageName (&#x27;to&#x27; moduleName (&#x27;,&#x27; moduleName)*)? &#x27;;&#x27;</span><br><span class="line">	|	&#x27;uses&#x27; typeName &#x27;;&#x27;</span><br><span class="line">	|	&#x27;provides&#x27; typeName &#x27;with&#x27; typeName (&#x27;,&#x27; typeName)* &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// require指示器</span><br><span class="line">requiresModifier</span><br><span class="line">	:	&#x27;transitive&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §8 (Classes)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 类声明(普通类和枚举类型)</span><br><span class="line">classDeclaration</span><br><span class="line">	:	normalClassDeclaration     // 一般类声明</span><br><span class="line">	|	enumDeclaration            // 枚举声明   </span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般类声明，支持单类和多接口继承</span><br><span class="line">normalClassDeclaration</span><br><span class="line">	:	classModifier* &#x27;class&#x27; identifier typeParameters? superclass? superinterfaces? classBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类指示器</span><br><span class="line">classModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;protected&#x27;</span><br><span class="line">	|	&#x27;private&#x27;</span><br><span class="line">	|	&#x27;abstract&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	|	&#x27;final&#x27;</span><br><span class="line">	|	&#x27;strictfp&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 泛型参数</span><br><span class="line">typeParameters</span><br><span class="line">	:	&#x27;&lt;&#x27; typeParameterList &#x27;&gt;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 泛型参数列表</span><br><span class="line">typeParameterList</span><br><span class="line">	:	typeParameter (&#x27;,&#x27; typeParameter)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类继承</span><br><span class="line">superclass</span><br><span class="line">	:	&#x27;extends&#x27; classType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口继承</span><br><span class="line">superinterfaces</span><br><span class="line">	:	&#x27;implements&#x27; interfaceTypeList</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口类型列表</span><br><span class="line">interfaceTypeList</span><br><span class="line">	:	interfaceType (&#x27;,&#x27; interfaceType)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类本体</span><br><span class="line">classBody</span><br><span class="line">	:	&#x27;&#123;&#x27; classBodyDeclaration* &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类本体声明</span><br><span class="line">classBodyDeclaration</span><br><span class="line">	:	classMemberDeclaration   // 类成员声明</span><br><span class="line">	|	instanceInitializer      // 类块声明</span><br><span class="line">	|	staticInitializer        // 类静态块声明</span><br><span class="line">	|	constructorDeclaration   // 构造参数声明 </span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类成员声明</span><br><span class="line">classMemberDeclaration</span><br><span class="line">	:	fieldDeclaration</span><br><span class="line">	|	methodDeclaration</span><br><span class="line">	|	classDeclaration</span><br><span class="line">	|	interfaceDeclaration</span><br><span class="line">	|	&#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类成员声明</span><br><span class="line">fieldDeclaration</span><br><span class="line">	:	fieldModifier* unannType variableDeclaratorList &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类成员指示器</span><br><span class="line">fieldModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;protected&#x27;</span><br><span class="line">	|	&#x27;private&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	|	&#x27;final&#x27;</span><br><span class="line">	|	&#x27;transient&#x27;</span><br><span class="line">	|	&#x27;volatile&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量声明列表</span><br><span class="line">variableDeclaratorList</span><br><span class="line">	:	variableDeclarator (&#x27;,&#x27; variableDeclarator)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量声明（赋值是可选的）</span><br><span class="line">variableDeclarator</span><br><span class="line">	:	variableDeclaratorId (&#x27;=&#x27; variableInitializer)?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量声明Id，包括单类型和数组类型</span><br><span class="line">variableDeclaratorId</span><br><span class="line">	:	identifier dims?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量初始化类型，包括简单表达式和数组初始化</span><br><span class="line">variableInitializer</span><br><span class="line">	:	expression</span><br><span class="line">	|	arrayInitializer</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明类型</span><br><span class="line">unannType</span><br><span class="line">	:	unannPrimitiveType</span><br><span class="line">	|	unannReferenceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明原始类型</span><br><span class="line">unannPrimitiveType</span><br><span class="line">	:	numericType</span><br><span class="line">	|	&#x27;boolean&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明引用类型，包括类，类型参数和数组类型</span><br><span class="line">unannReferenceType</span><br><span class="line">	:	unannClassOrInterfaceType</span><br><span class="line">	|	unannTypeVariable</span><br><span class="line">	|	unannArrayType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*unannClassOrInterfaceType</span><br><span class="line">	:	unannClassType</span><br><span class="line">	|	unannInterfaceType</span><br><span class="line">	;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 未声明类和接口类型</span><br><span class="line">unannClassOrInterfaceType</span><br><span class="line">	:	(	unannClassType_lfno_unannClassOrInterfaceType</span><br><span class="line">		|	unannInterfaceType_lfno_unannClassOrInterfaceType</span><br><span class="line">		)</span><br><span class="line">		(	unannClassType_lf_unannClassOrInterfaceType</span><br><span class="line">		|	unannInterfaceType_lf_unannClassOrInterfaceType</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明类类型</span><br><span class="line">unannClassType</span><br><span class="line">	:	identifier typeArguments?</span><br><span class="line">	|	unannClassOrInterfaceType &#x27;.&#x27; annotation* identifier typeArguments?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明的类的.类或接口类型</span><br><span class="line">unannClassType_lf_unannClassOrInterfaceType</span><br><span class="line">	:	&#x27;.&#x27; annotation* identifier typeArguments?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明的类的类或接口类型</span><br><span class="line">unannClassType_lfno_unannClassOrInterfaceType</span><br><span class="line">	:	identifier typeArguments?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明接口类型</span><br><span class="line">unannInterfaceType</span><br><span class="line">	:	unannClassType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明接口类型</span><br><span class="line">unannInterfaceType_lf_unannClassOrInterfaceType</span><br><span class="line">	:	unannClassType_lf_unannClassOrInterfaceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明接口类型</span><br><span class="line">unannInterfaceType_lfno_unannClassOrInterfaceType</span><br><span class="line">	:	unannClassType_lfno_unannClassOrInterfaceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明值变量类型</span><br><span class="line">unannTypeVariable</span><br><span class="line">	:	identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 未声明数组类型</span><br><span class="line">unannArrayType</span><br><span class="line">	:	unannPrimitiveType dims</span><br><span class="line">	|	unannClassOrInterfaceType dims</span><br><span class="line">	|	unannTypeVariable dims</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法声明</span><br><span class="line">methodDeclaration</span><br><span class="line">	:	methodModifier* methodHeader methodBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法指示器</span><br><span class="line">methodModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;protected&#x27;</span><br><span class="line">	|	&#x27;private&#x27;</span><br><span class="line">	|	&#x27;abstract&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	|	&#x27;final&#x27;</span><br><span class="line">	|	&#x27;synchronized&#x27;</span><br><span class="line">	|	&#x27;native&#x27;</span><br><span class="line">	|	&#x27;strictfp&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法头，包括泛型方法</span><br><span class="line">methodHeader</span><br><span class="line">	:	result methodDeclarator throws_?</span><br><span class="line">	|	typeParameters annotation* result methodDeclarator throws_?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 函数返回结果</span><br><span class="line">result</span><br><span class="line">	:	unannType</span><br><span class="line">	|	&#x27;void&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法体明，参数列表</span><br><span class="line">methodDeclarator</span><br><span class="line">	:	identifier &#x27;(&#x27; formalParameterList? &#x27;)&#x27; dims?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般参数列表</span><br><span class="line">formalParameterList</span><br><span class="line">	:	formalParameters &#x27;,&#x27; lastFormalParameter</span><br><span class="line">	|	lastFormalParameter</span><br><span class="line">	|	receiverParameter</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般参数</span><br><span class="line">formalParameters</span><br><span class="line">	:	formalParameter (&#x27;,&#x27; formalParameter)*</span><br><span class="line">	|	receiverParameter (&#x27;,&#x27; formalParameter)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般参数</span><br><span class="line">formalParameter</span><br><span class="line">	:	variableModifier* unannType variableDeclaratorId</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量指示器</span><br><span class="line">variableModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;final&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 最后一般参数，用于表示灵活参数列表</span><br><span class="line">lastFormalParameter</span><br><span class="line">	:	variableModifier* unannType annotation* &#x27;...&#x27; variableDeclaratorId</span><br><span class="line">	|	formalParameter</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接收参数</span><br><span class="line">receiverParameter</span><br><span class="line">	:	annotation* unannType (identifier &#x27;.&#x27;)? &#x27;this&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 异常声明</span><br><span class="line">throws_</span><br><span class="line">	:	&#x27;throws&#x27; exceptionTypeList</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 异常类型列表</span><br><span class="line">exceptionTypeList</span><br><span class="line">	:	exceptionType (&#x27;,&#x27; exceptionType)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 异常类型不能未原始类型</span><br><span class="line">exceptionType</span><br><span class="line">	:	classType</span><br><span class="line">	|	typeVariable</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法体</span><br><span class="line">methodBody</span><br><span class="line">	:	block</span><br><span class="line">	|	&#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 块初始化器</span><br><span class="line">instanceInitializer</span><br><span class="line">	:	block</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 静态块初始化器</span><br><span class="line">staticInitializer</span><br><span class="line">	:	&#x27;static&#x27; block</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 构造函数声明，是一个无返回值的参数</span><br><span class="line">constructorDeclaration</span><br><span class="line">	:	constructorModifier* constructorDeclarator throws_? constructorBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 构造函数指示器</span><br><span class="line">constructorModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;protected&#x27;</span><br><span class="line">	|	&#x27;private&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 构造函数声明</span><br><span class="line">constructorDeclarator</span><br><span class="line">	:	typeParameters? simpleTypeName &#x27;(&#x27; formalParameterList? &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 简单类型</span><br><span class="line">simpleTypeName</span><br><span class="line">	:	identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 构造函数体</span><br><span class="line">constructorBody</span><br><span class="line">	:	&#x27;&#123;&#x27; explicitConstructorInvocation? blockStatements? &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 构造函数内部声明</span><br><span class="line">explicitConstructorInvocation</span><br><span class="line">	:	typeArguments? &#x27;this&#x27; &#x27;(&#x27; argumentList? &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">	|	typeArguments? &#x27;super&#x27; &#x27;(&#x27; argumentList? &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">	|	expressionName &#x27;.&#x27; typeArguments? &#x27;super&#x27; &#x27;(&#x27; argumentList? &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">	|	primary &#x27;.&#x27; typeArguments? &#x27;super&#x27; &#x27;(&#x27; argumentList? &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举声明，枚举不能继承类只能继承接口</span><br><span class="line">enumDeclaration</span><br><span class="line">	:	classModifier* &#x27;enum&#x27; identifier superinterfaces? enumBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举体</span><br><span class="line">enumBody</span><br><span class="line">	:	&#x27;&#123;&#x27; enumConstantList? &#x27;,&#x27;? enumBodyDeclarations? &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举常数列表</span><br><span class="line">enumConstantList</span><br><span class="line">	:	enumConstant (&#x27;,&#x27; enumConstant)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举常数</span><br><span class="line">enumConstant</span><br><span class="line">	:	enumConstantModifier* identifier (&#x27;(&#x27; argumentList? &#x27;)&#x27;)? classBody?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举常数指示器，只能有注解</span><br><span class="line">enumConstantModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举体声明，跟类差不多</span><br><span class="line">enumBodyDeclarations</span><br><span class="line">	:	&#x27;;&#x27; classBodyDeclaration*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §9 (Interfaces)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 接口声明</span><br><span class="line">interfaceDeclaration</span><br><span class="line">	:	normalInterfaceDeclaration   // 一般接口声明</span><br><span class="line">	|	annotationTypeDeclaration    // 注解类型声明</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般接口声明，包括泛型接口</span><br><span class="line">normalInterfaceDeclaration</span><br><span class="line">	:	interfaceModifier* &#x27;interface&#x27; identifier typeParameters? extendsInterfaces? interfaceBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口指示器</span><br><span class="line">interfaceModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;protected&#x27;</span><br><span class="line">	|	&#x27;private&#x27;</span><br><span class="line">	|	&#x27;abstract&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	|	&#x27;strictfp&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口的接口继承</span><br><span class="line">extendsInterfaces</span><br><span class="line">	:	&#x27;extends&#x27; interfaceTypeList</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口体</span><br><span class="line">interfaceBody</span><br><span class="line">	:	&#x27;&#123;&#x27; interfaceMemberDeclaration* &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口成员声明</span><br><span class="line">interfaceMemberDeclaration</span><br><span class="line">	:	constantDeclaration</span><br><span class="line">	|	interfaceMethodDeclaration</span><br><span class="line">	|	classDeclaration</span><br><span class="line">	|	interfaceDeclaration</span><br><span class="line">	|	&#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 常数声明</span><br><span class="line">constantDeclaration</span><br><span class="line">	:	constantModifier* unannType variableDeclaratorList &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 常数指示器</span><br><span class="line">constantModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	|	&#x27;final&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口方法声明</span><br><span class="line">interfaceMethodDeclaration</span><br><span class="line">	:	interfaceMethodModifier* methodHeader methodBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 接口方法指示器</span><br><span class="line">interfaceMethodModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;private&#x27;//Introduced in Java 9</span><br><span class="line">	|	&#x27;abstract&#x27;</span><br><span class="line">	|	&#x27;default&#x27;</span><br><span class="line">	|	&#x27;static&#x27;</span><br><span class="line">	|	&#x27;strictfp&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解类型@interface声明</span><br><span class="line">annotationTypeDeclaration</span><br><span class="line">	:	interfaceModifier* &#x27;@&#x27; &#x27;interface&#x27; identifier annotationTypeBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解类型体</span><br><span class="line">annotationTypeBody</span><br><span class="line">	:	&#x27;&#123;&#x27; annotationTypeMemberDeclaration* &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解类型成员声明</span><br><span class="line">annotationTypeMemberDeclaration</span><br><span class="line">	:	annotationTypeElementDeclaration</span><br><span class="line">	|	constantDeclaration</span><br><span class="line">	|	classDeclaration</span><br><span class="line">	|	interfaceDeclaration</span><br><span class="line">	|	&#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解元素声明</span><br><span class="line">annotationTypeElementDeclaration</span><br><span class="line">	:	annotationTypeElementModifier* unannType identifier &#x27;(&#x27; &#x27;)&#x27; dims? defaultValue? &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解类型元素指示器</span><br><span class="line">annotationTypeElementModifier</span><br><span class="line">	:	annotation</span><br><span class="line">	|	&#x27;public&#x27;</span><br><span class="line">	|	&#x27;abstract&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解默认值</span><br><span class="line">defaultValue</span><br><span class="line">	:	&#x27;default&#x27; elementValue</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 注解</span><br><span class="line">annotation</span><br><span class="line">	:	normalAnnotation         // 一般注解</span><br><span class="line">	|	markerAnnotation         // 标记注解</span><br><span class="line">	|	singleElementAnnotation  // 单元素注解</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般注解</span><br><span class="line">normalAnnotation</span><br><span class="line">	:	&#x27;@&#x27; typeName &#x27;(&#x27; elementValuePairList? &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 元素值对列表</span><br><span class="line">elementValuePairList</span><br><span class="line">	:	elementValuePair (&#x27;,&#x27; elementValuePair)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 元素值对</span><br><span class="line">elementValuePair</span><br><span class="line">	:	identifier &#x27;=&#x27; elementValue</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 元素值</span><br><span class="line">elementValue</span><br><span class="line">	:	conditionalExpression</span><br><span class="line">	|	elementValueArrayInitializer</span><br><span class="line">	|	annotation</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 元素值数组初始化</span><br><span class="line">elementValueArrayInitializer</span><br><span class="line">	:	&#x27;&#123;&#x27; elementValueList? &#x27;,&#x27;? &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 元素值列表</span><br><span class="line">elementValueList</span><br><span class="line">	:	elementValue (&#x27;,&#x27; elementValue)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 标记注解</span><br><span class="line">markerAnnotation</span><br><span class="line">	:	&#x27;@&#x27; typeName</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 单元素注解</span><br><span class="line">singleElementAnnotation</span><br><span class="line">	:	&#x27;@&#x27; typeName &#x27;(&#x27; elementValue &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §10 (Arrays)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 数组初始化</span><br><span class="line">arrayInitializer</span><br><span class="line">	:	&#x27;&#123;&#x27; variableInitializerList? &#x27;,&#x27;? &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量初始化列表</span><br><span class="line">variableInitializerList</span><br><span class="line">	:	variableInitializer (&#x27;,&#x27; variableInitializer)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §14 (Blocks and Statements)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 块</span><br><span class="line">block</span><br><span class="line">	:	&#x27;&#123;&#x27; blockStatements? &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 块状态</span><br><span class="line">blockStatements</span><br><span class="line">	:	blockStatement+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 块状态</span><br><span class="line">blockStatement</span><br><span class="line">	:	localVariableDeclarationStatement</span><br><span class="line">	|	classDeclaration</span><br><span class="line">	|	statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 局部变量声明状态</span><br><span class="line">localVariableDeclarationStatement</span><br><span class="line">	:	localVariableDeclaration &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 局部变量声明</span><br><span class="line">localVariableDeclaration</span><br><span class="line">	:	variableModifier* unannType variableDeclaratorList</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 状态</span><br><span class="line">statement</span><br><span class="line">	:	statementWithoutTrailingSubstatement</span><br><span class="line">	|	labeledStatement</span><br><span class="line">	|	ifThenStatement</span><br><span class="line">	|	ifThenElseStatement</span><br><span class="line">	|	whileStatement</span><br><span class="line">	|	forStatement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 状态 没有短if</span><br><span class="line">statementNoShortIf</span><br><span class="line">	:	statementWithoutTrailingSubstatement</span><br><span class="line">	|	labeledStatementNoShortIf</span><br><span class="line">	|	ifThenElseStatementNoShortIf</span><br><span class="line">	|	whileStatementNoShortIf</span><br><span class="line">	|	forStatementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 状态 没有子状态</span><br><span class="line">statementWithoutTrailingSubstatement</span><br><span class="line">	:	block</span><br><span class="line">	|	emptyStatement</span><br><span class="line">	|	expressionStatement</span><br><span class="line">	|	assertStatement</span><br><span class="line">	|	switchStatement</span><br><span class="line">	|	doStatement</span><br><span class="line">	|	breakStatement</span><br><span class="line">	|	continueStatement</span><br><span class="line">	|	returnStatement</span><br><span class="line">	|	synchronizedStatement</span><br><span class="line">	|	throwStatement</span><br><span class="line">	|	tryStatement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 空状态</span><br><span class="line">emptyStatement</span><br><span class="line">	:	&#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 标记状态</span><br><span class="line">labeledStatement</span><br><span class="line">	:	identifier &#x27;:&#x27; statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 标记状态 没有短if</span><br><span class="line">labeledStatementNoShortIf</span><br><span class="line">	:	identifier &#x27;:&#x27; statementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 表达式状态</span><br><span class="line">expressionStatement</span><br><span class="line">	:	statementExpression &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 状态表达式</span><br><span class="line">statementExpression</span><br><span class="line">	:	assignment                // 赋值</span><br><span class="line">	|	preIncrementExpression   </span><br><span class="line">	|	preDecrementExpression</span><br><span class="line">	|	postIncrementExpression</span><br><span class="line">	|	postDecrementExpression</span><br><span class="line">	|	methodInvocation          // 方法调用</span><br><span class="line">	|	classInstanceCreationExpression  // 类创建表达式</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// if状态</span><br><span class="line">ifThenStatement</span><br><span class="line">	:	&#x27;if&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// if状态</span><br><span class="line">ifThenElseStatement</span><br><span class="line">	:	&#x27;if&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statementNoShortIf &#x27;else&#x27; statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// if else 状态</span><br><span class="line">ifThenElseStatementNoShortIf</span><br><span class="line">	:	&#x27;if&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statementNoShortIf &#x27;else&#x27; statementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 断言状态</span><br><span class="line">assertStatement</span><br><span class="line">	:	&#x27;assert&#x27; expression &#x27;;&#x27;</span><br><span class="line">	|	&#x27;assert&#x27; expression &#x27;:&#x27; expression &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// switch状态</span><br><span class="line">switchStatement</span><br><span class="line">	:	&#x27;switch&#x27; &#x27;(&#x27; expression &#x27;)&#x27; switchBlock</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// switch体</span><br><span class="line">switchBlock</span><br><span class="line">	:	&#x27;&#123;&#x27; switchBlockStatementGroup* switchLabel* &#x27;&#125;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// switch 两种case方式</span><br><span class="line">switchBlockStatementGroup</span><br><span class="line">	:	switchLabels blockStatements</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// switch 标签</span><br><span class="line">switchLabels</span><br><span class="line">	:	switchLabel+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// switch 标签，只允许枚举和常数表达式</span><br><span class="line">switchLabel</span><br><span class="line">	:	&#x27;case&#x27; constantExpression &#x27;:&#x27;</span><br><span class="line">	|	&#x27;case&#x27; enumConstantName &#x27;:&#x27;</span><br><span class="line">	|	&#x27;default&#x27; &#x27;:&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 枚举常数</span><br><span class="line">enumConstantName</span><br><span class="line">	:	identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// while stat</span><br><span class="line">whileStatement</span><br><span class="line">	:	&#x27;while&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// while stat 没有短if</span><br><span class="line">whileStatementNoShortIf</span><br><span class="line">	:	&#x27;while&#x27; &#x27;(&#x27; expression &#x27;)&#x27; statementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// do stat</span><br><span class="line">doStatement</span><br><span class="line">	:	&#x27;do&#x27; statement &#x27;while&#x27; &#x27;(&#x27; expression &#x27;)&#x27; &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// for stat 两种for表达式</span><br><span class="line">forStatement</span><br><span class="line">	:	basicForStatement</span><br><span class="line">	|	enhancedForStatement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// for stat 没有短if</span><br><span class="line">forStatementNoShortIf</span><br><span class="line">	:	basicForStatementNoShortIf</span><br><span class="line">	|	enhancedForStatementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般for</span><br><span class="line">basicForStatement</span><br><span class="line">	:	&#x27;for&#x27; &#x27;(&#x27; forInit? &#x27;;&#x27; expression? &#x27;;&#x27; forUpdate? &#x27;)&#x27; statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 一般for 无short if</span><br><span class="line">basicForStatementNoShortIf</span><br><span class="line">	:	&#x27;for&#x27; &#x27;(&#x27; forInit? &#x27;;&#x27; expression? &#x27;;&#x27; forUpdate? &#x27;)&#x27; statementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// for初始化</span><br><span class="line">forInit</span><br><span class="line">	:	statementExpressionList</span><br><span class="line">	|	localVariableDeclaration</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// for更新</span><br><span class="line">forUpdate</span><br><span class="line">	:	statementExpressionList</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// stat 表达式列表</span><br><span class="line">statementExpressionList</span><br><span class="line">	:	statementExpression (&#x27;,&#x27; statementExpression)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 迭代器for</span><br><span class="line">enhancedForStatement</span><br><span class="line">	:	&#x27;for&#x27; &#x27;(&#x27; variableModifier* unannType variableDeclaratorId &#x27;:&#x27; expression &#x27;)&#x27; statement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 迭代器for no short if</span><br><span class="line">enhancedForStatementNoShortIf</span><br><span class="line">	:	&#x27;for&#x27; &#x27;(&#x27; variableModifier* unannType variableDeclaratorId &#x27;:&#x27; expression &#x27;)&#x27; statementNoShortIf</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// break stat</span><br><span class="line">breakStatement</span><br><span class="line">	:	&#x27;break&#x27; identifier? &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// continue stat</span><br><span class="line">continueStatement</span><br><span class="line">	:	&#x27;continue&#x27; identifier? &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// return stat</span><br><span class="line">returnStatement</span><br><span class="line">	:	&#x27;return&#x27; expression? &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// throw stat</span><br><span class="line">throwStatement</span><br><span class="line">	:	&#x27;throw&#x27; expression &#x27;;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// synchronized stat</span><br><span class="line">synchronizedStatement</span><br><span class="line">	:	&#x27;synchronized&#x27; &#x27;(&#x27; expression &#x27;)&#x27; block</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// try stat，一种有finally，一种没有,还有一种带资源释放的try,类似python的with ... as ... </span><br><span class="line">tryStatement</span><br><span class="line">	:	&#x27;try&#x27; block catches</span><br><span class="line">	|	&#x27;try&#x27; block catches? finally_</span><br><span class="line">	|	tryWithResourcesStatement</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// catch </span><br><span class="line">catches</span><br><span class="line">	:	catchClause+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// catch </span><br><span class="line">catchClause</span><br><span class="line">	:	&#x27;catch&#x27; &#x27;(&#x27; catchFormalParameter &#x27;)&#x27; block</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// catch 的参数列表</span><br><span class="line">catchFormalParameter</span><br><span class="line">	:	variableModifier* catchType variableDeclaratorId</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// catch类型</span><br><span class="line">catchType</span><br><span class="line">	:	unannClassType (&#x27;|&#x27; classType)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// finally</span><br><span class="line">finally_</span><br><span class="line">	:	&#x27;finally&#x27; block</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 携带资源释放的try</span><br><span class="line">tryWithResourcesStatement</span><br><span class="line">	:	&#x27;try&#x27; resourceSpecification block catches? finally_?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 资源声明</span><br><span class="line">resourceSpecification</span><br><span class="line">	:	&#x27;(&#x27; resourceList &#x27;;&#x27;? &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 资源列表</span><br><span class="line">resourceList</span><br><span class="line">	:	resource (&#x27;;&#x27; resource)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 资源</span><br><span class="line">resource</span><br><span class="line">	:	variableModifier* unannType variableDeclaratorId &#x27;=&#x27; expression</span><br><span class="line">	|	variableAccess//Introduced in Java 9</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 变量访问</span><br><span class="line">variableAccess</span><br><span class="line">	:	expressionName</span><br><span class="line">	|	fieldAccess</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Productions from §15 (Expressions)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*primary</span><br><span class="line">	:	primaryNoNewArray</span><br><span class="line">	|	arrayCreationExpression</span><br><span class="line">	;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">primary</span><br><span class="line">	:	(	primaryNoNewArray_lfno_primary</span><br><span class="line">		|	arrayCreationExpression</span><br><span class="line">		)</span><br><span class="line">		(	primaryNoNewArray_lf_primary</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray</span><br><span class="line">	:	literal</span><br><span class="line">	|	classLiteral</span><br><span class="line">	|	&#x27;this&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;this&#x27;</span><br><span class="line">	|	&#x27;(&#x27; expression &#x27;)&#x27;</span><br><span class="line">	|	classInstanceCreationExpression</span><br><span class="line">	|	fieldAccess</span><br><span class="line">	|	arrayAccess</span><br><span class="line">	|	methodInvocation</span><br><span class="line">	|	methodReference</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lf_arrayAccess</span><br><span class="line">	:</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lfno_arrayAccess</span><br><span class="line">	:	literal</span><br><span class="line">	|	typeName (&#x27;[&#x27; &#x27;]&#x27;)* &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;void&#x27; &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;this&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;this&#x27;</span><br><span class="line">	|	&#x27;(&#x27; expression &#x27;)&#x27;</span><br><span class="line">	|	classInstanceCreationExpression</span><br><span class="line">	|	fieldAccess</span><br><span class="line">	|	methodInvocation</span><br><span class="line">	|	methodReference</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lf_primary</span><br><span class="line">	:	classInstanceCreationExpression_lf_primary</span><br><span class="line">	|	fieldAccess_lf_primary</span><br><span class="line">	|	arrayAccess_lf_primary</span><br><span class="line">	|	methodInvocation_lf_primary</span><br><span class="line">	|	methodReference_lf_primary</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary</span><br><span class="line">	:</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary</span><br><span class="line">	:	classInstanceCreationExpression_lf_primary</span><br><span class="line">	|	fieldAccess_lf_primary</span><br><span class="line">	|	methodInvocation_lf_primary</span><br><span class="line">	|	methodReference_lf_primary</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lfno_primary</span><br><span class="line">	:	literal</span><br><span class="line">	|	typeName (&#x27;[&#x27; &#x27;]&#x27;)* &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	unannPrimitiveType (&#x27;[&#x27; &#x27;]&#x27;)* &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;void&#x27; &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;this&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;this&#x27;</span><br><span class="line">	|	&#x27;(&#x27; expression &#x27;)&#x27;</span><br><span class="line">	|	classInstanceCreationExpression_lfno_primary</span><br><span class="line">	|	fieldAccess_lfno_primary</span><br><span class="line">	|	arrayAccess_lfno_primary</span><br><span class="line">	|	methodInvocation_lfno_primary</span><br><span class="line">	|	methodReference_lfno_primary</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary</span><br><span class="line">	:</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary</span><br><span class="line">	:	literal</span><br><span class="line">	|	typeName (&#x27;[&#x27; &#x27;]&#x27;)* &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	unannPrimitiveType (&#x27;[&#x27; &#x27;]&#x27;)* &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;void&#x27; &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;this&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;this&#x27;</span><br><span class="line">	|	&#x27;(&#x27; expression &#x27;)&#x27;</span><br><span class="line">	|	classInstanceCreationExpression_lfno_primary</span><br><span class="line">	|	fieldAccess_lfno_primary</span><br><span class="line">	|	methodInvocation_lfno_primary</span><br><span class="line">	|	methodReference_lfno_primary</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型字面量</span><br><span class="line">classLiteral</span><br><span class="line">	:	(typeName|numericType|&#x27;boolean&#x27;) (&#x27;[&#x27; &#x27;]&#x27;)* &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	|	&#x27;void&#x27; &#x27;.&#x27; &#x27;class&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">classInstanceCreationExpression</span><br><span class="line">	:	&#x27;new&#x27; typeArguments? annotation* identifier (&#x27;.&#x27; annotation* identifier)* typeArgumentsOrDiamond? &#x27;(&#x27; argumentList? &#x27;)&#x27; classBody?</span><br><span class="line">	|	expressionName &#x27;.&#x27; &#x27;new&#x27; typeArguments? annotation* identifier typeArgumentsOrDiamond? &#x27;(&#x27; argumentList? &#x27;)&#x27; classBody?</span><br><span class="line">	|	primary &#x27;.&#x27; &#x27;new&#x27; typeArguments? annotation* identifier typeArgumentsOrDiamond? &#x27;(&#x27; argumentList? &#x27;)&#x27; classBody?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">classInstanceCreationExpression_lf_primary</span><br><span class="line">	:	&#x27;.&#x27; &#x27;new&#x27; typeArguments? annotation* identifier typeArgumentsOrDiamond? &#x27;(&#x27; argumentList? &#x27;)&#x27; classBody?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">classInstanceCreationExpression_lfno_primary</span><br><span class="line">	:	&#x27;new&#x27; typeArguments? annotation* identifier (&#x27;.&#x27; annotation* identifier)* typeArgumentsOrDiamond? &#x27;(&#x27; argumentList? &#x27;)&#x27; classBody?</span><br><span class="line">	|	expressionName &#x27;.&#x27; &#x27;new&#x27; typeArguments? annotation* identifier typeArgumentsOrDiamond? &#x27;(&#x27; argumentList? &#x27;)&#x27; classBody?</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">typeArgumentsOrDiamond</span><br><span class="line">	:	typeArguments</span><br><span class="line">	|	&#x27;&lt;&#x27; &#x27;&gt;&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类成员访问</span><br><span class="line">fieldAccess</span><br><span class="line">	:	primary &#x27;.&#x27; identifier</span><br><span class="line">	|	&#x27;super&#x27; &#x27;.&#x27; identifier</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;super&#x27; &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类成员访问</span><br><span class="line">fieldAccess_lf_primary</span><br><span class="line">	:	&#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类成员访问</span><br><span class="line">fieldAccess_lfno_primary</span><br><span class="line">	:	&#x27;super&#x27; &#x27;.&#x27; identifier</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;super&#x27; &#x27;.&#x27; identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*arrayAccess</span><br><span class="line">	:	expressionName &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">	|	primaryNoNewArray &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">	;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 数组访问</span><br><span class="line">arrayAccess</span><br><span class="line">	:	(	expressionName &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		|	primaryNoNewArray_lfno_arrayAccess &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		)</span><br><span class="line">		(	primaryNoNewArray_lf_arrayAccess &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 数组访问</span><br><span class="line">arrayAccess_lf_primary</span><br><span class="line">	:	(	primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		)</span><br><span class="line">		(	primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line">	</span><br><span class="line">// 数组访问	</span><br><span class="line">arrayAccess_lfno_primary</span><br><span class="line">	:	(	expressionName &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		|	primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		)</span><br><span class="line">		(	primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 函数调用</span><br><span class="line">methodInvocation</span><br><span class="line">	:	methodName &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	expressionName &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	primary &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	&#x27;super&#x27; &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;super&#x27; &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">methodInvocation_lf_primary</span><br><span class="line">	:	&#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">methodInvocation_lfno_primary</span><br><span class="line">	:	methodName &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	expressionName &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	&#x27;super&#x27; &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;super&#x27; &#x27;.&#x27; typeArguments? identifier &#x27;(&#x27; argumentList? &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">argumentList</span><br><span class="line">	:	expression (&#x27;,&#x27; expression)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 方法引用</span><br><span class="line">methodReference</span><br><span class="line">	:	expressionName &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	referenceType &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	primary &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	&#x27;super&#x27; &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;super&#x27; &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	classType &#x27;::&#x27; typeArguments? &#x27;new&#x27;</span><br><span class="line">	|	arrayType &#x27;::&#x27; &#x27;new&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">methodReference_lf_primary</span><br><span class="line">	:	&#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">methodReference_lfno_primary</span><br><span class="line">	:	expressionName &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	referenceType &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	&#x27;super&#x27; &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	typeName &#x27;.&#x27; &#x27;super&#x27; &#x27;::&#x27; typeArguments? identifier</span><br><span class="line">	|	classType &#x27;::&#x27; typeArguments? &#x27;new&#x27;</span><br><span class="line">	|	arrayType &#x27;::&#x27; &#x27;new&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 数组创建表达式</span><br><span class="line">arrayCreationExpression</span><br><span class="line">	:	&#x27;new&#x27; primitiveType dimExprs dims?</span><br><span class="line">	|	&#x27;new&#x27; classOrInterfaceType dimExprs dims?</span><br><span class="line">	|	&#x27;new&#x27; primitiveType dims arrayInitializer</span><br><span class="line">	|	&#x27;new&#x27; classOrInterfaceType dims arrayInitializer</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 数组表达式</span><br><span class="line">dimExprs</span><br><span class="line">	:	dimExpr+</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 数组表达式</span><br><span class="line">dimExpr</span><br><span class="line">	:	annotation* &#x27;[&#x27; expression &#x27;]&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 常数表达式</span><br><span class="line">constantExpression</span><br><span class="line">	:	expression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 表达式</span><br><span class="line">expression</span><br><span class="line">	:	lambdaExpression</span><br><span class="line">	|	assignmentExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// lambda 表达式</span><br><span class="line">lambdaExpression</span><br><span class="line">	:	lambdaParameters &#x27;-&gt;&#x27; lambdaBody</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// lambda 参数</span><br><span class="line">lambdaParameters</span><br><span class="line">	:	identifier</span><br><span class="line">	|	&#x27;(&#x27; formalParameterList? &#x27;)&#x27;</span><br><span class="line">	|	&#x27;(&#x27; inferredFormalParameterList &#x27;)&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">inferredFormalParameterList</span><br><span class="line">	:	identifier (&#x27;,&#x27; identifier)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// lambda 体</span><br><span class="line">lambdaBody</span><br><span class="line">	:	expression</span><br><span class="line">	|	block</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 赋值表达式</span><br><span class="line">assignmentExpression</span><br><span class="line">	:	conditionalExpression</span><br><span class="line">	|	assignment</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 赋值表达式</span><br><span class="line">assignment</span><br><span class="line">	:	leftHandSide assignmentOperator expression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 左值表达死</span><br><span class="line">leftHandSide</span><br><span class="line">	:	expressionName</span><br><span class="line">	|	fieldAccess</span><br><span class="line">	|	arrayAccess</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 赋值运算符</span><br><span class="line">assignmentOperator</span><br><span class="line">	:	&#x27;=&#x27;</span><br><span class="line">	|	&#x27;*=&#x27;</span><br><span class="line">	|	&#x27;/=&#x27;</span><br><span class="line">	|	&#x27;%=&#x27;</span><br><span class="line">	|	&#x27;+=&#x27;</span><br><span class="line">	|	&#x27;-=&#x27;</span><br><span class="line">	|	&#x27;&lt;&lt;=&#x27;</span><br><span class="line">	|	&#x27;&gt;&gt;=&#x27;</span><br><span class="line">	|	&#x27;&gt;&gt;&gt;=&#x27;</span><br><span class="line">	|	&#x27;&amp;=&#x27;</span><br><span class="line">	|	&#x27;^=&#x27;</span><br><span class="line">	|	&#x27;|=&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 条件表达式</span><br><span class="line">conditionalExpression</span><br><span class="line">	:	conditionalOrExpression</span><br><span class="line">	|	conditionalOrExpression &#x27;?&#x27; expression &#x27;:&#x27; (conditionalExpression|lambdaExpression)</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 条件或表达式</span><br><span class="line">conditionalOrExpression</span><br><span class="line">	:	conditionalAndExpression</span><br><span class="line">	|	conditionalOrExpression &#x27;||&#x27; conditionalAndExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 条件与表达式</span><br><span class="line">conditionalAndExpression</span><br><span class="line">	:	inclusiveOrExpression</span><br><span class="line">	|	conditionalAndExpression &#x27;&amp;&amp;&#x27; inclusiveOrExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 按位或表达式</span><br><span class="line">inclusiveOrExpression</span><br><span class="line">	:	exclusiveOrExpression</span><br><span class="line">	|	inclusiveOrExpression &#x27;|&#x27; exclusiveOrExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 按位异或表达式</span><br><span class="line">exclusiveOrExpression</span><br><span class="line">	:	andExpression</span><br><span class="line">	|	exclusiveOrExpression &#x27;^&#x27; andExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 按位与表达式</span><br><span class="line">andExpression</span><br><span class="line">	:	equalityExpression</span><br><span class="line">	|	andExpression &#x27;&amp;&#x27; equalityExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 比较表达式</span><br><span class="line">equalityExpression</span><br><span class="line">	:	relationalExpression</span><br><span class="line">	|	equalityExpression &#x27;==&#x27; relationalExpression</span><br><span class="line">	|	equalityExpression &#x27;!=&#x27; relationalExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 关系表达式</span><br><span class="line">relationalExpression</span><br><span class="line">	:	shiftExpression</span><br><span class="line">	|	relationalExpression &#x27;&lt;&#x27; shiftExpression</span><br><span class="line">	|	relationalExpression &#x27;&gt;&#x27; shiftExpression</span><br><span class="line">	|	relationalExpression &#x27;&lt;=&#x27; shiftExpression</span><br><span class="line">	|	relationalExpression &#x27;&gt;=&#x27; shiftExpression</span><br><span class="line">	|	relationalExpression &#x27;instanceof&#x27; referenceType</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 按位移动表达式</span><br><span class="line">shiftExpression</span><br><span class="line">	:	additiveExpression</span><br><span class="line">	|	shiftExpression &#x27;&lt;&#x27; &#x27;&lt;&#x27; additiveExpression</span><br><span class="line">	|	shiftExpression &#x27;&gt;&#x27; &#x27;&gt;&#x27; additiveExpression</span><br><span class="line">	|	shiftExpression &#x27;&gt;&#x27; &#x27;&gt;&#x27; &#x27;&gt;&#x27; additiveExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 加减表达式</span><br><span class="line">additiveExpression</span><br><span class="line">	:	multiplicativeExpression</span><br><span class="line">	|	additiveExpression &#x27;+&#x27; multiplicativeExpression</span><br><span class="line">	|	additiveExpression &#x27;-&#x27; multiplicativeExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 乘法表达式</span><br><span class="line">multiplicativeExpression</span><br><span class="line">	:	unaryExpression</span><br><span class="line">	|	multiplicativeExpression &#x27;*&#x27; unaryExpression</span><br><span class="line">	|	multiplicativeExpression &#x27;/&#x27; unaryExpression</span><br><span class="line">	|	multiplicativeExpression &#x27;%&#x27; unaryExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 单目表达式</span><br><span class="line">unaryExpression</span><br><span class="line">	:	preIncrementExpression</span><br><span class="line">	|	preDecrementExpression</span><br><span class="line">	|	&#x27;+&#x27; unaryExpression</span><br><span class="line">	|	&#x27;-&#x27; unaryExpression</span><br><span class="line">	|	unaryExpressionNotPlusMinus</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 自增表达式</span><br><span class="line">preIncrementExpression</span><br><span class="line">	:	&#x27;++&#x27; unaryExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 自减表达式</span><br><span class="line">preDecrementExpression</span><br><span class="line">	:	&#x27;--&#x27; unaryExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 单目表达式没有+,-</span><br><span class="line">unaryExpressionNotPlusMinus</span><br><span class="line">	:	postfixExpression</span><br><span class="line">	|	&#x27;~&#x27; unaryExpression</span><br><span class="line">	|	&#x27;!&#x27; unaryExpression</span><br><span class="line">	|	castExpression</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">/*postfixExpression</span><br><span class="line">	:	primary</span><br><span class="line">	|	expressionName</span><br><span class="line">	|	postIncrementExpression</span><br><span class="line">	|	postDecrementExpression</span><br><span class="line">	;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">postfixExpression</span><br><span class="line">	:	(	primary</span><br><span class="line">		|	expressionName</span><br><span class="line">		)</span><br><span class="line">		(	postIncrementExpression_lf_postfixExpression</span><br><span class="line">		|	postDecrementExpression_lf_postfixExpression</span><br><span class="line">		)*</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">postIncrementExpression</span><br><span class="line">	:	postfixExpression &#x27;++&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">postIncrementExpression_lf_postfixExpression</span><br><span class="line">	:	&#x27;++&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">postDecrementExpression</span><br><span class="line">	:	postfixExpression &#x27;--&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">postDecrementExpression_lf_postfixExpression</span><br><span class="line">	:	&#x27;--&#x27;</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">// 类型转换表达式</span><br><span class="line">castExpression</span><br><span class="line">	:	&#x27;(&#x27; primitiveType &#x27;)&#x27; unaryExpression</span><br><span class="line">	|	&#x27;(&#x27; referenceType additionalBound* &#x27;)&#x27; unaryExpressionNotPlusMinus</span><br><span class="line">	|	&#x27;(&#x27; referenceType additionalBound* &#x27;)&#x27; lambdaExpression</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<h3 id="Lua-解释器"><a href="#Lua-解释器" class="headerlink" title="Lua 解释器"></a>Lua 解释器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">grammar Lua;</span><br><span class="line"></span><br><span class="line">chunk</span><br><span class="line">    : block EOF</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">block</span><br><span class="line">    : stat* retstat?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">stat</span><br><span class="line">    : &#x27;;&#x27;</span><br><span class="line">    | varlist &#x27;=&#x27; explist</span><br><span class="line">    | functioncall</span><br><span class="line">    | label</span><br><span class="line">    | &#x27;break&#x27;</span><br><span class="line">    | &#x27;goto&#x27; NAME</span><br><span class="line">    | &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;while&#x27; exp &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;repeat&#x27; block &#x27;until&#x27; exp</span><br><span class="line">    | &#x27;if&#x27; exp &#x27;then&#x27; block (&#x27;elseif&#x27; exp &#x27;then&#x27; block)* (&#x27;else&#x27; block)? &#x27;end&#x27;</span><br><span class="line">    | &#x27;for&#x27; NAME &#x27;=&#x27; exp &#x27;,&#x27; exp (&#x27;,&#x27; exp)? &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;for&#x27; namelist &#x27;in&#x27; explist &#x27;do&#x27; block &#x27;end&#x27;</span><br><span class="line">    | &#x27;function&#x27; funcname funcbody</span><br><span class="line">    | &#x27;local&#x27; &#x27;function&#x27; NAME funcbody</span><br><span class="line">    | &#x27;local&#x27; namelist (&#x27;=&#x27; explist)?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">retstat</span><br><span class="line">    : &#x27;return&#x27; explist? &#x27;;&#x27;?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">label</span><br><span class="line">    : &#x27;::&#x27; NAME &#x27;::&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">funcname</span><br><span class="line">    : NAME (&#x27;.&#x27; NAME)* (&#x27;:&#x27; NAME)?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">varlist</span><br><span class="line">    : var (&#x27;,&#x27; var)*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">namelist</span><br><span class="line">    : NAME (&#x27;,&#x27; NAME)*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">explist</span><br><span class="line">    : exp (&#x27;,&#x27; exp)*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">exp</span><br><span class="line">    : &#x27;nil&#x27; | &#x27;false&#x27; | &#x27;true&#x27;</span><br><span class="line">    | number</span><br><span class="line">    | string</span><br><span class="line">    | &#x27;...&#x27;</span><br><span class="line">    | functiondef</span><br><span class="line">    | prefixexp</span><br><span class="line">    | tableconstructor</span><br><span class="line">    | &lt;assoc=right&gt; exp operatorPower exp</span><br><span class="line">    | operatorUnary exp</span><br><span class="line">    | exp operatorMulDivMod exp</span><br><span class="line">    | exp operatorAddSub exp</span><br><span class="line">    | &lt;assoc=right&gt; exp operatorStrcat exp</span><br><span class="line">    | exp operatorComparison exp</span><br><span class="line">    | exp operatorAnd exp</span><br><span class="line">    | exp operatorOr exp</span><br><span class="line">    | exp operatorBitwise exp</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">prefixexp</span><br><span class="line">    : varOrExp nameAndArgs*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">functioncall</span><br><span class="line">    : varOrExp nameAndArgs+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">varOrExp</span><br><span class="line">    : var | &#x27;(&#x27; exp &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">var</span><br><span class="line">    : (NAME | &#x27;(&#x27; exp &#x27;)&#x27; varSuffix) varSuffix*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">varSuffix</span><br><span class="line">    : nameAndArgs* (&#x27;[&#x27; exp &#x27;]&#x27; | &#x27;.&#x27; NAME)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">nameAndArgs</span><br><span class="line">    : (&#x27;:&#x27; NAME)? args</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">var</span><br><span class="line">    : NAME | prefixexp &#x27;[&#x27; exp &#x27;]&#x27; | prefixexp &#x27;.&#x27; NAME</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">prefixexp</span><br><span class="line">    : var | functioncall | &#x27;(&#x27; exp &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">functioncall</span><br><span class="line">    : prefixexp args | prefixexp &#x27;:&#x27; NAME args </span><br><span class="line">    ;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">args</span><br><span class="line">    : &#x27;(&#x27; explist? &#x27;)&#x27; | tableconstructor | string</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">functiondef</span><br><span class="line">    : &#x27;function&#x27; funcbody</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">funcbody</span><br><span class="line">    : &#x27;(&#x27; parlist? &#x27;)&#x27; block &#x27;end&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">parlist</span><br><span class="line">    : namelist (&#x27;,&#x27; &#x27;...&#x27;)? | &#x27;...&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">tableconstructor</span><br><span class="line">    : &#x27;&#123;&#x27; fieldlist? &#x27;&#125;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fieldlist</span><br><span class="line">    : field (fieldsep field)* fieldsep?</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">field</span><br><span class="line">    : &#x27;[&#x27; exp &#x27;]&#x27; &#x27;=&#x27; exp | NAME &#x27;=&#x27; exp | exp</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fieldsep</span><br><span class="line">    : &#x27;,&#x27; | &#x27;;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">operatorOr </span><br><span class="line">	: &#x27;or&#x27;;</span><br><span class="line"></span><br><span class="line">operatorAnd </span><br><span class="line">	: &#x27;and&#x27;;</span><br><span class="line"></span><br><span class="line">operatorComparison </span><br><span class="line">	: &#x27;&lt;&#x27; | &#x27;&gt;&#x27; | &#x27;&lt;=&#x27; | &#x27;&gt;=&#x27; | &#x27;~=&#x27; | &#x27;==&#x27;;</span><br><span class="line"></span><br><span class="line">operatorStrcat</span><br><span class="line">	: &#x27;..&#x27;;</span><br><span class="line"></span><br><span class="line">operatorAddSub</span><br><span class="line">	: &#x27;+&#x27; | &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">operatorMulDivMod</span><br><span class="line">	: &#x27;*&#x27; | &#x27;/&#x27; | &#x27;%&#x27; | &#x27;//&#x27;;</span><br><span class="line"></span><br><span class="line">operatorBitwise</span><br><span class="line">	: &#x27;&amp;&#x27; | &#x27;|&#x27; | &#x27;~&#x27; | &#x27;&lt;&lt;&#x27; | &#x27;&gt;&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">operatorUnary</span><br><span class="line">    : &#x27;not&#x27; | &#x27;#&#x27; | &#x27;-&#x27; | &#x27;~&#x27;;</span><br><span class="line"></span><br><span class="line">operatorPower</span><br><span class="line">    : &#x27;^&#x27;;</span><br><span class="line"></span><br><span class="line">number</span><br><span class="line">    : INT | HEX | FLOAT | HEX_FLOAT</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line">    : NORMALSTRING | CHARSTRING | LONGSTRING</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">// LEXER</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    : [a-zA-Z_][a-zA-Z_0-9]*</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">NORMALSTRING</span><br><span class="line">    : &#x27;&quot;&#x27; ( EscapeSequence | ~(&#x27;\\&#x27;|&#x27;&quot;&#x27;) )* &#x27;&quot;&#x27; </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">CHARSTRING</span><br><span class="line">    : &#x27;\&#x27;&#x27; ( EscapeSequence | ~(&#x27;\&#x27;&#x27;|&#x27;\\&#x27;) )* &#x27;\&#x27;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">LONGSTRING</span><br><span class="line">    : &#x27;[&#x27; NESTED_STR &#x27;]&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">NESTED_STR</span><br><span class="line">    : &#x27;=&#x27; NESTED_STR &#x27;=&#x27;</span><br><span class="line">    | &#x27;[&#x27; .*? &#x27;]&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">INT</span><br><span class="line">    : Digit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">HEX</span><br><span class="line">    : &#x27;0&#x27; [xX] HexDigit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">FLOAT</span><br><span class="line">    : Digit+ &#x27;.&#x27; Digit* ExponentPart?</span><br><span class="line">    | &#x27;.&#x27; Digit+ ExponentPart?</span><br><span class="line">    | Digit+ ExponentPart</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">HEX_FLOAT</span><br><span class="line">    : &#x27;0&#x27; [xX] HexDigit+ &#x27;.&#x27; HexDigit* HexExponentPart?</span><br><span class="line">    | &#x27;0&#x27; [xX] &#x27;.&#x27; HexDigit+ HexExponentPart?</span><br><span class="line">    | &#x27;0&#x27; [xX] HexDigit+ HexExponentPart</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ExponentPart</span><br><span class="line">    : [eE] [+-]? Digit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexExponentPart</span><br><span class="line">    : [pP] [+-]? Digit+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">EscapeSequence</span><br><span class="line">    : &#x27;\\&#x27; [abfnrtvz&quot;&#x27;\\]</span><br><span class="line">    | &#x27;\\&#x27; &#x27;\r&#x27;? &#x27;\n&#x27;</span><br><span class="line">    | DecimalEscape</span><br><span class="line">    | HexEscape</span><br><span class="line">    | UtfEscape</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">fragment</span><br><span class="line">DecimalEscape</span><br><span class="line">    : &#x27;\\&#x27; Digit</span><br><span class="line">    | &#x27;\\&#x27; Digit Digit</span><br><span class="line">    | &#x27;\\&#x27; [0-2] Digit Digit</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">fragment</span><br><span class="line">HexEscape</span><br><span class="line">    : &#x27;\\&#x27; &#x27;x&#x27; HexDigit HexDigit</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">UtfEscape</span><br><span class="line">    : &#x27;\\&#x27; &#x27;u&#123;&#x27; HexDigit+ &#x27;&#125;&#x27;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">Digit</span><br><span class="line">    : [0-9]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">HexDigit</span><br><span class="line">    : [0-9a-fA-F]</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">COMMENT</span><br><span class="line">    : &#x27;--[&#x27; NESTED_STR &#x27;]&#x27; -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">LINE_COMMENT</span><br><span class="line">    : &#x27;--&#x27;</span><br><span class="line">    (                                               // --</span><br><span class="line">    | &#x27;[&#x27; &#x27;=&#x27;*                                      // --[==</span><br><span class="line">    | &#x27;[&#x27; &#x27;=&#x27;* ~(&#x27;=&#x27;|&#x27;[&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;) ~(&#x27;\r&#x27;|&#x27;\n&#x27;)*   // --[==AA</span><br><span class="line">    | ~(&#x27;[&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;) ~(&#x27;\r&#x27;|&#x27;\n&#x27;)*                // --AAA</span><br><span class="line">    ) (&#x27;\r\n&#x27;|&#x27;\r&#x27;|&#x27;\n&#x27;|EOF)</span><br><span class="line">    -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">WS  </span><br><span class="line">    : [ \t\u000C\r\n]+ -&gt; skip</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">SHEBANG</span><br><span class="line">    : &#x27;#&#x27; &#x27;!&#x27; ~(&#x27;\n&#x27;|&#x27;\r&#x27;)* -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.parak.top">Khighness</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.parak.top/posts/49052">https://www.parak.top/posts/49052</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自<a href="https://www.parak.top">炒菜K殿下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%80%E6%BA%90/">开源</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a><a class="post-meta__tags" href="/tags/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/">规则引擎</a></div><div class="post_share"><div class="social-share" data-image="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/top/bg-92.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/avatar/wepay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/avatar/wepay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/avatar/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/avatar/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/27845/"><img class="prev-cover" data-lazy-src="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/top/bg-93.jpg" onerror="onerror=null;src='https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/43737/"><img class="next-cover" data-lazy-src="https://khighness-blog.oss-cn-shanghai.aliyuncs.com/top/bg-91.jpg" onerror="onerror=null;src='https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">etcd-3-raft选举</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ANTLR-%E8%A7%A3%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">ANTLR 解析器生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR4%E7%9A%84%E6%96%B0%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">ANTLR4的新特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Start"><span class="toc-number">1.2.</span> <span class="toc-text">Quick Start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VS-Code-ANTLR4-%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">VS Code ANTLR4 插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">ANTLR 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.5.</span> <span class="toc-text">ANTLR 注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">ANTLR 标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E9%81%8D%E5%8E%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">ANTLR 遍历模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Listener-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E7%BB%93%E7%82%B9%E7%9B%91%E5%90%AC%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">Listener (观察者模式，通过结点监听，触发处理方法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visitor-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%BB%E5%8A%A8%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">Visitor (访问者模式，主动遍历)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-ANTLR4"><span class="toc-number">1.8.</span> <span class="toc-text">Hello ANTLR4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ANTLR-%E5%85%83%E8%AF%AD%E8%A8%80"><span class="toc-number">1.8.1.</span> <span class="toc-text">ANTLR 元语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">实现一个语法分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%9A%84%E6%AD%A7%E4%B9%89"><span class="toc-number">1.8.3.</span> <span class="toc-text">语法的歧义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E6%9E%84%E5%BB%BA%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">使用语法分析树构建语言类应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">1.8.5.</span> <span class="toc-text">语法分析树监听器和访问器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">语法分析树监听器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">语法分析树访问器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.8.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E7%9A%84ANTLR%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.9.</span> <span class="toc-text">入门的ANTLR项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ANTLR%E5%B7%A5%E5%85%B7%E3%80%81%E8%BF%90%E8%A1%8C%E5%BA%93%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.1.</span> <span class="toc-text">ANTLR工具、运行库以及自动生成的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%AD%E6%B3%95%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">测试生成的语法生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E4%B8%8EJava%E7%A8%8B%E5%BA%8F%E9%9B%86%E6%88%90"><span class="toc-number">1.9.3.</span> <span class="toc-text">将生成的语法分析器与Java程序集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%BA%94%E7%94%A8"><span class="toc-number">1.9.4.</span> <span class="toc-text">构建一个语言类应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97"><span class="toc-number">1.10.</span> <span class="toc-text">ANTLR 快速指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">1.10.1.</span> <span class="toc-text">匹配算术表达式的语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%AE%BF%E9%97%AE%E5%99%A8%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text">利用访问器构建一个计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%9B%91%E5%90%AC%E5%99%A8%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.10.3.</span> <span class="toc-text">利用监听器构建一个翻译程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.10.4.</span> <span class="toc-text">定制语法分析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%AF%AD%E6%B3%95%E4%B8%AD%E5%B5%8C%E5%85%A5%E4%BB%BB%E6%84%8F%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">在语法中嵌入任意动作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%89%B9%E6%80%A7"><span class="toc-number">1.10.5.</span> <span class="toc-text">词法分析特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A4%E5%B2%9B%E8%AF%AD%E6%B3%95%EF%BC%9A%E5%A4%84%E7%90%86%E7%9B%B8%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">孤岛语法：处理相同文件中的不同格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">重写输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E6%B5%81%E9%80%81%E5%85%A5%E4%B8%8D%E5%90%8C%E9%80%9A%E9%81%93"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">将词法符号流送入不同通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.10.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E8%AE%BE%E8%AE%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">ANTLR 设计语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%8C%83%E4%BE%8B%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%8F%90%E5%8F%96%E8%AF%AD%E6%B3%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">从编程语言的范例代码中提取语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%8E%B0%E6%9C%89%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E4%B8%BA%E6%8C%87%E5%8D%97"><span class="toc-number">1.11.2.</span> <span class="toc-text">以现有的语法规范为指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ANTLR%E8%AF%AD%E6%B3%95%E8%AF%86%E5%88%AB%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.3.</span> <span class="toc-text">使用ANTLR语法识别常见的语言模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">序列模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%A4%9A%E4%B8%AA%E5%A4%87%E9%80%89%E5%88%86%E6%94%AF%EF%BC%89"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">选择模式（多个备选分支）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">词法符号依赖模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">嵌套模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E5%B7%A6%E9%80%92%E5%BD%92%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">1.11.4.</span> <span class="toc-text">处理优先级、左递归和结合性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8A%E5%8D%87-Precedence-Climbing-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.11.4.0.1.</span> <span class="toc-text">使用优先级上升(Precedence Climbing)算法解析表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.11.5.</span> <span class="toc-text">识别常见的词法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">匹配标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%95%B0%E5%AD%97"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">匹配数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">匹配字符串常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">1.11.5.4.</span> <span class="toc-text">匹配注释和空白字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%AE%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E7%95%8C%E7%BA%BF"><span class="toc-number">1.11.5.5.</span> <span class="toc-text">划定词法分析器和语法分析器的界线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.11.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR%E8%AF%AD%E6%B3%95%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.12.</span> <span class="toc-text">ANTLR语法实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90CSV%E6%96%87%E4%BB%B6"><span class="toc-number">1.12.1.</span> <span class="toc-text">解析CSV文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90JSON"><span class="toc-number">1.12.2.</span> <span class="toc-text">解析JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">JSON的语法规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">JSON 词法规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90DOT%E8%AF%AD%E8%A8%80"><span class="toc-number">1.12.3.</span> <span class="toc-text">解析DOT语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOT%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">DOT语言的语法规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOT%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">DOT语言的词法规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90Cymbol%E8%AF%AD%E8%A8%80"><span class="toc-number">1.12.4.</span> <span class="toc-text">解析Cymbol语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90R%E8%AF%AD%E8%A8%80"><span class="toc-number">1.12.5.</span> <span class="toc-text">解析R语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%AF%AD%E6%B3%95%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%80%A6"><span class="toc-number">1.13.</span> <span class="toc-text">将语法和程序的逻辑代码解耦</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%86%85%E5%B5%8C%E5%8A%A8%E4%BD%9C%E5%88%B0%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.13.1.</span> <span class="toc-text">从内嵌动作到监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E7%9B%91%E5%90%AC%E5%99%A8%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.13.2.</span> <span class="toc-text">使用语法分析树监听器编写程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E5%99%A8%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.13.3.</span> <span class="toc-text">使用访问器编写程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%87%E9%80%89%E5%88%86%E6%94%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E7%B2%BE%E7%A1%AE%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.4.</span> <span class="toc-text">标记备选分支以获取精确的事件方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95%E4%B8%AD%E5%85%B1%E4%BA%AB%E4%BF%A1%E6%81%AF"><span class="toc-number">1.13.5.</span> <span class="toc-text">在事件方法中共享信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95%E6%9D%A5%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">使用访问器方法来返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E6%9D%A5%E6%A8%A1%E6%8B%9F%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.13.5.2.</span> <span class="toc-text">使用栈来模拟返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="toc-number">1.13.5.3.</span> <span class="toc-text">标注语法分析树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.13.5.4.</span> <span class="toc-text">不同的数据共享方法对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%9C%9F%E5%AE%9E%E7%9A%84%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.14.</span> <span class="toc-text">构建真实的语言类应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BDCSV%E6%95%B0%E6%8D%AE"><span class="toc-number">1.14.1.</span> <span class="toc-text">加载CSV数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86JSON%E7%BF%BB%E8%AF%91%E6%88%90XML"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">将JSON翻译成XML</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%B0%83%E7%94%A8%E5%9B%BE"><span class="toc-number">1.14.2.</span> <span class="toc-text">生成调用图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.14.3.</span> <span class="toc-text">验证程序中符号的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8%E9%80%9F%E6%88%90"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">符号表速成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%99%A8%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">验证器的架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E8%A7%A3%E6%9E%90%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">定义和解析符号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">1.15.</span> <span class="toc-text">错误报告与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%85%A5%E9%97%A8%E5%A4%84%E7%90%86"><span class="toc-number">1.15.1.</span> <span class="toc-text">错误入门处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%92%8C%E8%BD%AC%E5%8F%91ANTLR%E7%9A%84%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="toc-number">1.15.2.</span> <span class="toc-text">修改和转发ANTLR的错误消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">1.15.3.</span> <span class="toc-text">自动错误恢复机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%89%AB%E6%8F%8F%E5%90%8E%E7%BB%AD%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E6%9D%A5%E6%81%A2%E5%A4%8D"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">通过扫描后续词法符号来恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">从不匹配的词法符号中恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AD%90%E8%A7%84%E5%88%99%E7%9A%84%E9%94%99%E8%AF%AF%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="toc-number">1.15.3.3.</span> <span class="toc-text">从子规则的错误中恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%AF%AD%E4%B9%89%E5%88%A4%E5%AE%9A"><span class="toc-number">1.15.3.4.</span> <span class="toc-text">捕获失败的语义判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BD"><span class="toc-number">1.15.3.5.</span> <span class="toc-text">错误恢复机制的防护措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8B%98%E8%AF%AF%E5%A4%87%E9%80%89%E5%88%86%E6%94%AF"><span class="toc-number">1.15.4.</span> <span class="toc-text">勘误备选分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9ANTLR%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.15.5.</span> <span class="toc-text">修改ANTLR的错误处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.15.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.16.</span> <span class="toc-text">ANTLR属性和动作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%A6%E5%8A%A8%E4%BD%9C%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">1.16.1.</span> <span class="toc-text">使用带动作的语法编写一个计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99%E4%B9%8B%E5%A4%96%E4%BD%BF%E7%94%A8%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">在语法规则之外使用动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%A7%84%E5%88%99%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.16.1.2.</span> <span class="toc-text">在规则中嵌入动作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8C%E8%A7%84%E5%88%99%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.16.2.</span> <span class="toc-text">访问词法符号和规则的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E5%9B%BA%E5%AE%9A%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">1.16.3.</span> <span class="toc-text">识别关键字不固定的语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89%E5%88%A4%E5%AE%9A%E4%BF%AE%E6%94%B9%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.17.</span> <span class="toc-text">使用语义判定修改语法分析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="toc-number">1.17.1.</span> <span class="toc-text">识别多种语言的多个版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.17.2.</span> <span class="toc-text">关闭词法符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E6%AD%A7%E4%B9%89%E6%80%A7%E6%96%87%E6%9C%AC"><span class="toc-number">1.17.3.</span> <span class="toc-text">识别歧义性文本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%ABC-%E4%B8%AD%E7%9A%84T-0"><span class="toc-number">1.17.3.1.</span> <span class="toc-text">正确识别C++中的T(0)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%ABC-%E4%B8%AD%E7%9A%84T-i"><span class="toc-number">1.17.3.2.</span> <span class="toc-text">正确识别C++中的T(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%ABC-%E4%B8%AD%E7%9A%84T-i-1"><span class="toc-number">1.17.3.3.</span> <span class="toc-text">正确识别C++中的T(i)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%89%8D%E5%90%91%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.3.4.</span> <span class="toc-text">解决前向引用问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7"><span class="toc-number">1.18.</span> <span class="toc-text">ANTLR词法分析技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E9%80%81%E5%85%A5%E4%B8%8D%E5%90%8C%E9%80%9A%E9%81%93"><span class="toc-number">1.18.1.</span> <span class="toc-text">将词法分析器送入不同通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E9%80%9A%E9%81%93"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">填充词法符号通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E9%9A%90%E8%97%8F%E9%80%9A%E9%81%93"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">访问隐藏通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%8D%E6%B3%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.18.2.</span> <span class="toc-text">上下文相关的词法问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E4%B8%BA%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">关键字作为标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%9C%80%E9%95%BF%E5%8C%B9%E9%85%8D%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%AD%A7%E4%B9%89%E6%80%A7"><span class="toc-number">1.18.2.2.</span> <span class="toc-text">避免最长匹配带来的歧义性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python%E6%8D%A2%E8%A1%8C%E7%AC%A6"><span class="toc-number">1.18.2.3.</span> <span class="toc-text">Python换行符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E5%AD%A4%E5%B2%9B"><span class="toc-number">1.18.3.</span> <span class="toc-text">字符流中孤岛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%AF%8D%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%A4%84%E7%90%86%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.18.3.1.</span> <span class="toc-text">使用词法模式处理上下文相关的词法符号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9XML%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.18.4.</span> <span class="toc-text">对XML进行语法分析和词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML%E8%A7%84%E8%8C%83%E8%BD%AC%E6%8D%A2%E4%B8%BAANTLR%E6%96%87%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-number">1.18.4.1.</span> <span class="toc-text">XML规范转换为ANTLR文法语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86XML%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%8C%96"><span class="toc-number">1.18.4.2.</span> <span class="toc-text">将XML词法符号化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR%E8%BF%90%E8%A1%8C%E6%97%B6API"><span class="toc-number">1.19.</span> <span class="toc-text">ANTLR运行时API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88"><span class="toc-number">1.19.1.</span> <span class="toc-text">包结构概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E5%99%A8"><span class="toc-number">1.19.2.</span> <span class="toc-text">识别器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E6%B5%81"><span class="toc-number">1.19.3.</span> <span class="toc-text">输入字符流和词法符号流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%92%8C%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%B7%A5%E5%8E%82"><span class="toc-number">1.19.4.</span> <span class="toc-text">词法符号和词法符号工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91"><span class="toc-number">1.19.5.</span> <span class="toc-text">语法分析树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%9B%91%E5%90%AC%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E7%AD%96%E7%95%A5"><span class="toc-number">1.19.6.</span> <span class="toc-text">错误监听器和监听策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E9%80%9F%E5%BA%A6"><span class="toc-number">1.19.7.</span> <span class="toc-text">提高语法分析器的速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E6%B5%81"><span class="toc-number">1.19.8.</span> <span class="toc-text">无缓冲的字符流和词法符号流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9ANTLR%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">1.19.9.</span> <span class="toc-text">修改ANTLR的代码生成机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E7%9B%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">1.20.</span> <span class="toc-text">移除直接左递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92%E5%A4%87%E9%80%89%E5%88%86%E6%94%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.20.1.</span> <span class="toc-text">直接左递归备选分支模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E9%80%92%E5%BD%92%E8%A7%84%E5%88%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.20.2.</span> <span class="toc-text">左递归规则转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR-%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83"><span class="toc-number">1.21.</span> <span class="toc-text">ANTLR 语法参考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="toc-number">1.21.1.</span> <span class="toc-text">语法词汇表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.21.1.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.21.1.2.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%B8%B8%E9%87%8F"><span class="toc-number">1.21.1.3.</span> <span class="toc-text">文本常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.21.1.4.</span> <span class="toc-text">动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.21.1.5.</span> <span class="toc-text">关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.21.2.</span> <span class="toc-text">语法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%AF%BC%E5%85%A5"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">语法导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%A3%B0%E6%98%8E"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">词法符号声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.21.2.3.</span> <span class="toc-text">语法级别的动作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.21.3.</span> <span class="toc-text">文法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E9%80%89%E5%88%86%E6%94%AF%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">1.21.3.1.</span> <span class="toc-text">备选分支的标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.21.3.2.</span> <span class="toc-text">规则上下文对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE"><span class="toc-number">1.21.3.3.</span> <span class="toc-text">规则元素标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%85%83%E7%B4%A0"><span class="toc-number">1.21.3.4.</span> <span class="toc-text">规则元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E8%A7%84%E5%88%99"><span class="toc-number">1.21.3.5.</span> <span class="toc-text">子规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">1.21.3.6.</span> <span class="toc-text">捕获异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="toc-number">1.21.4.</span> <span class="toc-text">规则属性定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8B%E8%A7%84%E5%88%99%E5%92%8C%E6%96%87%E4%BB%B6%E7%BB%93%E6%9D%9F%E7%AC%A6"><span class="toc-number">1.21.4.1.</span> <span class="toc-text">起始规则和文件结束符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E4%BD%9C%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">1.21.5.</span> <span class="toc-text">动作和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E7%AC%A6%E5%8F%B7%E5%B1%9E%E6%80%A7"><span class="toc-number">1.21.5.1.</span> <span class="toc-text">词法符号属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99%E5%B1%9E%E6%80%A7"><span class="toc-number">1.21.5.2.</span> <span class="toc-text">文法规则属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.21.5.3.</span> <span class="toc-text">动态作用域属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.21.6.</span> <span class="toc-text">词法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.21.6.1.</span> <span class="toc-text">词法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99%E5%85%83%E7%B4%A0"><span class="toc-number">1.21.6.2.</span> <span class="toc-text">词法规则元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.21.6.3.</span> <span class="toc-text">递归词法规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="toc-number">1.21.6.4.</span> <span class="toc-text">冗余字符串常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.21.6.5.</span> <span class="toc-text">词法规则动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.21.6.6.</span> <span class="toc-text">词法分析器指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%AD%90%E8%A7%84%E5%88%99"><span class="toc-number">1.21.7.</span> <span class="toc-text">通配符与非贪婪子规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E8%AF%8D%E6%B3%95%E5%AD%90%E8%A7%84%E5%88%99"><span class="toc-number">1.21.7.1.</span> <span class="toc-text">非贪婪词法子规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%96%87%E6%B3%95%E5%AD%90%E8%A7%84%E5%88%99"><span class="toc-number">1.21.7.2.</span> <span class="toc-text">非贪婪文法子规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%A4%E5%AE%9A"><span class="toc-number">1.21.8.</span> <span class="toc-text">语义判定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E5%B8%A6%E5%88%A4%E5%AE%9A%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%86%B3%E7%AD%96"><span class="toc-number">1.21.8.1.</span> <span class="toc-text">进行带判定的语法分析决策</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%8F%AF%E8%A7%81%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.21.8.2.</span> <span class="toc-text">寻找可见的判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E5%88%A4%E5%AE%9A"><span class="toc-number">1.21.8.3.</span> <span class="toc-text">使用上下文相关判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99%E4%B8%AD%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.21.8.4.</span> <span class="toc-text">词法规则中的判定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ANTLR-%E9%80%89%E9%A1%B9options"><span class="toc-number">1.21.9.</span> <span class="toc-text">ANTLR 选项options</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E9%80%89%E9%A1%B9"><span class="toc-number">1.21.9.1.</span> <span class="toc-text">语法选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E9%80%89%E9%A1%B9"><span class="toc-number">1.21.9.2.</span> <span class="toc-text">规则选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E5%85%83%E7%B4%A0%E9%80%89%E9%A1%B9"><span class="toc-number">1.21.9.3.</span> <span class="toc-text">规则元素选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ANTLR%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.21.9.4.</span> <span class="toc-text">ANTLR命令行参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANTLR4-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.22.</span> <span class="toc-text">ANTLR4 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">1.22.1.</span> <span class="toc-text">简单计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.22.2.</span> <span class="toc-text">简单C语言编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java9"><span class="toc-number">1.22.3.</span> <span class="toc-text">Java9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">1.22.4.</span> <span class="toc-text">Lua 解释器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: gray"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Khighness</div><div class="footer_custom_text"><a href="https://www.foreverblog.cn/" target="_blank" > <img src="https://img.foreverblog.cn/logo_en_default.png" alt="" style="width:auto;height:16px;"> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Py2eOHzSdrnxKPzKrOJaHJOq-9Nh9j0Va',
      appKey: '9eQhwuCgyshpYKn4rtEhqt4R',
      placeholder: '',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/Khighness/cdn/js/emotion.json',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick, mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://unpkg.com/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="//code.tidio.co/ao1f4qdjllf8yowzz7v5brdaejt42uoi.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>